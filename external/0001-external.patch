diff --git a/canutils/.travis.yml b/canutils/.travis.yml
new file mode 100644
index 0000000000..5c5e11e8c1
--- /dev/null
+++ b/canutils/.travis.yml
@@ -0,0 +1,164 @@
+language: c
+
+matrix:
+    include:
+
+# native
+
+        - env: test="x64 4.8.4 (make)"
+          os: linux
+          dist: trusty
+          compiler: gcc
+          script: make
+
+        - env: test="x64 4.8.4 (autotools)"
+          os: linux
+          dist: trusty
+          compiler: gcc
+          script: ./autogen.sh && ./configure CFLAGS="-Werror -Wno-unused-result" && make distcheck
+
+        - env: test="x64 5.0 (autotools)"
+          os: linux
+          dist: trusty
+          compiler: clang
+          script: ./autogen.sh && ./configure CFLAGS="-Werror -Wno-unused-result" && make distcheck
+
+        - env: test="x64 4.8.4 (CMake gcc)"
+          os: linux
+          dist: trusty
+          compiler: gcc
+          before_script:
+              - mkdir gcc_rel && cd gcc_rel
+              - cmake ..
+          script: make
+
+        - env: test="x64 5.0 (CMake clang)"
+          os: linux
+          dist: trusty
+          compiler: clang
+          before_script:
+              - mkdir clang_rel && cd clang_rel
+              - cmake ..
+          script: make
+
+        - env: test="x64 5.0 (CMake clang - Ninja) Debug"
+          os: linux
+          dist: trusty
+          compiler: clang
+          before_script:
+              - mkdir clang_ninja_dbg && cd clang_ninja_dbg
+              - cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug
+          script: ninja
+
+# ppc64le
+
+        - env: test="ppc64le 4.8.4 (make)"
+          os: linux
+          dist: trusty
+          compiler: gcc
+          script: make
+          arch: ppc64le
+
+        - env: test="ppc64le 4.8.4 (autotools)"
+          os: linux
+          dist: trusty
+          compiler: gcc
+          script: ./autogen.sh && ./configure CFLAGS="-Werror -Wno-unused-result" && make distcheck
+          arch: ppc64le
+
+        - env: test="ppc64le 5.0 (autotools)"
+          os: linux
+          dist: trusty
+          compiler: clang
+          script: ./autogen.sh && ./configure CFLAGS="-Werror -Wno-unused-result" && make distcheck
+          arch: ppc64le
+
+        - env: test="ppc64le 4.8.4 (CMake gcc)"
+          os: linux
+          dist: trusty
+          compiler: gcc
+          before_script:
+              - mkdir gcc_rel && cd gcc_rel
+              - cmake ..
+          script: make
+          arch: ppc64le
+
+        - env: test="ppc64le 5.0 (CMake clang)"
+          os: linux
+          dist: trusty
+          compiler: clang
+          before_script:
+              - mkdir clang_rel && cd clang_rel
+              - cmake ..
+          script: make
+          arch: ppc64le
+
+        - env: test="ppc64le 5.0 (CMake clang - Ninja) Debug"
+          os: linux
+          dist: trusty
+          compiler: clang
+          before_script:
+              - mkdir clang_ninja_dbg && cd clang_ninja_dbg
+              - cmake .. -GNinja -DCMAKE_BUILD_TYPE=Debug
+          script: ninja
+          arch: ppc64le
+
+# Android
+
+        - env: test="Android NDK (CMake)"
+          os: linux
+          language: android
+          android:
+              components:
+                  - build-tools-25.0.2
+          install:
+              - echo y | sdkmanager "ndk-bundle"
+              - echo y | sdkmanager "cmake;3.6.4111459"
+          before_script:
+              - export ANDROID_NDK_HOME=$ANDROID_HOME/ndk-bundle
+              - export ANDROID_CMAKE=$ANDROID_HOME/cmake/3.6.4111459/bin/cmake
+              - export ANDROID_TOOLCHAIN_FILE=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake
+          script:
+              - pushd . && mkdir android15_armeabiv7a_rel && cd android15_armeabiv7a_rel
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-15 -DANDROID_ABI=armeabi-v7a -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android15_x86_rel && cd android15_x86_rel
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-15 -DANDROID_ABI=x86 -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android21_arm64-v8a_rel && cd android21_arm64-v8a_rel
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-21 -DANDROID_ABI=arm64-v8a -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android21_x86_64_rel && cd android21_x86_64_rel
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-21 -DANDROID_ABI=x86_64 -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android15_armeabiv7a_dbg && cd android15_armeabiv7a_dbg
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-15 -DANDROID_ABI=armeabi-v7a -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android15_x86_dbg && cd android15_x86_dbg
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-15 -DANDROID_ABI=x86 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android21_arm64-v8a_dbg && cd android21_arm64-v8a_dbg
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-21 -DANDROID_ABI=arm64-v8a -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+              - pushd . && mkdir android21_x86_64_dbg && cd android21_x86_64_dbg
+              - $ANDROID_CMAKE -DANDROID_PLATFORM=android-21 -DANDROID_ABI=x86_64 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_TOOLCHAIN_FILE=$ANDROID_TOOLCHAIN_FILE ..
+              - make && popd
+
+addons:
+    apt:
+        packages:
+            - autoconf
+            - automake
+            - libtool
+            - m4
+            - cmake
+            - ninja-build
+        sources:
+            - ubuntu-toolchain-r-test
diff --git a/canutils/Android.bp b/canutils/Android.bp
new file mode 100644
index 0000000000..5bc90ff139
--- /dev/null
+++ b/canutils/Android.bp
@@ -0,0 +1,95 @@
+// Copyright (C) 2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["external_canutils_license"],
+}
+
+// Added automatically by a large-scale-change that took the approach of
+// 'apply every license found to every target'. While this makes sure we respect
+// every license restriction, it may not be entirely correct.
+//
+// e.g. GPL in an MIT project might only apply to the contrib/ directory.
+//
+// Please consider splitting the single license below into multiple licenses,
+// taking care not to lose any license_kind information, and overriding the
+// default license using the 'licenses: [...]' property on targets as needed.
+//
+// For unused files, consider creating a 'fileGroup' with "//visibility:private"
+// to attach the license to, and including a comment whether the files may be
+// used in the current project.
+// See: http://go/android-license-faq
+license {
+    name: "external_canutils_license",
+    visibility: [":__subpackages__"],
+    license_kinds: [
+        "SPDX-license-identifier-BSD",
+        "SPDX-license-identifier-MIT",
+        "SPDX-license-identifier-NCSA",
+        "legacy_notice",
+        "legacy_unencumbered",
+    ],
+    license_text: [
+        "LICENSE",
+    ],
+}
+
+cc_defaults {
+    name: "can-utils_defaults",
+
+    cflags: [
+	"-O2",
+	"-g",
+	"-W",
+	"-Wall",
+        "-Wno-unused-parameter",
+	"-DSO_RXQ_OVFL=40",
+	"-DPF_CAN=29",
+	"-DAF_CAN=PF_CAN",
+    ],
+    local_include_dirs: [
+        "include",
+    ],
+}
+
+cc_library {
+    name: "libcan",
+    defaults: ["can-utils_defaults"],
+    srcs: [
+        "lib.c",
+	"canframelen.c",
+    ],
+}
+
+cc_binary {
+    name: "candump",
+    defaults: ["can-utils_defaults"],
+    srcs: [
+        "candump.c",
+    ],
+    static_libs: [
+        "libcan",
+    ],
+}
+
+cc_binary {
+    name: "cansend",
+    defaults: ["can-utils_defaults"],
+    srcs: [
+        "cansend.c",
+    ],
+    static_libs: [
+        "libcan",
+    ],
+}
diff --git a/canutils/CMakeLists.txt b/canutils/CMakeLists.txt
new file mode 100644
index 0000000000..fea4171a1b
--- /dev/null
+++ b/canutils/CMakeLists.txt
@@ -0,0 +1,102 @@
+cmake_minimum_required(VERSION 3.3)
+
+project(can-utils LANGUAGES C)
+
+include (CheckSymbolExists)
+include (GNUInstallDirs)
+
+if(NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release)
+endif()
+
+add_definitions(-D_GNU_SOURCE)
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wno-parentheses")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-strict-aliasing")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DSO_RXQ_OVFL=40")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DPF_CAN=29")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DAF_CAN=PF_CAN")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DN_SLCAN=17")
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DSCM_TIMESTAMPING_OPT_STATS=54")
+
+include_directories (.)
+include_directories (./include)
+
+set(PROGRAMS_CANLIB
+    asc2log
+    canbusload
+    candump
+    cangen
+    canlogserver
+    canplayer
+    cansend
+    cansequence
+    log2asc
+    log2long
+)
+
+set(PROGRAMS_J1939
+    j1939acd
+    j1939cat
+    j1939spy
+    j1939sr
+    testj1939
+)
+
+set(PROGRAMS
+    ${PROGRAMS_CANLIB}
+    bcmserver
+    can-calc-bit-timing
+    canfdtest
+    cangw
+    cansniffer
+    isotpdump
+    isotpperf
+    isotprecv
+    isotpsend
+    isotpserver
+    isotpsniffer
+    isotptun
+    slcan_attach
+    slcand
+    slcanpty
+)
+
+add_executable(mcp251xfd-dump
+    mcp251xfd/mcp251xfd-dev-coredump.c
+    mcp251xfd/mcp251xfd-dump.c
+    mcp251xfd/mcp251xfd-main.c
+    mcp251xfd/mcp251xfd-regmap.c
+)
+
+if(NOT ANDROID)
+  list(APPEND PROGRAMS ${PROGRAMS_J1939})
+
+  add_library(j1939 STATIC
+      libj1939.c
+  )
+endif()
+
+add_library(can STATIC
+    lib.c
+    canframelen.c
+)
+
+foreach(name ${PROGRAMS})
+  add_executable(${name} ${name}.c)
+
+  if("${name}" IN_LIST PROGRAMS_J1939)
+    target_link_libraries(${name}
+        PRIVATE j1939
+    )
+  elseif("${name}" IN_LIST PROGRAMS_CANLIB)
+    target_link_libraries(${name}
+        PRIVATE can
+    )
+  endif()
+
+  install(TARGETS ${name} DESTINATION ${CMAKE_INSTALL_BINDIR})
+endforeach()
+
+
+ADD_CUSTOM_TARGET(uninstall "${CMAKE_COMMAND}" -P "${CMAKE_SOURCE_DIR}/cmake/make_uninstall.cmake")
diff --git a/canutils/GNUmakefile.am b/canutils/GNUmakefile.am
new file mode 100644
index 0000000000..02c37abcf3
--- /dev/null
+++ b/canutils/GNUmakefile.am
@@ -0,0 +1,122 @@
+ACLOCAL_AMFLAGS = -I config/m4
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/include \
+	-I$(top_builddir)/include \
+	$(linux_CFLAGS)
+
+# link every app against libcan, it's static so it wouldn't hurt
+LDADD = \
+	libcan.la
+
+noinst_HEADERS = \
+	canframelen.h \
+	lib.h \
+	libj1939.h \
+	terminal.h \
+	include/linux/can.h \
+	include/linux/can/bcm.h \
+	include/linux/can/error.h \
+	include/linux/can/gw.h \
+	include/linux/can/isotp.h \
+	include/linux/can/j1939.h \
+	include/linux/can/netlink.h \
+	include/linux/can/raw.h \
+	include/linux/can/vxcan.h \
+	include/linux/errqueue.h \
+	include/linux/kernel.h \
+	include/linux/net_tstamp.h \
+	include/linux/netlink.h
+
+noinst_LTLIBRARIES = \
+	libcan.la \
+	libj1939.la
+
+libcan_la_SOURCES = \
+	lib.c \
+	canframelen.c
+
+libj1939_la_SOURCES = \
+	libj1939.c
+
+mcp251xfd_dump_SOURCES = \
+	mcp251xfd/mcp251xfd-dev-coredump.c \
+	mcp251xfd/mcp251xfd-dump-userspace.h \
+	mcp251xfd/mcp251xfd-dump.c \
+	mcp251xfd/mcp251xfd-dump.h \
+	mcp251xfd/mcp251xfd-main.c \
+	mcp251xfd/mcp251xfd-regmap.c \
+	mcp251xfd/mcp251xfd.h
+
+bin_PROGRAMS = \
+	asc2log \
+	bcmserver \
+	can-calc-bit-timing \
+	canbusload \
+	candump \
+	canfdtest \
+	cangen \
+	cangw \
+	canlogserver \
+	canplayer \
+	cansend \
+	cansequence \
+	cansniffer \
+	isotpdump \
+	isotpperf \
+	isotprecv \
+	isotpsend \
+	isotpserver \
+	isotpsniffer \
+	isotptun \
+	j1939acd \
+	j1939cat \
+	j1939spy \
+	j1939sr \
+	log2asc \
+	log2long \
+	mcp251xfd-dump \
+	slcan_attach \
+	slcand \
+	slcanpty \
+	testj1939
+
+j1939acd_LDADD = libj1939.la
+j1939cat_LDADD = libj1939.la
+j1939spy_LDADD = libj1939.la
+j1939sr_LDADD = libj1939.la
+testj1939_LDADD = libj1939.la
+
+EXTRA_DIST = \
+	.travis.yml \
+	Android.mk \
+	README.md \
+	autogen.sh \
+	can-j1939-kickstart.md \
+	can-j1939.md \
+	mcp251xfd/99-devcoredump.rules \
+	mcp251xfd/devcoredump
+
+MAINTAINERCLEANFILES = \
+	configure \
+	GNUmakefile.in \
+	aclocal.m4 \
+	config/autoconf/compile \
+	config/autoconf/config.guess \
+	config/autoconf/config.sub \
+	config/autoconf/depcomp \
+	config/autoconf/install-sh \
+	config/autoconf/ltmain.sh \
+	config/autoconf/mdate-sh \
+	config/autoconf/missing \
+	config/autoconf/texinfo.tex \
+	config/m4/libtool.m4 \
+	config/m4/ltoptions.m4 \
+	config/m4/ltsugar.m4 \
+	config/m4/ltversion.m4 \
+	config/m4/lt~obsolete.m4 \
+	$(DIST_ARCHIVES)
+
+maintainer-clean-local:
+	-chmod -R a+rw $(distdir)
+	-rm -fr $(distdir)
diff --git a/canutils/LICENSE b/canutils/LICENSE
new file mode 100644
index 0000000000..3ae3bbf3f0
--- /dev/null
+++ b/canutils/LICENSE
@@ -0,0 +1,244 @@
+"iperf, Copyright (c) 2014-2020, The Regents of the University of California,
+through Lawrence Berkeley National Laboratory (subject to receipt of any 
+required approvals from the U.S. Dept. of Energy).  All rights reserved."
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+(1) Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+
+(2) Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation and/
+or other materials provided with the distribution.
+
+(3) Neither the name of the University of California, Lawrence Berkeley
+National Laboratory, U.S. Dept. of Energy nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+You are under no obligation whatsoever to provide any bug fixes, patches, or
+upgrades to the features, functionality or performance of the source code
+("Enhancements") to anyone; however, if you choose to make your Enhancements
+available either publicly, or directly to Lawrence Berkeley National
+Laboratory, without imposing a separate written license agreement for such
+Enhancements, then you hereby grant the following license: a  non-exclusive,
+royalty-free perpetual license to install, use, modify, prepare derivative
+works, incorporate into other computer software, distribute, and sublicense
+such enhancements or derivative works thereof, in binary and source code form.
+
+=====
+
+This software contains source code (src/cjson.{c,h}) that is:
+
+  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+
+=====
+
+This software contains source code (src/net.{c,h}) that is:
+
+  This software was developed as part of a project at MIT.
+
+  Copyright (c) 2005-2007 Russ Cox,
+		     Massachusetts Institute of Technology
+
+  Permission is hereby granted, free of charge, to any person obtaining
+  a copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, sublicense, and/or sell copies of the Software, and to
+  permit persons to whom the Software is furnished to do so, subject to
+  the following conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  ===
+
+  Contains parts of an earlier library that has:
+
+  /*
+   * The authors of this software are Rob Pike, Sape Mullender, and Russ Cox
+   *              Copyright (c) 2003 by Lucent Technologies.
+   * Permission to use, copy, modify, and distribute this software for any
+   * purpose without fee is hereby granted, provided that this entire notice
+   * is included in all copies of any software which is or includes a copy
+   * or modification of this software and in all copies of the supporting
+   * documentation for such software.
+   * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+   * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT TECHNOLOGIES MAKE ANY
+   * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
+   * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+  */
+
+=====
+
+This software contains source code (src/net.c) that is:
+
+/*
+ * Copyright (c) 2001 Eric Jackson <ericj@monkey.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+=====
+
+This software contains source code (src/queue.h) that is:
+
+  /*
+   * Copyright (c) 1991, 1993
+   *      The Regents of the University of California.  All rights reserved.
+   *
+   * Redistribution and use in source and binary forms, with or without
+   * modification, are permitted provided that the following conditions
+   * are met:
+   * 1. Redistributions of source code must retain the above copyright
+   *    notice, this list of conditions and the following disclaimer.
+   * 2. Redistributions in binary form must reproduce the above copyright
+   *    notice, this list of conditions and the following disclaimer in the
+   *    documentation and/or other materials provided with the distribution.
+   * 3. Neither the name of the University nor the names of its contributors
+   *    may be used to endorse or promote products derived from this software
+   *    without specific prior written permission.
+   *
+   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   * SUCH DAMAGE.
+   *
+   *      @(#)queue.h     8.5 (Berkeley) 8/20/94
+   */
+
+=====
+
+This software contains source code (src/units.{c.h}) that is:
+
+  /*---------------------------------------------------------------
+   * Copyright (c) 1999,2000,2001,2002,2003
+   * The Board of Trustees of the University of Illinois
+   * All Rights Reserved.
+   *---------------------------------------------------------------
+   * Permission is hereby granted, free of charge, to any person
+   * obtaining a copy of this software (Iperf) and associated
+   * documentation files (the "Software"), to deal in the Software
+   * without restriction, including without limitation the
+   * rights to use, copy, modify, merge, publish, distribute,
+   * sublicense, and/or sell copies of the Software, and to permit
+   * persons to whom the Software is furnished to do
+   * so, subject to the following conditions:
+   *
+   *
+   * Redistributions of source code must retain the above
+   * copyright notice, this list of conditions and
+   * the following disclaimers.
+   *
+   *
+   * Redistributions in binary form must reproduce the above
+   * copyright notice, this list of conditions and the following
+   * disclaimers in the documentation and/or other materials
+   * provided with the distribution.
+   *
+   *
+   * Neither the names of the University of Illinois, NCSA,
+   * nor the names of its contributors may be used to endorse
+   * or promote products derived from this Software without
+   * specific prior written permission.
+   *
+   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+   * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT
+   * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+   * ________________________________________________________________
+   * National Laboratory for Applied Network Research
+   * National Center for Supercomputing Applications
+   * University of Illinois at Urbana-Champaign
+   * http://www.ncsa.uiuc.edu
+   * ________________________________________________________________
+   *
+   * stdio.c
+   * by Mark Gates <mgates@nlanr.net>
+   * and Ajay Tirumalla <tirumala@ncsa.uiuc.edu>
+   * -------------------------------------------------------------------
+   * input and output numbers, converting with kilo, mega, giga
+   * ------------------------------------------------------------------- */
+
+=====
+
+This software contains source code (src/portable_endian.h) that is:
+
+// "License": Public Domain
+// I, Mathias Panzenb√∂ck, place this file hereby into the public domain. Use it at your own risk for whatever you like.
+
+=====
+
+
+
diff --git a/canutils/LICENSES/BSD-3-Clause b/canutils/LICENSES/BSD-3-Clause
new file mode 100644
index 0000000000..5858df50a1
--- /dev/null
+++ b/canutils/LICENSES/BSD-3-Clause
@@ -0,0 +1,27 @@
+Copyright (c) <year> <owner> . All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice,
+   this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from this
+   software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
diff --git a/canutils/LICENSES/GPL-2.0-only.txt b/canutils/LICENSES/GPL-2.0-only.txt
new file mode 100644
index 0000000000..2b7b643ff4
--- /dev/null
+++ b/canutils/LICENSES/GPL-2.0-only.txt
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.	This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.	Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.	For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.	If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.	For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy	<name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/canutils/LICENSES/Linux-syscall-note.txt b/canutils/LICENSES/Linux-syscall-note.txt
new file mode 100644
index 0000000000..3d7ab24a40
--- /dev/null
+++ b/canutils/LICENSES/Linux-syscall-note.txt
@@ -0,0 +1,12 @@
+ NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+ Also note that the only valid version of the GPL as far as the kernel
+ is concerned is _this_ particular version of the license (ie v2, not
+ v2.2 or v3.x or whatever), unless explicitly otherwise stated.
+
+			Linus Torvalds
diff --git a/canutils/Makefile b/canutils/Makefile
new file mode 100644
index 0000000000..fb526434af
--- /dev/null
+++ b/canutils/Makefile
@@ -0,0 +1,146 @@
+#
+#  Copyright (c) 2002-2005 Volkswagen Group Electronic Research
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions, the following disclaimer and
+#     the referenced file 'COPYING'.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Volkswagen nor the names of its contributors
+#     may be used to endorse or promote products derived from this software
+#     without specific prior written permission.
+#
+#  Alternatively, provided that this notice is retained in full, this
+#  software may be distributed under the terms of the GNU General
+#  Public License ("GPL") version 2 as distributed in the 'COPYING'
+#  file from the main directory of the linux kernel source.
+#
+#  The provided data structures and external interfaces from this code
+#  are not restricted to be used by modules with a GPL compatible license.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+#  DAMAGE.
+#
+#  Send feedback to <linux-can@vger.kernel.org>
+
+DESTDIR ?=
+PREFIX ?= /usr/local
+
+MAKEFLAGS := -k
+
+CFLAGS := -O2 -Wall -Wno-parentheses
+
+CPPFLAGS += \
+	-Iinclude \
+	-DAF_CAN=PF_CAN \
+	-DPF_CAN=29 \
+	-DSO_RXQ_OVFL=40 \
+	-DSCM_TIMESTAMPING_OPT_STATS=54 \
+	-D_FILE_OFFSET_BITS=64 \
+	-D_GNU_SOURCE
+
+PROGRAMS_CANGW := \
+	cangw
+
+PROGRAMS_ISOTP := \
+	isotpdump \
+	isotpperf \
+	isotprecv \
+	isotpsend \
+	isotpserver \
+	isotpsniffer \
+	isotptun
+
+PROGRAMS_J1939 := \
+	j1939acd \
+	j1939cat \
+	j1939spy \
+	j1939sr \
+	testj1939
+
+PROGRAMS_SLCAN := \
+	slcan_attach \
+	slcand
+
+PROGRAMS := \
+	$(PROGRAMS_CANGW) \
+	$(PROGRAMS_ISOTP) \
+	$(PROGRAMS_J1939) \
+	$(PROGRAMS_SLCAN) \
+	asc2log \
+	bcmserver \
+	can-calc-bit-timing \
+	canbusload \
+	candump \
+	canfdtest \
+	cangen \
+	cansequence \
+	canlogserver \
+	canplayer \
+	cansend \
+	cansniffer \
+	log2asc \
+	log2long \
+	mcp251xfd-dump \
+	slcanpty
+
+all: $(PROGRAMS)
+
+clean:
+	rm -f $(PROGRAMS) *.o mcp251xfd/*.o
+
+install:
+	mkdir -p $(DESTDIR)$(PREFIX)/bin
+	cp -f $(PROGRAMS) $(DESTDIR)$(PREFIX)/bin
+
+distclean: clean
+	rm -f $(PROGRAMS) $(LIBRARIES) *~
+
+asc2log.o:	lib.h
+candump.o:	lib.h
+cangen.o:	lib.h
+canlogserver.o:	lib.h
+canplayer.o:	lib.h
+cansend.o:	lib.h
+log2asc.o:	lib.h
+log2long.o:	lib.h
+j1939acd.o:	libj1939.h
+j1939cat.o:	libj1939.h
+j1939spy.o:	libj1939.h
+j1939sr.o:	libj1939.h
+testj1939.o:	libj1939.h
+canframelen.o:  canframelen.h
+
+asc2log:	asc2log.o	lib.o
+candump:	candump.o	lib.o
+cangen:		cangen.o	lib.o
+canlogserver:	canlogserver.o	lib.o
+canplayer:	canplayer.o	lib.o
+cansend:	cansend.o	lib.o
+cansequence:	cansequence.o	lib.o
+log2asc:	log2asc.o	lib.o
+log2long:	log2long.o	lib.o
+j1939acd:	j1939acd.o	libj1939.o
+j1939cat:	j1939cat.o	libj1939.o
+j1939spy:	j1939spy.o	libj1939.o
+j1939sr:	j1939sr.o	libj1939.o
+testj1939:	testj1939.o	libj1939.o
+canbusload:	canbusload.o	canframelen.o
+
+mcp251xfd-dump:	mcp251xfd/mcp251xfd-dev-coredump.o mcp251xfd/mcp251xfd-dump.o mcp251xfd/mcp251xfd-main.o mcp251xfd/mcp251xfd-regmap.o
+	$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@
diff --git a/canutils/README.md b/canutils/README.md
new file mode 100644
index 0000000000..4b3037bb69
--- /dev/null
+++ b/canutils/README.md
@@ -0,0 +1,78 @@
+<p align="center">
+<img src="https://github.com/linux-can/can-logos/raw/master/png/SocketCAN-logo-60dpi.png" alt="SocketCAN logo"/>
+</p>
+
+### SocketCAN userspace utilities and tools
+
+This repository contains some userspace utilities for Linux CAN
+subsystem (aka SocketCAN):
+
+#### Basic tools to display, record, generate and replay CAN traffic
+
+* candump : display, filter and log CAN data to files
+* canplayer : replay CAN logfiles
+* cansend : send a single frame
+* cangen : generate (random) CAN traffic
+* cansequence : send and check sequence of CAN frames with incrementing payload
+* cansniffer : display CAN data content differences
+
+#### CAN access via IP sockets
+* canlogserver : log CAN frames from a remote/local host
+* bcmserver : interactive BCM configuration (remote/local)
+* [socketcand](https://github.com/linux-can/socketcand) : use RAW/BCM/ISO-TP sockets via TCP/IP sockets
+* [cannelloni](https://github.com/mguentner/cannelloni) : UDP/SCTP based SocketCAN tunnel
+
+#### CAN in-kernel gateway configuration
+* cangw : CAN gateway userspace tool for netlink configuration
+
+#### CAN bus measurement and testing
+* canbusload : calculate and display the CAN busload
+* can-calc-bit-timing : userspace version of in-kernel bitrate calculation
+* canfdtest : Full-duplex test program (DUT and host part)
+
+#### ISO-TP tools [ISO15765-2:2016 for Linux](https://github.com/hartkopp/can-isotp)
+* isotpsend : send a single ISO-TP PDU
+* isotprecv : receive ISO-TP PDU(s)
+* isotpsniffer : 'wiretap' ISO-TP PDU(s)
+* isotpdump : 'wiretap' and interpret CAN messages (CAN_RAW)
+* isotpserver : IP server for simple TCP/IP <-> ISO 15765-2 bridging (ASCII HEX)
+* isotpperf : ISO15765-2 protocol performance visualisation
+* isotptun : create a bi-directional IP tunnel on CAN via ISO-TP
+
+#### J1939/ISOBus tools
+* j1939acd : address claim daemon
+* j1939cat : take a file and send and receive it over CAN
+* j1939spy : spy on J1939 messages using SOC_J1939
+* j1939sr : send/recv from stdin or to stdout
+* testj1939 : send/receive test packet
+
+Follow the link to see examples on how this tools can be used:
+[Kickstart guide to can-j1939 on linux](https://github.com/linux-can/can-utils/blob/master/can-j1939-kickstart.md)
+
+#### Log file converters
+* asc2log : convert ASC logfile to compact CAN frame logfile
+* log2asc : convert compact CAN frame logfile to ASC logfile
+* log2long : convert compact CAN frame representation into user readable
+
+#### Serial Line Discipline configuration (for slcan driver)
+* slcan_attach : userspace tool for serial line CAN interface configuration
+* slcand : daemon for serial line CAN interface configuration
+* slcanpty : creates a pty for applications using the slcan ASCII protocol
+
+#### CMake Project Generator
+* Place your build folder anywhere, passing CMake the path.  Relative or absolute.
+* Some examples using a build folder under the source tree root:
+* Android : ``cmake -DCMAKE_TOOLCHAIN_FILE=~/Android/Sdk/ndk-bundle/build/cmake/android.toolchain.cmake -DANDROID_PLATFORM=android-21 -DANDROID_ABI=armeabi-v7a .. && make``
+* Android Studio : Copy repo under your project's ``app`` folder, add ``add_subdirectory(can-utils)`` to your ``CMakeLists.txt`` file after ``cmake_minimum_required()``.  Generating project will build Debug/Release for all supported EABI types.  ie. arm64-v8a, armeabi-v7a, x86, x86_64.
+* Raspberry Pi : ``cmake -DCMAKE_TOOLCHAIN_FILE=~/rpi/tools/build/cmake/rpi.toolchain.cmake .. && make``
+* Linux : ``cmake -GNinja .. && ninja``
+* Linux Eclipse Photon (Debug) : ``CC=clang cmake -G"Eclipse CDT4 - Unix Makefiles" ../can-utils/ -DCMAKE_BUILD_TYPE=Debug -DCMAKE_ECLIPSE_VERSION=4.8.0``
+* To override the base installation directory use: ``CMAKE_INSTALL_PREFIX``
+  ie. ``CC=clang cmake -DCMAKE_INSTALL_PREFIX=./out .. && make install``
+
+### Additional Information:
+
+*   [SocketCAN Documentation (Linux Kernel)](https://www.kernel.org/doc/Documentation/networking/can.txt)
+*   [Elinux.org CAN Bus Page](http://elinux.org/CAN_Bus)
+*   [Debian Package Description](https://packages.debian.org/sid/can-utils)
+
diff --git a/canutils/asc2log.c b/canutils/asc2log.c
new file mode 100644
index 0000000000..ea6b486322
--- /dev/null
+++ b/canutils/asc2log.c
@@ -0,0 +1,542 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * asc2log.c - convert ASC logfile to compact CAN frame logfile
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
+#include <limits.h>
+
+#include <linux/can.h>
+#include <linux/can/error.h>
+#include <net/if.h>
+
+#include "lib.h"
+
+#define BUFLEN 400 /* CAN FD mode lines can be pretty long */
+
+extern int optind, opterr, optopt;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - convert ASC logfile to compact CAN frame logfile.\n", prg);
+	fprintf(stderr, "Usage: %s\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "\t-I <infile>\t(default stdin)\n");
+	fprintf(stderr, "\t-O <outfile>\t(default stdout)\n");
+}
+
+void prframe(FILE *file, struct timeval *tv, int dev, struct canfd_frame *cf, unsigned int max_dlen, char *extra_info) {
+
+	fprintf(file, "(%lu.%06lu) ", tv->tv_sec, tv->tv_usec);
+
+	if (dev > 0)
+		fprintf(file, "can%d ", dev-1);
+	else
+		fprintf(file, "canX ");
+
+	fprint_canframe(file, cf, extra_info, 0, max_dlen);
+}
+
+void get_can_id(struct canfd_frame *cf, char *idstring, int base) {
+
+	if (idstring[strlen(idstring)-1] == 'x') {
+		cf->can_id = CAN_EFF_FLAG;
+		idstring[strlen(idstring)-1] = 0;
+	} else
+		cf->can_id = 0;
+    
+	cf->can_id |= strtoul(idstring, NULL, base);
+}
+
+void calc_tv(struct timeval *tv, struct timeval *read_tv,
+	     struct timeval *date_tv, char timestamps, int dplace) {
+
+	if (dplace == 4) /* shift values having only 4 decimal places */
+		read_tv->tv_usec *= 100;                /* and need for 6 */
+
+	if (dplace == 5) /* shift values having only 5 decimal places */
+		read_tv->tv_usec *= 10;                /* and need for 6 */
+
+	if (timestamps == 'a') { /* absolute */
+
+		tv->tv_sec  = date_tv->tv_sec  + read_tv->tv_sec;
+		tv->tv_usec = date_tv->tv_usec + read_tv->tv_usec;
+
+	} else { /* relative */
+
+		if (((!tv->tv_sec) && (!tv->tv_usec)) && 
+		    (date_tv->tv_sec || date_tv->tv_usec)) {
+			tv->tv_sec  = date_tv->tv_sec; /* initial date/time */
+			tv->tv_usec = date_tv->tv_usec;
+		}
+
+		tv->tv_sec  += read_tv->tv_sec;
+		tv->tv_usec += read_tv->tv_usec;
+	}
+
+	if (tv->tv_usec >= 1000000) {
+		tv->tv_usec -= 1000000;
+		tv->tv_sec++;
+	}
+}
+
+void eval_can(char* buf, struct timeval *date_tvp, char timestamps, char base, int dplace, FILE *outfile) {
+
+	int interface;
+	static struct timeval tv; /* current frame timestamp */
+	static struct timeval read_tv; /* frame timestamp from ASC file */
+	struct canfd_frame cf;
+	struct can_frame *ccf = (struct can_frame *)&cf; /* for len8_dlc */
+	char rtr;
+	int dlc = 0;
+	int len = 0;
+	int data[8];
+	char tmp1[BUFLEN];
+	char dir[3]; /* 'Rx' or 'Tx' plus terminating zero */
+	char *extra_info;
+	int i, items;
+
+	/* check for ErrorFrames */
+	if (sscanf(buf, "%lu.%lu %d %s",
+		   &read_tv.tv_sec, &read_tv.tv_usec,
+		   &interface, tmp1) == 4) {
+
+		if (!strncmp(tmp1, "ErrorFrame", strlen("ErrorFrame"))) {
+
+			memset(&cf, 0, sizeof(cf));
+			/* do not know more than 'Error' */
+			cf.can_id = (CAN_ERR_FLAG | CAN_ERR_BUSERROR);
+			cf.len = CAN_ERR_DLC;
+
+			calc_tv(&tv, &read_tv, date_tvp, timestamps, dplace);
+			prframe(outfile, &tv, interface, &cf, CAN_MAX_DLEN, "\n");
+			fflush(outfile);
+			return;
+		}
+	}
+
+	/* 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00 */
+
+	/* check for CAN frames with (hexa)decimal values */
+	if (base == 'h')
+		items = sscanf(buf, "%lu.%lu %d %s %2s %c %x %x %x %x %x %x %x %x %x",
+			       &read_tv.tv_sec, &read_tv.tv_usec, &interface,
+			       tmp1, dir, &rtr, &dlc,
+			       &data[0], &data[1], &data[2], &data[3],
+			       &data[4], &data[5], &data[6], &data[7]);
+	else
+		items = sscanf(buf, "%lu.%lu %d %s %2s %c %x %d %d %d %d %d %d %d %d",
+			       &read_tv.tv_sec, &read_tv.tv_usec, &interface,
+			       tmp1, dir, &rtr, &dlc,
+			       &data[0], &data[1], &data[2], &data[3],
+			       &data[4], &data[5], &data[6], &data[7]);
+
+	if (items < 7 ) /* make sure we've read the dlc */
+		return;
+
+	/* dlc is one character hex value 0..F */
+	if (dlc > CAN_MAX_RAW_DLC)
+		return;
+
+	/* retrieve real data length */
+	if (dlc > CAN_MAX_DLC)
+		len = CAN_MAX_DLEN;
+	else
+		len = dlc;
+
+	if ((items == len + 7 ) || /* data frame */
+	    ((items == 6) && (rtr == 'r')) || /* RTR without DLC */
+	    ((items == 7) && (rtr == 'r'))) { /* RTR with DLC */
+
+		/* check for CAN ID with (hexa)decimal value */
+		if (base == 'h')
+			get_can_id(&cf, tmp1, 16);
+		else
+			get_can_id(&cf, tmp1, 10);
+
+		/* dlc > 8 => len == CAN_MAX_DLEN => fill len8_dlc value */
+		if (dlc > CAN_MAX_DLC)
+			ccf->len8_dlc = dlc;
+
+		if (strlen(dir) != 2) /* "Rx" or "Tx" */
+			return;
+
+		/* check for signed integer overflow */
+		if (dplace == 4 && read_tv.tv_usec >= INT_MAX / 100)
+			return;
+
+		if (dplace == 5 && read_tv.tv_usec >= INT_MAX / 10)
+			return;
+
+		if (dir[0] == 'R')
+			extra_info = " R\n";
+		else
+			extra_info = " T\n";
+
+		cf.len = len;
+		if (rtr == 'r')
+			cf.can_id |= CAN_RTR_FLAG;
+		else
+			for (i = 0; i < len; i++)
+				cf.data[i] = data[i] & 0xFFU;
+
+		calc_tv(&tv, &read_tv, date_tvp, timestamps, dplace);
+		prframe(outfile, &tv, interface, &cf, CAN_MAX_DLEN, extra_info);
+		fflush(outfile);
+	}
+}
+
+void eval_canfd(char* buf, struct timeval *date_tvp, char timestamps, int dplace, FILE *outfile) {
+
+	int interface;
+	static struct timeval tv; /* current frame timestamp */
+	static struct timeval read_tv; /* frame timestamp from ASC file */
+	struct canfd_frame cf = { 0 };
+	unsigned char brs, esi, ctmp;
+	unsigned int flags;
+	int dlc, dlen = 0;
+	char tmp1[BUFLEN];
+	char dir[3]; /* 'Rx' or 'Tx' plus terminating zero */
+	char *extra_info;
+	char *ptr;
+	int i;
+
+	/* The CANFD format is mainly in hex representation but <DataLength>
+	   and probably some content we skip anyway. Don't trust the docs! */
+
+	/* 21.671796 CANFD   1 Tx         11  msgCanFdFr1                      1 0 a 16 \
+	   00 00 00 00 00 00 00 00 00 00 00 00 00 00 59 c0		\
+	   100000  214   223040 80000000 46500250 460a0250 20011736 20010205 */
+
+	/* check for valid line without symbolic name */
+	if (sscanf(buf, "%lu.%lu %*s %d %2s %s %hhx %hhx %x %d ",
+		   &read_tv.tv_sec, &read_tv.tv_usec, &interface,
+		   dir, tmp1, &brs, &esi, &dlc, &dlen) != 9) {
+
+		/* check for valid line with a symbolic name */
+		if (sscanf(buf, "%lu.%lu %*s %d %2s %s %*s %hhx %hhx %x %d ",
+			   &read_tv.tv_sec, &read_tv.tv_usec, &interface,
+			   dir, tmp1, &brs, &esi, &dlc, &dlen) != 9) {
+
+			/* no valid CANFD format pattern */
+			return;
+		}
+	}
+
+	/* check for allowed (unsigned) value ranges */
+	if ((dlen > CANFD_MAX_DLEN) || (dlc > CANFD_MAX_DLC) ||
+	    (brs > 1) || (esi > 1))
+		return;
+
+	if (strlen(dir) != 2) /* "Rx" or "Tx" */
+		return;
+
+	/* check for signed integer overflow */
+	if (dplace == 4 && read_tv.tv_usec >= INT_MAX / 100)
+		return;
+
+	/* check for signed integer overflow */
+	if (dplace == 5 && read_tv.tv_usec >= INT_MAX / 10)
+		return;
+
+	if (dir[0] == 'R')
+		extra_info = " R\n";
+	else
+		extra_info = " T\n";
+
+	/* don't trust ASCII content - sanitize data length */
+	if (dlen != can_fd_dlc2len(can_fd_len2dlc(dlen)))
+		return;
+
+	get_can_id(&cf, tmp1, 16);
+
+	/* now search for the beginning of the data[] content */
+	sprintf(tmp1, " %x %x %x %2d ", brs, esi, dlc, dlen);
+
+	/* search for the pattern generated by real data */
+	ptr = strcasestr(buf, tmp1);
+	if (ptr == NULL)
+		return;
+
+	ptr += strlen(tmp1); /* start of ASCII hex frame data */
+
+	cf.len = dlen;
+
+	for (i = 0; i < dlen; i++) {
+		ctmp = asc2nibble(ptr[0]);
+		if (ctmp > 0x0F)
+			return;
+
+		cf.data[i] = (ctmp << 4);
+
+		ctmp = asc2nibble(ptr[1]);
+		if (ctmp > 0x0F)
+			return;
+
+		cf.data[i] |= ctmp;
+
+		ptr += 3; /* start of next ASCII hex byte */
+	}
+
+	/* skip MessageDuration and MessageLength to get Flags value */
+	if (sscanf(ptr, "   %*x %*x %x ", &flags) != 1)
+		return;
+
+	/* relevant flags in Flags field */
+#define ASC_F_RTR 0x00000010
+#define ASC_F_FDF 0x00001000
+#define ASC_F_BRS 0x00002000
+#define ASC_F_ESI 0x00004000
+
+	if (flags & ASC_F_FDF) {
+		dlen = CANFD_MAX_DLEN;
+		if (flags & ASC_F_BRS)
+			cf.flags |= CANFD_BRS;
+		if (flags & ASC_F_ESI)
+			cf.flags |= CANFD_ESI;
+	} else {
+		/* yes. The 'CANFD' format supports classic CAN content! */
+		dlen = CAN_MAX_DLEN;
+		if (flags & ASC_F_RTR) {
+			cf.can_id |= CAN_RTR_FLAG;
+			/* dlen is always 0 for classic CAN RTR frames
+			   but the DLC value is valid in RTR cases */
+			cf.len = dlc;
+			/* sanitize payload length value */
+			if (dlc > CAN_MAX_DLEN)
+				cf.len = CAN_MAX_DLEN;
+		}
+		/* check for extra DLC when having a Classic CAN with 8 bytes payload */
+		if ((cf.len == CAN_MAX_DLEN) && (dlc > CAN_MAX_DLEN) && (dlc <= CAN_MAX_RAW_DLC)) {
+			struct can_frame *ccf = (struct can_frame *)&cf;
+
+			ccf->len8_dlc = dlc;
+		}
+	}
+
+	calc_tv(&tv, &read_tv, date_tvp, timestamps, dplace);
+	prframe(outfile, &tv, interface, &cf, dlen, extra_info);
+	fflush(outfile);
+
+	/* No support for really strange CANFD ErrorFrames format m( */
+}
+
+int get_date(struct timeval *tv, char *date) {
+
+	struct tm tms;
+	unsigned int msecs = 0;
+
+	if (strcasestr(date, " pm ") != NULL) {
+		/* assume EN/US date due to existing am/pm field */
+
+		if (!setlocale(LC_TIME, "en_US")) {
+			fprintf(stderr, "Setting locale to 'en_US' failed!\n");
+			return 1;
+		}
+
+		if (!strptime(date, "%B %d %I:%M:%S %p %Y", &tms)) {
+			/* The string might contain a milliseconds value which strptime()
+			   does not support. So we read the ms value into the year variable
+			   before parsing the real year value (hack) */
+			if (!strptime(date, "%B %d %I:%M:%S.%Y %p %Y", &tms))
+				return 1;
+			sscanf(date, "%*s %*d %*d:%*d:%*d.%3u ", &msecs);
+		}
+
+	} else {
+		/* assume DE date due to non existing am/pm field */
+
+		if (!setlocale(LC_TIME, "de_DE")) {
+			fprintf(stderr, "Setting locale to 'de_DE' failed!\n");
+			return 1;
+		}
+
+		if (!strptime(date, "%B %d %H:%M:%S %Y", &tms)) {
+			/* The string might contain a milliseconds value which strptime()
+			   does not support. So we read the ms value into the year variable
+			   before parsing the real year value (hack) */
+			if (!strptime(date, "%B %d %H:%M:%S.%Y %Y", &tms))
+				return 1;
+			sscanf(date, "%*s %*d %*d:%*d:%*d.%3u ", &msecs);
+		}
+	}
+
+	//printf("h %d m %d s %d ms %03d d %d m %d y %d\n",
+	//tms.tm_hour, tms.tm_min, tms.tm_sec, msecs,
+	//tms.tm_mday, tms.tm_mon+1, tms.tm_year+1900);
+
+	tv->tv_sec = mktime(&tms);
+	tv->tv_usec = msecs * 1000;
+
+	if (tv->tv_sec < 0)
+		return 1;
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	char buf[BUFLEN], tmp1[BUFLEN], tmp2[BUFLEN];
+
+	FILE *infile = stdin;
+	FILE *outfile = stdout;
+	static int verbose;
+	static struct timeval tmp_tv; /* tmp frame timestamp from ASC file */
+	static struct timeval date_tv; /* date of the ASC file */
+	static int dplace; /* decimal place 4, 5 or 6 or uninitialized */
+	static char base; /* 'd'ec or 'h'ex */
+	static char timestamps; /* 'a'bsolute or 'r'elative */
+	int opt;
+
+	while ((opt = getopt(argc, argv, "I:O:v?")) != -1) {
+		switch (opt) {
+		case 'I':
+			infile = fopen(optarg, "r");
+			if (!infile) {
+				perror("infile");
+				return 1;
+			}
+			break;
+
+		case 'O':
+			outfile = fopen(optarg, "w");
+			if (!outfile) {
+				perror("outfile");
+				return 1;
+			}
+			break;
+
+		case 'v':
+			verbose = 1;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			return 0;
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			return 1;
+			break;
+		}
+	}
+
+
+	while (fgets(buf, BUFLEN-1, infile)) {
+
+		if (!dplace) { /* the representation of a valid CAN frame not known */
+
+			/* check for base and timestamp entries in the header */
+			if ((!base) &&
+			    (sscanf(buf, "base %s timestamps %s", tmp1, tmp2) == 2)) {
+				base = tmp1[0];
+				timestamps = tmp2[0];
+				if (verbose)
+					printf("base %c timestamps %c\n", base, timestamps);
+				if ((base != 'h') && (base != 'd')) {
+					printf("invalid base %s (must be 'hex' or 'dez')!\n",
+					       tmp1);
+					return 1;
+				}
+				if ((timestamps != 'a') && (timestamps != 'r')) {
+					printf("invalid timestamps %s (must be 'absolute'"
+					       " or 'relative')!\n", tmp2);
+					return 1;
+				}
+				continue;
+			}
+
+			/* check for the original logging date in the header */ 
+			if ((!date_tv.tv_sec) &&
+			    (!strncmp(buf, "date", 4))) {
+
+				if (get_date(&date_tv, &buf[9])) { /* skip 'date day ' */
+					fprintf(stderr, "Not able to determine original log "
+						"file date. Using current time.\n");
+					/* use current date as default */
+					gettimeofday(&date_tv, NULL);
+				}
+				if (verbose)
+					printf("date %lu => %s", date_tv.tv_sec, ctime(&date_tv.tv_sec));
+				continue;
+			}
+
+			/* check for decimal places length in valid CAN frames */
+			if (sscanf(buf, "%lu.%s %s ", &tmp_tv.tv_sec, tmp2,
+				   tmp1) != 3)
+				continue; /* dplace remains zero until first found CAN frame */
+
+			dplace = strlen(tmp2);
+			if (verbose)
+				printf("decimal place %d, e.g. '%s'\n", dplace,
+				       tmp2);
+			if (dplace < 4 || dplace > 6) {
+				printf("invalid dplace %d (must be 4, 5 or 6)!\n",
+				       dplace);
+				return 1;
+			}
+		}
+
+		/* the representation of a valid CAN frame is known here */
+		/* so try to get CAN frames and ErrorFrames and convert them */
+
+		/* check classic CAN format or the CANFD tag which can take both types */
+		if (sscanf(buf, "%lu.%lu %s ", &tmp_tv.tv_sec,  &tmp_tv.tv_usec, tmp1) == 3){
+			if (!strncmp(tmp1, "CANFD", 5))
+				eval_canfd(buf, &date_tv, timestamps, dplace, outfile);
+			else
+				eval_can(buf, &date_tv, timestamps, base, dplace, outfile);
+		}
+	}
+	fclose(outfile);
+	fclose(infile);
+	return 0;
+}
diff --git a/canutils/autogen.sh b/canutils/autogen.sh
new file mode 100755
index 0000000000..6d1c20a24f
--- /dev/null
+++ b/canutils/autogen.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+#
+# usage:
+#
+# banner <target name>
+#
+banner() {
+	echo
+	TG=`echo $1 | sed -e "s,/.*/,,g"`
+	LINE=`echo $TG |sed -e "s/./-/g"`
+	echo $LINE
+	echo $TG
+	echo $LINE
+	echo
+}
+
+banner "autoreconf"
+
+autoreconf --force --install -Wall || exit $?
+
+banner "Finished"
diff --git a/canutils/bcmserver.c b/canutils/bcmserver.c
new file mode 100644
index 0000000000..8b8288a532
--- /dev/null
+++ b/canutils/bcmserver.c
@@ -0,0 +1,365 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * tst-bcm-server.c
+ *
+ * Test program that implements a socket server which understands ASCII
+ * messages for simple broadcast manager frame send commands.
+ *
+ * < interface command ival_s ival_us can_id can_dlc [data]* >
+ *
+ * Only the items 'can_id' and 'data' are given in (ASCII) hexadecimal values.
+ *
+ * ## TX path:
+ *
+ * The commands are 'A'dd, 'U'pdate, 'D'elete and 'S'end.
+ * e.g.
+ *
+ * Send the CAN frame 123#1122334455667788 every second on vcan1
+ * < vcan1 A 1 0 123 8 11 22 33 44 55 66 77 88 >
+ *
+ * Send the CAN frame 123#1122334455667788 every 10 usecs on vcan1
+ * < vcan1 A 0 10 123 8 11 22 33 44 55 66 77 88 >
+ *
+ * Send the CAN frame 123#42424242 every 20 msecs on vcan1
+ * < vcan1 A 0 20000 123 4 42 42 42 42 >
+ *
+ * Update the CAN frame 123#42424242 with 123#112233 - no change of timers
+ * < vcan1 U 0 0 123 3 11 22 33 >
+ *
+ * Delete the cyclic send job from above
+ * < vcan1 D 0 0 123 0 >
+ *
+ * Send a single CAN frame without cyclic transmission
+ * < can0 S 0 0 123 0 >
+ *
+ * When the socket is closed the cyclic transmissions are terminated.
+ *
+ * ## RX path:
+ *
+ * The commands are 'R'eceive setup, 'F'ilter ID Setup and 'X' for delete.
+ * e.g.
+ *
+ * Receive CAN ID 0x123 from vcan1 and check for changes in the first byte
+ * < vcan1 R 0 0 123 1 FF >
+ *
+ * Receive CAN ID 0x123 from vcan1 and check for changes in given mask
+ * < vcan1 R 0 0 123 8 FF 00 F8 00 00 00 00 00 >
+ *
+ * As above but throttle receive update rate down to 1.5 seconds
+ * < vcan1 R 1 500000 123 8 FF 00 F8 00 00 00 00 00 >
+ *
+ * Filter for CAN ID 0x123 from vcan1 without content filtering
+ * < vcan1 F 0 0 123 0 >
+ *
+ * Delete receive filter ('R' or 'F') for CAN ID 0x123
+ * < vcan1 X 0 0 123 0 >
+ *
+ * CAN messages received by the given filters are send in the format:
+ * < interface can_id can_dlc [data]* >
+ *
+ * e.g. when receiving a CAN message from vcan1 with
+ * can_id 0x123 , data length 4 and data 0x11, 0x22, 0x33 and 0x44
+ *
+ * < vcan1 123 4 11 22 33 44 >
+ *
+ * ##
+ *
+ * Authors:
+ * Andre Naujoks (the socket server stuff)
+ * Oliver Hartkopp (the rest)
+ *
+ * Copyright (c) 2002-2009 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <errno.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/wait.h>
+
+#include <linux/can.h>
+#include <linux/can/bcm.h>
+
+#define MAXLEN 100
+#define FORMATSZ 80
+#define PORT 28600
+
+void childdied(int i)
+{
+	wait(NULL);
+}
+
+int main(void)
+{
+
+	int sl, sa, sc;
+	int i;
+	int idx = 0;
+	struct sockaddr_in  saddr, clientaddr;
+	struct sockaddr_can caddr;
+	socklen_t caddrlen = sizeof(caddr);
+	struct ifreq ifr;
+	fd_set readfds;
+	socklen_t sin_size = sizeof(clientaddr);
+	struct sigaction signalaction;
+	sigset_t sigset;
+
+	char buf[MAXLEN];
+	char format[FORMATSZ];
+	char rxmsg[50];
+
+	struct {
+		struct bcm_msg_head msg_head;
+		struct can_frame frame;
+	} msg;
+
+	if (snprintf(format, FORMATSZ, "< %%%ds %%c %%lu %%lu %%x %%hhu "
+		     "%%hhx %%hhx %%hhx %%hhx %%hhx %%hhx "
+		     "%%hhx %%hhx >", IFNAMSIZ-1) >= FORMATSZ-1)
+		exit(1);
+
+	sigemptyset(&sigset);
+	signalaction.sa_handler = &childdied;
+	signalaction.sa_mask = sigset;
+	signalaction.sa_flags = 0;
+	sigaction(SIGCHLD, &signalaction, NULL);  /* signal for dying child */
+
+	if((sl = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
+		perror("inetsocket");
+		exit(1);
+	}
+
+	saddr.sin_family = AF_INET;
+	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	saddr.sin_port = htons(PORT);
+
+	while(bind(sl,(struct sockaddr*)&saddr, sizeof(saddr)) < 0) {
+		struct timespec f = {
+			.tv_nsec = 100 * 1000 * 1000,
+		};
+
+		printf(".");fflush(NULL);
+		nanosleep(&f, NULL);
+	}
+
+	if (listen(sl,3) != 0) {
+		perror("listen");
+		exit(1);
+	}
+
+	while (1) { 
+		sa = accept(sl,(struct sockaddr *)&clientaddr, &sin_size);
+		if (sa > 0 ){
+			if (!fork())
+				break;
+			close(sa);
+		}
+		else {
+			if (errno != EINTR) {
+				/*
+				 * If the cause for the error was NOT the
+				 * signal from a dying child => give an error
+				 */
+				perror("accept");
+				exit(1);
+			}
+		}
+	}
+
+	/* open BCM socket */
+
+	if ((sc = socket(PF_CAN, SOCK_DGRAM, CAN_BCM)) < 0) {
+		perror("bcmsocket");
+		return 1;
+	}
+
+	memset(&caddr, 0, sizeof(caddr));
+	caddr.can_family = PF_CAN;
+	/* can_ifindex is set to 0 (any device) => need for sendto() */
+
+	if (connect(sc, (struct sockaddr *)&caddr, sizeof(caddr)) < 0) {
+		perror("connect");
+		return 1;
+	}
+
+	while (1) {
+
+		FD_ZERO(&readfds);
+		FD_SET(sc, &readfds);
+		FD_SET(sa, &readfds);
+
+		select((sc > sa)?sc+1:sa+1, &readfds, NULL, NULL, NULL);
+
+		if (FD_ISSET(sc, &readfds)) {
+
+			recvfrom(sc, &msg, sizeof(msg), 0,
+				 (struct sockaddr*)&caddr, &caddrlen);
+
+			ifr.ifr_ifindex = caddr.can_ifindex;
+			ioctl(sc, SIOCGIFNAME, &ifr);
+
+			sprintf(rxmsg, "< %s %03X %d ", ifr.ifr_name,
+				msg.msg_head.can_id, msg.frame.can_dlc);
+
+			for ( i = 0; i < msg.frame.can_dlc; i++)
+				sprintf(rxmsg + strlen(rxmsg), "%02X ",
+					msg.frame.data[i]);
+
+			/* delimiter '\0' for Adobe(TM) Flash(TM) XML sockets */
+			strcat(rxmsg, ">\0");
+
+			send(sa, rxmsg, strlen(rxmsg) + 1, 0);
+		}
+
+
+		if (FD_ISSET(sa, &readfds)) {
+
+			char cmd;
+			int items;
+
+			if (read(sa, buf+idx, 1) < 1)
+				exit(1);
+
+			if (!idx) {
+				if (buf[0] == '<')
+					idx = 1;
+
+				continue;
+			}
+
+			if (idx > MAXLEN-2) {
+				idx = 0;
+				continue;
+			}
+
+			if (buf[idx] != '>') {
+				idx++;
+				continue;
+			}
+
+			buf[idx+1] = 0;
+			idx = 0;
+
+			//printf("read '%s'\n", buf);
+
+			/* prepare bcm message settings */
+			memset(&msg, 0, sizeof(msg));
+			msg.msg_head.nframes = 1;
+
+			items = sscanf(buf, format,
+				       ifr.ifr_name,
+				       &cmd, 
+				       &msg.msg_head.ival2.tv_sec,
+				       &msg.msg_head.ival2.tv_usec,
+				       &msg.msg_head.can_id,
+				       &msg.frame.can_dlc,
+				       &msg.frame.data[0],
+				       &msg.frame.data[1],
+				       &msg.frame.data[2],
+				       &msg.frame.data[3],
+				       &msg.frame.data[4],
+				       &msg.frame.data[5],
+				       &msg.frame.data[6],
+				       &msg.frame.data[7]);
+
+			if (items < 6)
+				break;
+			if (msg.frame.can_dlc > 8)
+				break;
+			if (items != 6 + msg.frame.can_dlc)
+				break;
+
+			msg.frame.can_id = msg.msg_head.can_id;
+
+			switch (cmd) {
+			case 'S':
+				msg.msg_head.opcode = TX_SEND;
+				break;
+			case 'A':
+				msg.msg_head.opcode = TX_SETUP;
+				msg.msg_head.flags |= SETTIMER | STARTTIMER;
+				break;
+			case 'U':
+				msg.msg_head.opcode = TX_SETUP;
+				msg.msg_head.flags  = 0;
+				break;
+			case 'D':
+				msg.msg_head.opcode = TX_DELETE;
+				break;
+
+			case 'R':
+				msg.msg_head.opcode = RX_SETUP;
+				msg.msg_head.flags  = SETTIMER;
+				break;
+			case 'F':
+				msg.msg_head.opcode = RX_SETUP;
+				msg.msg_head.flags  = RX_FILTER_ID | SETTIMER;
+				break;
+			case 'X':
+				msg.msg_head.opcode = RX_DELETE;
+				break;
+			default:
+				printf("unknown command '%c'.\n", cmd);
+				exit(1);
+			}
+
+			if (!ioctl(sc, SIOCGIFINDEX, &ifr)) {
+				caddr.can_ifindex = ifr.ifr_ifindex;
+				sendto(sc, &msg, sizeof(msg), 0,
+				       (struct sockaddr*)&caddr, sizeof(caddr));
+			}
+		}
+	}
+
+	close(sc);
+	close(sa);
+
+	return 0;
+}
diff --git a/canutils/can-calc-bit-timing.c b/canutils/can-calc-bit-timing.c
new file mode 100644
index 0000000000..dc2a62c146
--- /dev/null
+++ b/canutils/can-calc-bit-timing.c
@@ -0,0 +1,1902 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/* can-calc-bit-timing.c: Calculate CAN bit timing parameters
+ *
+ * Copyright (C) 2008 Wolfgang Grandegger <wg@grandegger.com>
+ * Copyright (C) 2016, 2021, 2022 Marc Kleine-Budde <mkl@pengutronix.de>
+ *
+ * Derived from:
+ *   can_baud.c - CAN baudrate calculation
+ *   Code based on LinCAN sources and H8S2638 project
+ *   Copyright 2004-2006 Pavel Pisa - DCE FELK CVUT cz
+ *   Copyright 2005      Stanislav Marek
+ *   email:pisa@cmp.felk.cvut.cz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <errno.h>
+#include <getopt.h>
+#include <libgen.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <linux/can/netlink.h>
+#include <linux/types.h>
+
+enum {
+	OPT_TQ = UCHAR_MAX + 1,
+	OPT_PROP_SEG,
+	OPT_PHASE_SEG1,
+	OPT_PHASE_SEG2,
+	OPT_SJW,
+	OPT_BRP,
+	OPT_TSEG1,
+	OPT_TSEG2,
+	OPT_ALG,
+};
+
+/* imported from kernel */
+
+/**
+ * abs - return absolute value of an argument
+ * @x: the value.  If it is unsigned type, it is converted to signed type first.
+ *     char is treated as if it was signed (regardless of whether it really is)
+ *     but the macro's return type is preserved as char.
+ *
+ * Return: an absolute value of x.
+ */
+#define abs(x)	__abs_choose_expr(x, long long,				\
+		__abs_choose_expr(x, long,				\
+		__abs_choose_expr(x, int,				\
+		__abs_choose_expr(x, short,				\
+		__abs_choose_expr(x, char,				\
+		__builtin_choose_expr(					\
+			__builtin_types_compatible_p(typeof(x), char),	\
+			(char)({ signed char __x = (x); __x < 0 ? -__x:__x; }), \
+			((void)0)))))))
+
+#define __abs_choose_expr(x, type, other) __builtin_choose_expr(	\
+	__builtin_types_compatible_p(typeof(x),   signed type) ||	\
+	__builtin_types_compatible_p(typeof(x), unsigned type),		\
+	({ signed type __x = (x); __x < 0 ? -__x : __x; }), other)
+
+/*
+ * min()/max()/clamp() macros that also do
+ * strict type-checking.. See the
+ * "unnecessary" pointer comparison.
+ */
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+
+#define max(x, y) ({				\
+	typeof(x) _max1 = (x);			\
+	typeof(y) _max2 = (y);			\
+	(void) (&_max1 == &_max2);		\
+	_max1 > _max2 ? _max1 : _max2; })
+
+/**
+ * clamp - return a value clamped to a given range with strict typechecking
+ * @val: current value
+ * @lo: lowest allowable value
+ * @hi: highest allowable value
+ *
+ * This macro does strict typechecking of lo/hi to make sure they are of the
+ * same type as val.  See the unnecessary pointer comparisons.
+ */
+#define clamp(val, lo, hi) min((typeof(val))max(val, lo), hi)
+
+#define do_div(n, base) ({					\
+	uint32_t __base = (base);				\
+	uint32_t __rem;						\
+	__rem = ((uint64_t)(n)) % __base;			\
+	(n) = ((uint64_t)(n)) / __base;				\
+	__rem;							\
+})
+
+/* */
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+/* we don't want to see these prints */
+#define netdev_err(dev, format, arg...) do { } while (0)
+#define netdev_warn(dev, format, arg...) do { } while (0)
+
+/* define in-kernel-types */
+typedef __u64 u64;
+typedef __u32 u32;
+
+struct calc_ref_clk {
+	__u32 clk;	/* CAN system clock frequency in Hz */
+	const char *name;
+};
+
+/*
+ * minimal structs, just enough to be source level compatible
+ */
+struct can_priv {
+	struct can_clock clock;
+};
+
+struct net_device {
+	struct can_priv	priv;
+};
+
+struct calc_bittiming_const {
+	const struct can_bittiming_const bittiming_const;
+	const struct can_bittiming_const data_bittiming_const;
+
+	const struct calc_ref_clk ref_clk[16];
+
+	const void (*printf_btr)(struct can_bittiming *bt, bool hdr);
+	const void (*printf_data_btr)(struct can_bittiming *bt, bool hdr);
+};
+
+struct can_calc_bittiming {
+	int (*alg)(struct net_device *dev, struct can_bittiming *bt,
+		   const struct can_bittiming_const *btc);
+	const char *name;
+};
+
+struct calc_data {
+	const struct can_bittiming_const *bittiming_const;
+	const struct can_calc_bittiming *calc_bittiming;
+	const void (*printf_btr)(struct can_bittiming *bt, bool hdr);
+	const char *name;
+
+	const struct calc_ref_clk *ref_clks;
+	const unsigned int *bitrates;
+
+	unsigned int sample_point;
+
+	const struct calc_ref_clk *opt_ref_clk;
+	const unsigned int *opt_bitrates;
+	const unsigned int *opt_data_bitrates;
+	const struct can_bittiming *opt_bt;
+
+	bool quiet;
+};
+
+static inline void *netdev_priv(const struct net_device *dev)
+{
+	return (void *)&dev->priv;
+}
+
+static void print_usage(char *cmd)
+{
+	printf("%s - calculate CAN bit timing parameters.\n", cmd);
+	printf("Usage: %s [options] [<CAN-contoller-name>]\n"
+	       "Options:\n"
+	       "\t-q             don't print header line\n"
+	       "\t-l             list all support CAN controller names\n"
+	       "\t-b <bitrate>   arbitration bit-rate in bits/sec\n"
+	       "\t-d <bitrate>   data bit-rate in bits/sec\n"
+	       "\t-s <samp_pt>   sample-point in one-tenth of a percent\n"
+	       "\t               or 0 for CIA recommended sample points\n"
+	       "\t-c <clock>     real CAN system clock in Hz\n"
+	       "\t--alg <alg>    choose specified algorithm for bit-timing calculation\n"
+	       "\n"
+	       "Or supply low level bit timing parameters to decode them:\n"
+	       "\n"
+	       "\t--prop-seg     Propagation segment in TQs\n"
+	       "\t--phase-seg1   Phase buffer segment 1 in TQs\n"
+	       "\t--phase-seg2   Phase buffer segment 2 in TQs\n"
+	       "\t--sjw          Synchronisation jump width in TQs\n"
+	       "\t--brp          Bit-rate prescaler\n"
+	       "\t--tseg1        Time segment 1 = prop-seg + phase-seg1\n"
+	       "\t--tseg2        Time segment 2 = phase_seg2\n",
+	       cmd);
+}
+
+static void printf_btr_nop(struct can_bittiming *bt, bool hdr)
+{
+}
+
+#define RCAR_CAN_BCR_TSEG1(x)	(((x) & 0x0f) << 20)
+#define RCAR_CAN_BCR_BPR(x)	(((x) & 0x3ff) << 8)
+#define RCAR_CAN_BCR_SJW(x)	(((x) & 0x3) << 4)
+#define RCAR_CAN_BCR_TSEG2(x)	((x) & 0x07)
+
+static void printf_btr_rcar_can(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "CiBCR");
+	} else {
+		uint32_t bcr;
+
+		bcr = RCAR_CAN_BCR_TSEG1(bt->phase_seg1 + bt->prop_seg - 1) |
+			RCAR_CAN_BCR_BPR(bt->brp - 1) |
+			RCAR_CAN_BCR_SJW(bt->sjw - 1) |
+			RCAR_CAN_BCR_TSEG2(bt->phase_seg2 - 1);
+
+		printf("0x%08x", bcr << 8);
+	}
+}
+
+static void printf_btr_mcp251x(struct can_bittiming *bt, bool hdr)
+{
+	uint8_t cnf1, cnf2, cnf3;
+
+	if (hdr) {
+		printf("CNF1 CNF2 CNF3");
+	} else {
+		cnf1 = ((bt->sjw - 1) << 6) | (bt->brp - 1);
+		cnf2 = 0x80 | ((bt->phase_seg1 - 1) << 3) | (bt->prop_seg - 1);
+		cnf3 = bt->phase_seg2 - 1;
+		printf("0x%02x 0x%02x 0x%02x", cnf1, cnf2, cnf3);
+	}
+}
+
+static void printf_btr_mcp251xfd(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "NBTCFG");
+	} else {
+		uint32_t nbtcfg = ((bt->brp - 1) << 24) |
+			((bt->prop_seg + bt->phase_seg1 - 1) << 16) |
+			((bt->phase_seg2 - 1) << 8) |
+			(bt->sjw - 1);
+		printf("0x%08x", nbtcfg);
+	}
+}
+
+static void printf_btr_bxcan(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "CAN_BTR");
+	} else {
+		uint32_t btr;
+
+		btr = (((bt->brp -1) & 0x3ff) << 0) |
+			(((bt->prop_seg + bt->phase_seg1 -1) & 0xf) << 16) |
+			(((bt->phase_seg2 -1) & 0x7) << 20) |
+			(((bt->sjw -1) & 0x3) << 24);
+
+		printf("0x%08x", btr);
+	}
+}
+
+static void printf_btr_at91(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "CAN_BR");
+	} else {
+		uint32_t br = ((bt->phase_seg2 - 1) |
+			       ((bt->phase_seg1 - 1) << 4) |
+			       ((bt->prop_seg - 1) << 8) |
+			       ((bt->sjw - 1) << 12) |
+			       ((bt->brp - 1) << 16));
+		printf("0x%08x", br);
+	}
+}
+
+static void printf_btr_c_can(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%13s", "BTR BRPEXT");
+	} else {
+		uint32_t btr;
+		uint32_t brpext;
+
+		btr = (((bt->brp -1) & 0x3f) << 0) |
+			(((bt->sjw -1) & 0x3) << 6) |
+			(((bt->prop_seg + bt->phase_seg1 -1) & 0xf) << 8) |
+			(((bt->phase_seg2 -1) & 0x7) << 12);
+		brpext = ((bt->brp -1) >> 6) & 0xf;
+
+		printf("0x%04x 0x%04x", btr, brpext);
+	}
+}
+
+static void printf_btr_flexcan(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "CAN_CTRL");
+	} else {
+		uint32_t ctrl = (((bt->brp        - 1) << 24) |
+				 ((bt->sjw        - 1) << 22) |
+				 ((bt->phase_seg1 - 1) << 19) |
+				 ((bt->phase_seg2 - 1) << 16) |
+				 ((bt->prop_seg   - 1) <<  0));
+
+		printf("0x%08x", ctrl);
+	}
+}
+
+static void printf_btr_mcan(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "NBTP");
+	} else {
+		uint32_t nbtp;
+
+
+		nbtp = (((bt->brp -1) & 0x1ff) << 16) |
+			(((bt->sjw -1) & 0x7f) << 25) |
+			(((bt->prop_seg + bt->phase_seg1 -1) & 0xff) << 8) |
+			(((bt->phase_seg2 -1) & 0x7f) << 0);
+
+		printf("0x%08x", nbtp);
+	}
+}
+
+static void printf_btr_sja1000(struct can_bittiming *bt, bool hdr)
+{
+	uint8_t btr0, btr1;
+
+	if (hdr) {
+		printf("%9s", "BTR0 BTR1");
+	} else {
+		btr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);
+		btr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |
+			(((bt->phase_seg2 - 1) & 0x7) << 4);
+		printf("0x%02x 0x%02x", btr0, btr1);
+	}
+}
+
+static void printf_btr_ti_hecc(struct can_bittiming *bt, bool hdr)
+{
+	if (hdr) {
+		printf("%10s", "CANBTC");
+	} else {
+		uint32_t can_btc;
+
+		can_btc = (bt->phase_seg2 - 1) & 0x7;
+		can_btc |= ((bt->phase_seg1 + bt->prop_seg - 1)
+			    & 0xF) << 3;
+		can_btc |= ((bt->sjw - 1) & 0x3) << 8;
+		can_btc |= ((bt->brp - 1) & 0xFF) << 16;
+
+		printf("0x%08x", can_btc);
+	}
+}
+
+static const struct calc_bittiming_const can_calc_consts[] = {
+	{
+		.bittiming_const = {
+			.name = "rcar_can",
+			.tseg1_min = 4,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 65000000, },
+		},
+		.printf_btr = printf_btr_rcar_can,
+	}, {
+		.bittiming_const = {
+			.name = "rcar_canfd",
+			.tseg1_min = 2,
+			.tseg1_max = 128,
+			.tseg2_min = 2,
+			.tseg2_max = 32,
+			.sjw_max = 32,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "rcar_canfd",
+			.tseg1_min = 2,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 8,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	}, {
+		.bittiming_const = {
+			.name = "rcar_canfd (CC)",
+			.tseg1_min = 4,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+	}, {	/* -------- SPI -------- */
+		.bittiming_const = {
+			.name = "hi311x",
+			.tseg1_min = 2,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk =  24000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "mcp251x",
+			.tseg1_min = 3,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			/* The mcp251x uses half of the external OSC clock as the base clock */
+			{ .clk =  8000000 / 2, .name = "8 MHz OSC" },
+			{ .clk = 16000000 / 2, .name = "16 MHz OSC" },
+			{ .clk = 20000000 / 2, .name = "20 MHz OSC" },
+		},
+		.printf_btr = printf_btr_mcp251x,
+	}, {
+		.bittiming_const = {
+			.name = "mcp251xfd",
+			.tseg1_min = 2,
+			.tseg1_max = 256,
+			.tseg2_min = 1,
+			.tseg2_max = 128,
+			.sjw_max = 128,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "mcp251xfd",
+			.tseg1_min = 1,
+			.tseg1_max = 32,
+			.tseg2_min = 1,
+			.tseg2_max = 16,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+		.printf_btr = printf_btr_mcp251xfd,
+	}, {	/* -------- USB -------- */
+		.bittiming_const = {
+			.name = "usb_8dev",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 32000000, },
+		}
+	}, {
+		.bittiming_const = {
+			.name = "ems_usb",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 8000000, },
+		},
+	}, {
+
+#define ESD_USB2_TSEG1_MIN 1
+#define ESD_USB2_TSEG1_MAX 16
+#define ESD_USB2_TSEG2_MIN 1
+#define ESD_USB2_TSEG2_MAX 8
+#define ESD_USB2_SJW_MAX 4
+#define ESD_USB2_BRP_MIN 1
+#define ESD_USB2_BRP_MAX 1024
+#define ESD_USB2_BRP_INC 1
+
+#define ESD_USB2_CAN_CLOCK 60000000
+#define ESD_USBM_CAN_CLOCK 36000000
+
+		.bittiming_const = {
+			.name = "esd_usb2",
+			.tseg1_min = ESD_USB2_TSEG1_MIN,
+			.tseg1_max = ESD_USB2_TSEG1_MAX,
+			.tseg2_min = ESD_USB2_TSEG2_MIN,
+			.tseg2_max = ESD_USB2_TSEG2_MAX,
+			.sjw_max = ESD_USB2_SJW_MAX,
+			.brp_min = ESD_USB2_BRP_MIN,
+			.brp_max = ESD_USB2_BRP_MAX,
+			.brp_inc = ESD_USB2_BRP_INC,
+		},
+		.ref_clk = {
+			{ .clk = ESD_USB2_CAN_CLOCK, .name = "CAN-USB/2", },
+			{ .clk = ESD_USBM_CAN_CLOCK, .name = "CAN-USB/Micro", },
+		},
+	}, {	/* gs_usb */
+		.bittiming_const = {
+			.name = "bxcan",	// stm32f072
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 48000000, },
+		},
+		.printf_btr = printf_btr_bxcan,
+	}, {	/* gs_usb */
+		.bittiming_const = {
+			.name = "CANtact Pro",	// LPC65616
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "CANtact Pro",	// LPC65616
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 24000000, .name = "CANtact Pro (original)", },
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	}, {
+
+#define KVASER_USB_TSEG1_MIN 1
+#define KVASER_USB_TSEG1_MAX 16
+#define KVASER_USB_TSEG2_MIN 1
+#define KVASER_USB_TSEG2_MAX 8
+#define KVASER_USB_SJW_MAX 4
+#define KVASER_USB_BRP_MIN 1
+#define KVASER_USB_BRP_MAX 64
+#define KVASER_USB_BRP_INC 1
+
+		.bittiming_const = {
+			.name = "kvaser_usb",
+			.tseg1_min = KVASER_USB_TSEG1_MIN,
+			.tseg1_max = KVASER_USB_TSEG1_MAX,
+			.tseg2_min = KVASER_USB_TSEG2_MIN,
+			.tseg2_max = KVASER_USB_TSEG2_MAX,
+			.sjw_max = KVASER_USB_SJW_MAX,
+			.brp_min = KVASER_USB_BRP_MIN,
+			.brp_max = KVASER_USB_BRP_MAX,
+			.brp_inc = KVASER_USB_BRP_INC,
+		},
+		.ref_clk = {
+			{ .clk = 8000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "kvaser_usb_kcan",
+			.tseg1_min = 1,
+			.tseg1_max = 255,
+			.tseg2_min = 1,
+			.tseg2_max = 32,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 8192,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "kvaser_usb_kcan",
+			.tseg1_min = 1,
+			.tseg1_max = 255,
+			.tseg2_min = 1,
+			.tseg2_max = 32,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 8192,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 80000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "kvaser_usb_flex",
+			.tseg1_min = 4,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 24000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "pcan_usb_pro",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 56000000, },
+		},
+	}, {
+
+#define PUCAN_TSLOW_BRP_BITS 10
+#define PUCAN_TSLOW_TSGEG1_BITS 8
+#define PUCAN_TSLOW_TSGEG2_BITS 7
+#define PUCAN_TSLOW_SJW_BITS 7
+
+#define PUCAN_TFAST_BRP_BITS 10
+#define PUCAN_TFAST_TSGEG1_BITS 5
+#define PUCAN_TFAST_TSGEG2_BITS 4
+#define PUCAN_TFAST_SJW_BITS 4
+
+		.bittiming_const = {
+			.name = "pcan_usb_fd",
+			.tseg1_min = 1,
+			.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),
+			.tseg2_min = 1,
+			.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),
+			.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),
+			.brp_min = 1,
+			.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "pcan_usb_fd",
+			.tseg1_min = 1,
+			.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),
+			.tseg2_min = 1,
+			.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),
+			.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),
+			.brp_min = 1,
+			.brp_max = (1 << PUCAN_TFAST_BRP_BITS),
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 80000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "softing",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 32,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 8000000, },
+			{ .clk = 16000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "at91",
+			.tseg1_min = 4,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 2,
+			.brp_max = 128,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 99532800, .name = "ronetix PM9263", },
+			{ .clk = 100000000, },
+		},
+		.printf_btr = printf_btr_at91,
+	}, {
+		.bittiming_const = {
+			.name = "cc770",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 8000000 },
+		}
+	}, {
+		.bittiming_const = {
+			.name = "c_can",
+			.tseg1_min = 2,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 24000000, },
+		},
+		.printf_btr = printf_btr_c_can,
+	}, {
+		.bittiming_const = {
+			.name = "flexcan",
+			.tseg1_min = 4,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 24000000, .name = "mx28" },
+			{ .clk = 30000000, .name = "mx6" },
+			{ .clk = 49875000, },
+			{ .clk = 66000000, },
+			{ .clk = 66500000, .name = "mx25"},
+			{ .clk = 66666666, },
+			{ .clk = 83368421, .name = "vybrid" },
+		},
+		.printf_btr = printf_btr_flexcan,
+	}, {
+		.bittiming_const = {
+			.name = "flexcan-fd",
+			.tseg1_min = 2,
+			.tseg1_max = 96,
+			.tseg2_min = 2,
+			.tseg2_max = 32,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "flexcan-fd",
+			.tseg1_min = 2,
+			.tseg1_max = 39,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	}, {
+
+#define GRCAN_CONF_PS1_MIN 1
+#define GRCAN_CONF_PS1_MAX 15
+#define GRCAN_CONF_PS2_MIN 2
+#define GRCAN_CONF_PS2_MAX 8
+#define GRCAN_CONF_RSJ_MAX 4
+#define GRCAN_CONF_SCALER_MIN 0
+#define GRCAN_CONF_SCALER_MAX 255
+#define GRCAN_CONF_SCALER_INC 1
+
+		.bittiming_const = {
+			.name = "grcan",
+			.tseg1_min = GRCAN_CONF_PS1_MIN + 1,
+			.tseg1_max = GRCAN_CONF_PS1_MAX + 1,
+			.tseg2_min = GRCAN_CONF_PS2_MIN,
+			.tseg2_max = GRCAN_CONF_PS2_MAX,
+			.sjw_max = GRCAN_CONF_RSJ_MAX,
+			.brp_min = GRCAN_CONF_SCALER_MIN + 1,
+			.brp_max = GRCAN_CONF_SCALER_MAX + 1,
+			.brp_inc = GRCAN_CONF_SCALER_INC,
+		},
+	}, {
+		.bittiming_const = {
+			.name = "ifi_canfd",
+			.tseg1_min = 1,
+			.tseg1_max = 256,
+			.tseg2_min = 2,
+			.tseg2_max = 256,
+			.sjw_max = 128,
+			.brp_min = 2,
+			.brp_max = 512,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "ifi_canfd",
+			.tseg1_min = 1,
+			.tseg1_max = 256,
+			.tseg2_min = 2,
+			.tseg2_max = 256,
+			.sjw_max = 128,
+			.brp_min = 2,
+			.brp_max = 512,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	}, {
+		.bittiming_const = {
+			.name = "janz-ican3",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 8000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "kvaser_pciefd",
+			.tseg1_min = 1,
+			.tseg1_max = 512,
+			.tseg2_min = 1,
+			.tseg2_max = 32,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 8192,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "kvaser_pciefd",
+			.tseg1_min = 1,
+			.tseg1_max = 512,
+			.tseg2_min = 1,
+			.tseg2_max = 32,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 8192,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	}, {
+		.bittiming_const = {
+			.name = "mscan",
+			.tseg1_min = 4,
+			.tseg1_max = 16,
+			.tseg2_min = 2,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 32000000, },
+			{ .clk = 33000000, },
+			{ .clk = 33300000, },
+			{ .clk = 33333333, },
+			{ .clk = 66660000, .name = "mpc5121", },
+			{ .clk = 66666666, .name = "mpc5121" },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "mcan-v3.0",
+			.tseg1_min = 2,
+			.tseg1_max = 64,
+			.tseg2_min = 1,
+			.tseg2_max = 16,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 1024,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "mcan-v3.0",
+			.tseg1_min = 2,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 32,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+		.printf_btr = printf_btr_mcan,
+	}, {
+		.bittiming_const = {
+			.name = "mcan-v3.1+",
+			.tseg1_min = 2,
+			.tseg1_max = 256,
+			.tseg2_min = 2,
+			.tseg2_max = 128,
+			.sjw_max = 128,
+			.brp_min = 1,
+			.brp_max = 512,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "mcan-v3.1+",
+			.tseg1_min = 1,
+			.tseg1_max = 32,
+			.tseg2_min = 1,
+			.tseg2_max = 16,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 32,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+			{ .clk = 24000000, .name = "stm32mp1 - ck_hse" },
+			{ .clk = 24573875, .name = "stm32mp1 - pll3_1" },
+			{ .clk = 74250000, .name = "stm32mp1 - pll4_r" },
+			{ .clk = 29700000, .name = "stm32mp1 - pll4_q" },
+		},
+		.printf_btr = printf_btr_mcan,
+	}, {
+
+#define PUCAN_TSLOW_BRP_BITS 10
+#define PUCAN_TSLOW_TSGEG1_BITS 8
+#define PUCAN_TSLOW_TSGEG2_BITS 7
+#define PUCAN_TSLOW_SJW_BITS 7
+
+#define PUCAN_TFAST_BRP_BITS 10
+#define PUCAN_TFAST_TSGEG1_BITS 5
+#define PUCAN_TFAST_TSGEG2_BITS 4
+#define PUCAN_TFAST_SJW_BITS 4
+
+		.bittiming_const = {
+			.name = "peak_canfd",
+			.tseg1_min = 1,
+			.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),
+			.tseg2_min = 1,
+			.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),
+			.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),
+			.brp_min = 1,
+			.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "peak_canfd",
+			.tseg1_min = 1,
+			.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),
+			.tseg2_min = 1,
+			.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),
+			.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),
+			.brp_min = 1,
+			.brp_max = (1 << PUCAN_TFAST_BRP_BITS),
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, },
+			{ .clk = 24000000, },
+			{ .clk = 30000000, },
+			{ .clk = 40000000, },
+			{ .clk = 60000000, },
+			{ .clk = 80000000, },
+		},
+	}, {
+		.bittiming_const = {
+			.name = "sja1000",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 16000000 / 2, },
+			{ .clk = 24000000 / 2, .name = "f81601" },
+		},
+		.printf_btr = printf_btr_sja1000,
+	}, {
+		.bittiming_const = {
+			.name = "sun4i_can",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 64,
+			.brp_inc = 1,
+		},
+	}, {
+		.bittiming_const = {
+			.name = "ti_hecc",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 13000000, },
+		},
+		.printf_btr = printf_btr_ti_hecc,
+	}, {
+		.bittiming_const = {
+			.name = "xilinx_can",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 4,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+	}, {
+		.bittiming_const = {
+			.name = "xilinx_can_fd",
+			.tseg1_min = 1,
+			.tseg1_max = 64,
+			.tseg2_min = 1,
+			.tseg2_max = 16,
+			.sjw_max = 16,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "xilinx_can_fd",
+			.tseg1_min = 1,
+			.tseg1_max = 16,
+			.tseg2_min = 1,
+			.tseg2_max = 8,
+			.sjw_max = 8,
+			.brp_min = 1,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	}, {
+		.bittiming_const = {
+			.name = "xilinx_can_fd2",
+			.tseg1_min = 1,
+			.tseg1_max = 256,
+			.tseg2_min = 1,
+			.tseg2_max = 128,
+			.sjw_max = 128,
+			.brp_min = 2,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.data_bittiming_const = {
+			.name = "xilinx_can_fd2",
+			.tseg1_min = 1,
+			.tseg1_max = 32,
+			.tseg2_min = 1,
+			.tseg2_max = 16,
+			.sjw_max = 16,
+			.brp_min = 2,
+			.brp_max = 256,
+			.brp_inc = 1,
+		},
+		.ref_clk = {
+			{ .clk = 20000000, .name = "CIA recommendation"},
+			{ .clk = 40000000, .name = "CIA recommendation"},
+		},
+	},
+};
+
+static const unsigned int common_bitrates[] = {
+	1000000,
+	800000,
+	500000,
+	250000,
+	125000,
+	100000,
+	50000,
+	20000,
+	10000,
+	0
+};
+
+static const unsigned int common_data_bitrates[] = {
+	12000000,
+	10000000,
+	8000000,
+	5000000,
+	4000000,
+	2000000,
+	1000000,
+	0
+};
+
+#define CAN_CALC_MAX_ERROR 50 /* in one-tenth of a percent */
+#define CAN_CALC_SYNC_SEG 1
+
+/*
+ * Bit-timing calculation derived from:
+ *
+ * Code based on LinCAN sources and H8S2638 project
+ * Copyright 2004-2006 Pavel Pisa - DCE FELK CVUT cz
+ * Copyright 2005      Stanislav Marek
+ * email: pisa@cmp.felk.cvut.cz
+ *
+ * Calculates proper bit-timing parameters for a specified bit-rate
+ * and sample-point, which can then be used to set the bit-timing
+ * registers of the CAN controller. You can find more information
+ * in the header file linux/can/netlink.h.
+ */
+
+/*
+ * imported from v3.18-rc1~52^2~248^2~1
+ *
+ * b25a437206ed can: dev: remove unused variable from can_calc_bittiming() function
+ */
+#undef can_calc_bittiming
+#undef can_update_spt
+#define can_calc_bittiming can_calc_bittiming_v3_18
+#define can_update_spt can_update_spt_v3_18
+
+static int can_update_spt(const struct can_bittiming_const *btc,
+			  int sampl_pt, int tseg, int *tseg1, int *tseg2)
+{
+	*tseg2 = tseg + 1 - (sampl_pt * (tseg + 1)) / 1000;
+	if (*tseg2 < btc->tseg2_min)
+		*tseg2 = btc->tseg2_min;
+	if (*tseg2 > btc->tseg2_max)
+		*tseg2 = btc->tseg2_max;
+	*tseg1 = tseg - *tseg2;
+	if (*tseg1 > btc->tseg1_max) {
+		*tseg1 = btc->tseg1_max;
+		*tseg2 = tseg - *tseg1;
+	}
+	return 1000 * (tseg + 1 - *tseg2) / (tseg + 1);
+}
+
+static int can_calc_bittiming(struct net_device *dev, struct can_bittiming *bt,
+			      const struct can_bittiming_const *btc)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	long best_error = 1000000000, error = 0;
+	int best_tseg = 0, best_brp = 0, brp = 0;
+	int tsegall, tseg = 0, tseg1 = 0, tseg2 = 0;
+	int spt_error = 1000, spt = 0, sampl_pt;
+	long rate;
+	u64 v64;
+
+	/* Use CIA recommended sample points */
+	if (bt->sample_point) {
+		sampl_pt = bt->sample_point;
+	} else {
+		if (bt->bitrate > 800000)
+			sampl_pt = 750;
+		else if (bt->bitrate > 500000)
+			sampl_pt = 800;
+		else
+			sampl_pt = 875;
+	}
+
+	/* tseg even = round down, odd = round up */
+	for (tseg = (btc->tseg1_max + btc->tseg2_max) * 2 + 1;
+	     tseg >= (btc->tseg1_min + btc->tseg2_min) * 2; tseg--) {
+		tsegall = 1 + tseg / 2;
+		/* Compute all possible tseg choices (tseg=tseg1+tseg2) */
+		brp = priv->clock.freq / (tsegall * bt->bitrate) + tseg % 2;
+		/* chose brp step which is possible in system */
+		brp = (brp / btc->brp_inc) * btc->brp_inc;
+		if ((brp < btc->brp_min) || (brp > btc->brp_max))
+			continue;
+		rate = priv->clock.freq / (brp * tsegall);
+		error = bt->bitrate - rate;
+		/* tseg brp biterror */
+		if (error < 0)
+			error = -error;
+		if (error > best_error)
+			continue;
+		best_error = error;
+		if (error == 0) {
+			spt = can_update_spt(btc, sampl_pt, tseg / 2,
+					     &tseg1, &tseg2);
+			error = sampl_pt - spt;
+			if (error < 0)
+				error = -error;
+			if (error > spt_error)
+				continue;
+			spt_error = error;
+		}
+		best_tseg = tseg / 2;
+		best_brp = brp;
+		if (error == 0)
+			break;
+	}
+
+	if (best_error) {
+		/* Error in one-tenth of a percent */
+		error = (best_error * 1000) / bt->bitrate;
+		if (error > CAN_CALC_MAX_ERROR) {
+			netdev_err(dev,
+				   "bitrate error %ld.%ld%% too high\n",
+				   error / 10, error % 10);
+			return -EDOM;
+		} else {
+			netdev_warn(dev, "bitrate error %ld.%ld%%\n",
+				    error / 10, error % 10);
+		}
+	}
+
+	/* real sample point */
+	bt->sample_point = can_update_spt(btc, sampl_pt, best_tseg,
+					  &tseg1, &tseg2);
+
+	v64 = (u64)best_brp * 1000000000UL;
+	do_div(v64, priv->clock.freq);
+	bt->tq = (u32)v64;
+	bt->prop_seg = tseg1 / 2;
+	bt->phase_seg1 = tseg1 - bt->prop_seg;
+	bt->phase_seg2 = tseg2;
+
+	/* check for sjw user settings */
+	if (!bt->sjw || !btc->sjw_max)
+		bt->sjw = 1;
+	else {
+		/* bt->sjw is at least 1 -> sanitize upper bound to sjw_max */
+		if (bt->sjw > btc->sjw_max)
+			bt->sjw = btc->sjw_max;
+		/* bt->sjw must not be higher than tseg2 */
+		if (tseg2 < bt->sjw)
+			bt->sjw = tseg2;
+	}
+
+	bt->brp = best_brp;
+	/* real bit-rate */
+	bt->bitrate = priv->clock.freq / (bt->brp * (tseg1 + tseg2 + 1));
+
+	return 0;
+}
+
+/*
+ * imported from v4.8-rc1~140^2~304^2~11
+ *
+ * 7da29f97d6c8 can: dev: can-calc-bit-timing(): better sample point calculation
+ */
+#undef can_update_spt
+#undef can_calc_bittiming
+#define can_update_spt can_update_spt_v4_8
+#define can_calc_bittiming can_calc_bittiming_v4_8
+
+static int can_update_spt(const struct can_bittiming_const *btc,
+			  unsigned int spt_nominal, unsigned int tseg,
+			  unsigned int *tseg1_ptr, unsigned int *tseg2_ptr,
+			  unsigned int *spt_error_ptr)
+{
+	unsigned int spt_error, best_spt_error = UINT_MAX;
+	unsigned int spt, best_spt = 0;
+	unsigned int tseg1, tseg2;
+	int i;
+
+	for (i = 0; i <= 1; i++) {
+		tseg2 = tseg + CAN_CALC_SYNC_SEG - (spt_nominal * (tseg + CAN_CALC_SYNC_SEG)) / 1000 - i;
+		tseg2 = clamp(tseg2, btc->tseg2_min, btc->tseg2_max);
+		tseg1 = tseg - tseg2;
+		if (tseg1 > btc->tseg1_max) {
+			tseg1 = btc->tseg1_max;
+			tseg2 = tseg - tseg1;
+		}
+
+		spt = 1000 * (tseg + CAN_CALC_SYNC_SEG - tseg2) / (tseg + CAN_CALC_SYNC_SEG);
+		spt_error = abs(spt_nominal - spt);
+
+		if ((spt <= spt_nominal) && (spt_error < best_spt_error)) {
+			best_spt = spt;
+			best_spt_error = spt_error;
+			*tseg1_ptr = tseg1;
+			*tseg2_ptr = tseg2;
+		}
+	}
+
+	if (spt_error_ptr)
+		*spt_error_ptr = best_spt_error;
+
+	return best_spt;
+}
+
+static int can_calc_bittiming(struct net_device *dev, struct can_bittiming *bt,
+			      const struct can_bittiming_const *btc)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned int rate;		/* current bitrate */
+	unsigned int rate_error;	/* difference between current and nominal value */
+	unsigned int best_rate_error = UINT_MAX;
+	unsigned int spt_error;		/* difference between current and nominal value */
+	unsigned int best_spt_error = UINT_MAX;
+	unsigned int spt_nominal;	/* nominal sample point */
+	unsigned int best_tseg = 0;	/* current best value for tseg */
+	unsigned int best_brp = 0;	/* current best value for brp */
+	unsigned int brp, tsegall, tseg, tseg1 = 0, tseg2 = 0;
+	u64 v64;
+
+	/* Use CiA recommended sample points */
+	if (bt->sample_point) {
+		spt_nominal = bt->sample_point;
+	} else {
+		if (bt->bitrate > 800000)
+			spt_nominal = 750;
+		else if (bt->bitrate > 500000)
+			spt_nominal = 800;
+		else
+			spt_nominal = 875;
+	}
+
+	/* tseg even = round down, odd = round up */
+	for (tseg = (btc->tseg1_max + btc->tseg2_max) * 2 + 1;
+	     tseg >= (btc->tseg1_min + btc->tseg2_min) * 2; tseg--) {
+		tsegall = CAN_CALC_SYNC_SEG + tseg / 2;
+
+		/* Compute all possible tseg choices (tseg=tseg1+tseg2) */
+		brp = priv->clock.freq / (tsegall * bt->bitrate) + tseg % 2;
+
+		/* choose brp step which is possible in system */
+		brp = (brp / btc->brp_inc) * btc->brp_inc;
+		if ((brp < btc->brp_min) || (brp > btc->brp_max))
+			continue;
+
+		rate = priv->clock.freq / (brp * tsegall);
+		rate_error = abs(bt->bitrate - rate);
+
+		/* tseg brp biterror */
+		if (rate_error > best_rate_error)
+			continue;
+
+		/* reset sample point error if we have a better bitrate */
+		if (rate_error < best_rate_error)
+			best_spt_error = UINT_MAX;
+
+		can_update_spt(btc, spt_nominal, tseg / 2, &tseg1, &tseg2, &spt_error);
+		if (spt_error > best_spt_error)
+			continue;
+
+		best_spt_error = spt_error;
+		best_rate_error = rate_error;
+		best_tseg = tseg / 2;
+		best_brp = brp;
+
+		if (rate_error == 0 && spt_error == 0)
+			break;
+	}
+
+	if (best_rate_error) {
+		/* Error in one-tenth of a percent */
+		rate_error = (best_rate_error * 1000) / bt->bitrate;
+		if (rate_error > CAN_CALC_MAX_ERROR) {
+			netdev_err(dev,
+				   "bitrate error %ld.%ld%% too high\n",
+				   rate_error / 10, rate_error % 10);
+			return -EDOM;
+		}
+		netdev_warn(dev, "bitrate error %ld.%ld%%\n",
+			    rate_error / 10, rate_error % 10);
+	}
+
+	/* real sample point */
+	bt->sample_point = can_update_spt(btc, spt_nominal, best_tseg,
+					  &tseg1, &tseg2, NULL);
+
+	v64 = (u64)best_brp * 1000 * 1000 * 1000;
+	do_div(v64, priv->clock.freq);
+	bt->tq = (u32)v64;
+	bt->prop_seg = tseg1 / 2;
+	bt->phase_seg1 = tseg1 - bt->prop_seg;
+	bt->phase_seg2 = tseg2;
+
+	/* check for sjw user settings */
+	if (!bt->sjw || !btc->sjw_max) {
+		bt->sjw = 1;
+	} else {
+		/* bt->sjw is at least 1 -> sanitize upper bound to sjw_max */
+		if (bt->sjw > btc->sjw_max)
+			bt->sjw = btc->sjw_max;
+		/* bt->sjw must not be higher than tseg2 */
+		if (tseg2 < bt->sjw)
+			bt->sjw = tseg2;
+	}
+
+	bt->brp = best_brp;
+
+	/* real bit-rate */
+	bt->bitrate = priv->clock.freq / (bt->brp * (CAN_CALC_SYNC_SEG + tseg1 + tseg2));
+
+	return 0;
+}
+
+#undef can_calc_bittiming
+#undef can_update_spt
+
+static const struct can_calc_bittiming calc_bittiming_list[] = {
+	/* 1st will be default */
+	{
+		.alg = can_calc_bittiming_v4_8,
+		.name = "v4.8",
+	}, {
+		.alg = can_calc_bittiming_v3_18,
+		.name = "v3.18",
+	},
+};
+
+static int can_fixup_bittiming(struct net_device *dev, struct can_bittiming *bt,
+			       const struct can_bittiming_const *btc)
+{
+	struct can_priv *priv = netdev_priv(dev);
+	unsigned int tseg1, alltseg;
+	u64 brp64, v64;
+
+	tseg1 = bt->prop_seg + bt->phase_seg1;
+	if (!bt->sjw)
+		bt->sjw = 1;
+	if (bt->sjw > btc->sjw_max ||
+	    tseg1 < btc->tseg1_min || tseg1 > btc->tseg1_max ||
+	    bt->phase_seg2 < btc->tseg2_min || bt->phase_seg2 > btc->tseg2_max)
+		return -ERANGE;
+
+	if (!bt->brp) {
+		brp64 = (u64)priv->clock.freq * (u64)bt->tq;
+		if (btc->brp_inc > 1)
+			do_div(brp64, btc->brp_inc);
+		brp64 += 500000000UL - 1;
+		do_div(brp64, 1000000000UL); /* the practicable BRP */
+		if (btc->brp_inc > 1)
+			brp64 *= btc->brp_inc;
+		bt->brp = brp64;
+	}
+
+	v64 = bt->brp * 1000 * 1000 * 1000;
+	do_div(v64, priv->clock.freq);
+	bt->tq = v64;
+
+	if (bt->brp < btc->brp_min || bt->brp > btc->brp_max)
+		return -EINVAL;
+
+	alltseg = CAN_CALC_SYNC_SEG + bt->prop_seg + bt->phase_seg1 + bt->phase_seg2;
+	bt->bitrate = priv->clock.freq / (bt->brp * alltseg);
+	bt->sample_point = ((CAN_CALC_SYNC_SEG + tseg1) * 1000) / alltseg;
+
+	return 0;
+}
+
+static __u32 get_cia_sample_point(__u32 bitrate)
+{
+	__u32 sampl_pt;
+
+	if (bitrate > 800000)
+		sampl_pt = 750;
+	else if (bitrate > 500000)
+		sampl_pt = 800;
+	else
+		sampl_pt = 875;
+
+	return sampl_pt;
+}
+
+static void print_bittiming_one(const struct can_calc_bittiming *calc_bittiming,
+				const struct can_bittiming_const *bittiming_const,
+				const struct can_bittiming *ref_bt,
+				const struct calc_ref_clk *ref_clk,
+				unsigned int bitrate_nominal,
+				unsigned int sample_point_nominal,
+				void (*printf_btr)(struct can_bittiming *bt, bool hdr),
+				bool quiet)
+{
+	struct net_device dev = {
+		.priv.clock.freq = ref_clk->clk,
+	};
+	struct can_bittiming bt = {
+		.bitrate = bitrate_nominal,
+		.sample_point = sample_point_nominal,
+	};
+	unsigned int bitrate_error, sample_point_error;
+
+	if (!quiet) {
+		printf("Bit timing parameters for %s with %.6f MHz ref clock %s%s%susing algo '%s'\n"
+		       " nominal                                  real  Bitrt    nom   real  SampP\n"
+		       " Bitrate TQ[ns] PrS PhS1 PhS2 SJW BRP  Bitrate  Error  SampP  SampP  Error   ",
+		       bittiming_const->name,
+		       ref_clk->clk / 1000000.0,
+		       ref_clk->name ? "(" : "",
+		       ref_clk->name ? ref_clk->name : "",
+		       ref_clk->name ? ") " : "",
+		       calc_bittiming->name);
+
+		printf_btr(&bt, true);
+		printf("\n");
+	}
+
+	if (ref_bt) {
+		bt = *ref_bt;
+
+		if (can_fixup_bittiming(&dev, &bt, bittiming_const)) {
+			printf("%8d ***parameters exceed controller's range***\n", bitrate_nominal);
+			return;
+		}
+	} else {
+		if (calc_bittiming->alg(&dev, &bt, bittiming_const)) {
+			printf("%8d ***bitrate not possible***\n", bitrate_nominal);
+			return;
+		}
+	}
+
+	bitrate_error = abs(bitrate_nominal - bt.bitrate);
+	sample_point_error = abs(sample_point_nominal - bt.sample_point);
+
+	printf("%8d "				/* Bitrate */
+	       "%6d %3d %4d %4d "		/* TQ[ns], PrS, PhS1, PhS2 */
+	       "%3d %3d "			/* SJW, BRP */
+	       "%8d  ",				/* real Bitrate */
+	       bitrate_nominal,
+	       bt.tq, bt.prop_seg, bt.phase_seg1, bt.phase_seg2,
+	       bt.sjw, bt.brp,
+	       bt.bitrate);
+
+	if (100.0 * bitrate_error / bitrate_nominal > 99.9)
+		printf("‚â•100%%  ");
+	else
+		printf("%4.1f%%  ",		/* Bitrate Error */
+		       100.0 * bitrate_error / bitrate_nominal);
+
+	printf("%4.1f%%  %4.1f%%  ",		/* nom Sample Point, real Sample Point */
+	       sample_point_nominal / 10.0,
+	       bt.sample_point / 10.0);
+
+	if (100.0 * sample_point_error / sample_point_nominal > 99.9)
+		printf("‚â•100%%   ");
+	else
+		printf("%4.1f%%   ",		/* Sample Point Error */
+		       100.0 * sample_point_error / sample_point_nominal);
+
+	printf_btr(&bt, false);
+	printf("\n");
+}
+
+static void print_bittiming(const struct calc_data *data)
+{
+	const struct calc_ref_clk *ref_clks = data->ref_clks;
+
+	if (!ref_clks->clk && !data->quiet)
+		printf("Skipping bit timing parameter calculation for %s, no ref clock defined\n\n",
+		       data->bittiming_const->name);
+
+	while (ref_clks->clk) {
+		void (*printf_btr)(struct can_bittiming *bt, bool hdr);
+		unsigned int const *bitrates = data->bitrates;
+		bool quiet = data->quiet;
+
+		if (data->printf_btr)
+			printf_btr = data->printf_btr;
+		else
+			printf_btr = printf_btr_nop;
+
+		while (*bitrates) {
+			unsigned int sample_point;
+
+			/* get nominal sample point */
+			if (data->sample_point)
+				sample_point = data->sample_point;
+			else
+				sample_point = get_cia_sample_point(*bitrates);
+
+			print_bittiming_one(data->calc_bittiming,
+					    data->bittiming_const,
+					    data->opt_bt,
+					    ref_clks,
+					    *bitrates,
+					    sample_point,
+					    printf_btr,
+					    quiet);
+			bitrates++;
+			quiet = true;
+		}
+
+		printf("\n");
+		ref_clks++;
+	}
+}
+
+static void do_list_calc_bittiming_list(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(calc_bittiming_list); i++)
+		printf("    %s\n", calc_bittiming_list[i].name);
+}
+
+static void do_list(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(can_calc_consts); i++)
+		printf("%s\n", can_calc_consts[i].bittiming_const.name);
+}
+
+static void do_calc(struct calc_data *data)
+{
+	unsigned int i;
+	bool found = false;
+
+	for (i = 0; i < ARRAY_SIZE(can_calc_consts); i++) {
+		const struct calc_bittiming_const *btc;
+
+		btc = &can_calc_consts[i];
+
+		if (data->name &&
+		    strcmp(data->name, btc->bittiming_const.name) &&
+		    strcmp(data->name, btc->data_bittiming_const.name))
+			continue;
+
+		found = true;
+
+		if (btc->bittiming_const.name[0]) {
+			data->bittiming_const = &btc->bittiming_const;
+			data->printf_btr = btc->printf_btr;
+
+			if (data->opt_ref_clk)
+				data->ref_clks = data->opt_ref_clk;
+			else
+				data->ref_clks = btc->ref_clk;
+
+			if (data->opt_bitrates)
+				data->bitrates = data->opt_bitrates;
+			else
+				data->bitrates = common_bitrates;
+
+			print_bittiming(data);
+		}
+
+		if (btc->data_bittiming_const.name[0]) {
+			data->bittiming_const = &btc->data_bittiming_const;
+
+			if (btc->printf_data_btr)
+				data->printf_btr = btc->printf_data_btr;
+			else
+				data->printf_btr = btc->printf_btr;
+
+			if (data->opt_ref_clk)
+				data->ref_clks = data->opt_ref_clk;
+			else
+				data->ref_clks = btc->ref_clk;
+
+			if (data->opt_data_bitrates)
+				data->bitrates = data->opt_data_bitrates;
+			else if (data->opt_bitrates)
+				data->bitrates = data->opt_bitrates;
+			else
+				data->bitrates = common_data_bitrates;
+
+			print_bittiming(data);
+		}
+	}
+
+	if (!found) {
+		printf("error: unknown CAN controller '%s', try one of these:\n\n", data->name);
+		do_list();
+		exit(EXIT_FAILURE);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	struct calc_ref_clk opt_ref_clk[] = {
+		{ .name = "cmd-line" },
+		{ /* sentinel */ }
+	};
+	struct can_bittiming opt_bt[1] = { };
+	unsigned int opt_bitrate[] = {
+		0,
+		0 /* sentinel */
+	};
+	unsigned int opt_data_bitrate[] = {
+		0,
+		0 /* sentinel */
+	};
+	struct calc_data data[] = {
+		{
+			.calc_bittiming = calc_bittiming_list,
+		}
+	};
+	const char *opt_alg_name = NULL;
+	bool list = false;
+	int opt;
+
+	const struct option long_options[] = {
+		{ "tq",		required_argument,	0, OPT_TQ, },
+		{ "prop-seg",	required_argument,	0, OPT_PROP_SEG, },
+		{ "phase-seg1",	required_argument,	0, OPT_PHASE_SEG1, },
+		{ "phase-seg2",	required_argument,	0, OPT_PHASE_SEG2, },
+		{ "sjw",	required_argument,	0, OPT_SJW, },
+		{ "brp",	required_argument,	0, OPT_BRP, },
+		{ "tseg1",	required_argument,	0, OPT_TSEG1, },
+		{ "tseg2",	required_argument,	0, OPT_TSEG2, },
+		{ "alg",	optional_argument,	0, OPT_ALG, },
+		{ 0,		0,			0, 0 },
+	};
+
+	while ((opt = getopt_long(argc, argv, "b:c:d:lqs:?", long_options, NULL)) != -1) {
+		switch (opt) {
+		case 'b':
+			opt_bitrate[0] = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'c':
+			opt_ref_clk->clk = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'd':
+			opt_data_bitrate[0] = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'l':
+			list = true;
+			break;
+
+		case 'q':
+			data->quiet = true;
+			break;
+
+		case 's':
+			data->sample_point = strtoul(optarg, NULL, 10);
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(EXIT_SUCCESS);
+			break;
+
+		case OPT_TQ:
+			opt_bt->tq = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_PROP_SEG:
+			opt_bt->prop_seg = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_PHASE_SEG1:
+			opt_bt->phase_seg1 = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_PHASE_SEG2:
+			opt_bt->phase_seg2 = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_SJW:
+			opt_bt->sjw = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_BRP:
+			opt_bt->brp = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_TSEG1: {
+			__u32 tseg1;
+
+			tseg1 = strtoul(optarg, NULL, 10);
+			opt_bt->prop_seg = tseg1 / 2;
+			opt_bt->phase_seg1 = tseg1 - opt_bt->prop_seg;
+			break;
+		}
+
+		case OPT_TSEG2:
+			opt_bt->phase_seg2 = strtoul(optarg, NULL, 10);
+			break;
+
+		case OPT_ALG:
+			if (!optarg) {
+				printf("Supported CAN calc bit timing algorithms:\n\n");
+				do_list_calc_bittiming_list();
+				printf("\n");
+				exit(EXIT_SUCCESS);
+			}
+			opt_alg_name = optarg;
+			break;
+
+		default:
+			print_usage(basename(argv[0]));
+			exit(EXIT_FAILURE);
+			break;
+		}
+	}
+
+	if (argc > optind + 1) {
+		print_usage(argv[0]);
+		exit(EXIT_FAILURE);
+	}
+
+	if (argc == optind + 1)
+		data->name = argv[optind];
+
+	if (list) {
+		do_list();
+		exit(EXIT_SUCCESS);
+	}
+
+	if (data->sample_point && (data->sample_point >= 1000 || data->sample_point < 100))
+		print_usage(argv[0]);
+
+	if (opt_alg_name) {
+		bool alg_found = false;
+		unsigned int i;
+
+		for (i = 0; i < ARRAY_SIZE(calc_bittiming_list); i++) {
+			if (!strcmp(opt_alg_name, calc_bittiming_list[i].name)) {
+				data->calc_bittiming = &calc_bittiming_list[i];
+				alg_found = true;
+			}
+		}
+
+		if (!alg_found) {
+			printf("error: unknown CAN calc bit timing algorithm '%s', try one of these:\n\n", opt_alg_name);
+			do_list_calc_bittiming_list();
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (opt_ref_clk->clk)
+		data->opt_ref_clk = opt_ref_clk;
+	if (opt_bitrate[0])
+		data->opt_bitrates = opt_bitrate;
+	if (opt_data_bitrate[0])
+		data->opt_data_bitrates = opt_data_bitrate;
+	if (opt_bt->prop_seg)
+		data->opt_bt = opt_bt;
+
+	do_calc(data);
+
+	exit(EXIT_SUCCESS);
+}
diff --git a/canutils/can-j1939-install-kernel-module.md b/canutils/can-j1939-install-kernel-module.md
new file mode 100644
index 0000000000..7de99a3531
--- /dev/null
+++ b/canutils/can-j1939-install-kernel-module.md
@@ -0,0 +1,180 @@
+# can-j1939 kernel module installation #
+
+
+
+### Problem
+
+You already have **can0** or **vcan0** up and working, **can-utils** downloaded and compiled to **~/can/can-utils** and you can send and receive frames without problems. However, when you want to bring up **can-j1939** you get error like this:
+
+```bash
+avra@vm-debian:~/can/can-utils$ sudo modprobe can-j1939
+modprobe: FATAL: Module can-j1939 not found in directory /lib/modules/5.7.0.0.bpo.2-amd64
+```
+
+and also this:
+
+```bash
+avra@vm-debian:~/can/can-utils$ testj1939
+testj1939: socket(j1939): Protocol not supported
+```
+
+
+
+### Solution
+
+Above errors mean that **can-j1939** was not enabled in your kernel and you need to compile it manually. There are several ways to do it. Any Linux kernel since 5.4 has **can-j1939** module, but you will probably want to install fresher version, which leads to downloading kernel sources, enabling **can-j1939** module, recompiling kernel and installing it. I will be using Debian 10.5 x64 (buster testing) virtual machine.
+
+
+
+#### 1. Download kernel source ####
+
+We will download Debian patched kernel 5.8. First update your sources
+
+```
+avra@vm-debian:~$ sudo apt update
+```
+
+and then look at available Debian patched kernel source packages
+
+```
+avra@vm-debian:~$ apt-cache search linux-source
+linux-source-4.19 - Linux kernel source for version 4.19 with Debian patches
+linux-source - Linux kernel source (meta-package)
+linux-source-5.4 - Linux kernel source for version 5.4 with Debian patches
+linux-source-5.5 - Linux kernel source for version 5.5 with Debian patches
+linux-source-5.6 - Linux kernel source for version 5.6 with Debian patches
+linux-source-5.7 - Linux kernel source for version 5.7 with Debian patches
+linux-source-5.8 - Linux kernel source for version 5.8 with Debian patches
+```
+
+If kernel 5.8 does not show in your linux-sources list (it shows above in mine since I have already upgraded stock 4.19 kernel to backported 5.7), then you will need to add backports to your sources list. It is best to do it like this
+
+```
+echo 'deb http://deb.debian.org/debian buster-backports main contrib' | sudo tee -a /etc/apt/sources.list.d/debian-backports.list
+```
+
+Alternatively, or in case you have problems with installation of some packages, or you just want to have everything in a single list, here is what my **/etc/apt/sources.list** looks like (you will need to append at least last line to yours)
+
+```
+deb http://security.debian.org/debian-security buster/updates main contrib
+deb-src http://security.debian.org/debian-security buster/updates main contrib
+
+deb http://deb.debian.org/debian/ buster main contrib non-free
+deb-src http://deb.debian.org/debian/ buster main contrib non-free
+
+deb http://deb.debian.org/debian buster-backports main contrib
+```
+
+After adding backports in one way or another, try **sudo apt update** again, and after that **apt-cache search linux-source** should show kernel 5.8 in the list, so you can install it's source package
+
+```
+sudo apt install linux-source-5.8
+```
+
+and unpack it
+```
+avra@vm-debian:~$ cd /usr/src
+avra@vm-debian:/usr/src$ sudo tar -xaf linux-source-5.8.tar.xz
+avra@vm-debian:/usr/src$ cd linux-source-5.8
+```
+
+
+
+#### 2. Add can-j1939 module to kernel ####
+
+First we need some packages for **menuconfig** 
+
+```
+sudo apt-get install libncurses5 libncurses5-dev
+```
+
+copy and use our old configuration to run **menuconfig**
+
+```
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo cp /boot/config-$(uname -r) .config
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo make menuconfig
+```
+
+where we enable SAE  J1939 kernel module as shown
+
+```
+	- Networking Support
+		- Can bus subsystem support
+			- <M> SAE J1939
+```
+
+Now edit **/usr/src/linux-source-5.8/.config**, find CONFIG_SYSTEM_TRUSTED_KEYS, change it as following
+```
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+```
+
+and save the file.
+
+
+
+#### 3. Compile and install kernel and modules
+
+We will have to download necessary packages
+
+```
+sudo apt install build-essential libssl-dev libelf-dev bison flex
+```
+
+compile kernel (using threads to make it faster)
+
+```
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo make -j $(nproc)
+```
+
+install
+
+```
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo make modules_install
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo make install
+```
+
+and update grub
+
+```
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo update-grub
+avra@vm-debian:/usr/src/linux-source-5.8$ sudo reboot
+```
+
+Check if installation is correct with
+
+```
+sudo modprobe can-j1939
+```
+
+and if you get no error then you can enjoy **can-j1939**. If you get some error then you might check if this alternative command works:
+
+```
+sudo insmod /lib/modules/5.8.10/kernel/net/can/j1939/can-j1939.ko
+```
+
+If it does then all you need to do is 
+
+```
+sudo depmod -av
+```
+
+reboot once, and **modprobe** command from the above should finally work.
+
+
+
+#### 4. Install headers if needed
+
+You might have a problem with headers not being updated. To check that open file **/usr/include/linux/can.h** with
+
+```
+nano /usr/include/linux/can.h
+```
+
+If in the struct **sockaddr_can** you don‚Äôt see **j1939**, then header files did not upgrade and you need to do it manually
+
+```
+sudo cp /usr/src/linux-source-5.8/include/uapi/linux/can.h /usr/include/linux/can.h
+sudo cp /usr/src/linux-source-5.8/include/uapi/linux/can/j1939.h /usr/include/linux/can/
+```
+
+That is the minimum for compiling some **J1939** C code, but you might want to upgrade other header files as well. That's up to you. Enjoy!
diff --git a/canutils/can-j1939-kickstart.md b/canutils/can-j1939-kickstart.md
new file mode 100644
index 0000000000..721656aa7b
--- /dev/null
+++ b/canutils/can-j1939-kickstart.md
@@ -0,0 +1,197 @@
+# Kickstart guide to can-j1939 on linux
+
+## Prepare using VCAN
+
+You may skip this step entirely if you have a functional
+**can0** bus on your system.
+
+Load module, when *vcan* is not in-kernel
+
+	modprobe vcan
+
+Create a virtual can0 device and start the device
+
+	ip link add can0 type vcan
+	ip link set can0 up
+
+## First steps with j1939
+
+Use [testj1939](testj1939.c)
+
+When *can-j1939* is compiled as module, opening a socket will load it,
+__or__ you can load it manually
+
+	modprobe can-j1939
+
+Most of the subsequent examples will use 2 sockets programs (in 2 terminals).
+One will use CAN_J1939 sockets using *testj1939*,
+and the other will use CAN_RAW sockets using cansend+candump.
+
+testj1939 can be told to print the used API calls by adding **-v** program argument.
+
+### receive without source address
+
+Do in terminal 1
+
+	testj1939 -B -r can0
+
+Send raw CAN in terminal 2
+
+	cansend can0 1823ff40#0123
+
+You should have this output in terminal 1
+
+	40 02300: 01 23
+
+This means, from NAME 0, SA 40, PGN 02300 was received,
+with 2 databytes, *01* & *23*.
+
+now emit this CAN message:
+
+	cansend can0 18234140#0123
+
+In J1939, this means that ECU 0x40 sends directly to ECU 0x41
+Since we did not bind to address 0x41, this traffic
+is not meant for us and *testj1939* does not receive it.
+
+### receive with source address
+
+Terminal 1:
+
+	testj1939 -r can0:0x80
+
+Terminal 2:
+
+	cansend can0 18238040#0123
+
+Will emit this output
+
+	40 02300: 01 23
+
+This is because the traffic had destination address __0x80__ .
+
+### send
+
+Open in terminal 1:
+
+	candump -L can0
+
+And to these test in another terminal
+
+	testj1939 -B -s can0:0x80 can0:,0x3ffff
+
+This produces **1BFFFF80#0123456789ABCDEF** on CAN.
+
+Note: To be able to send a broadcast we need to use, we need to use "-B" flag.
+
+### Multiple source addresses on 1 CAN device
+
+	testj1939 -B -s can0:0x90 can0:,0x3ffff
+
+produces **1BFFFF90#0123456789ABCDEF** ,
+
+### Use PDU1 PGN
+
+	testj1939 -B -s can0:0x80 can0:,0x12300
+
+emits **1923FF80#0123456789ABCDEF** .
+
+Note that the PGN is **0x12300**, and destination address is **0xff**.
+
+### Use destination address info
+
+Since in this example we use unicast source and destination addresses, we do
+not need to use "-B" (broadcast) flag.
+
+The destination field may be set during sendto().
+*testj1939* implements that like this
+
+	testj1939 -s can0:0x80 can0:0x40,0x12300
+
+emits **19234080#0123456789ABCDEF** .
+
+The destination CAN iface __must__ always match the source CAN iface.
+Specifying one during bind is therefore sufficient.
+
+	testj1939 -s can0:0x80 :0x40,0x12300
+
+emits the very same.
+
+### Emit different PGNs using the same socket
+
+The PGN is provided in both __bind( *sockname* )__ and
+__sendto( *peername* )__ , and only one is used.
+*peername* PGN has highest precedence.
+
+For broadcasted transmissions
+
+	testj1939 -B -s can0:0x80 :,0x32100
+
+emits **1B21FF80#0123456789ABCDEF**
+
+Destination specific transmissions
+
+	testj1939 -s can0:0x80,0x12300 :0x40,0x32100
+
+emits **1B214080#0123456789ABCDEF** .
+
+It makes sometimes sense to omit the PGN in __bind( *sockname* )__ .
+
+### Larger packets
+
+J1939 transparently switches to *Transport Protocol* when packets
+do not fit into single CAN packets.
+
+	testj1939 -B -s20 can0:0x80 :,0x12300
+
+emits:
+
+	18ECFF80#20140003FF002301
+	18EBFF80#010123456789ABCD
+	18EBFF80#02EF0123456789AB
+	18EBFF80#03CDEF01234567FF
+
+The fragments for broadcasted *Transport Protocol* are separated
+__50ms__ from each other.
+Destination specific *Transport Protocol* applies flow control
+and may emit CAN packets much faster.
+
+First assign 0x90 to the local system.
+This becomes important because the kernel must interact in the
+transport protocol sessions before the complete packet is delivered.
+
+	testj1939 can0:0x90 -r &
+
+Now test:
+
+	testj1939 -s20 can0:0x80 :0x90,0x12300
+
+emits:
+
+	18EC9080#1014000303002301
+	18EC8090#110301FFFF002301
+	18EB9080#010123456789ABCD
+	18EB9080#02EF0123456789AB
+	18EB9080#03CDEF01234567FF
+	18EC8090#13140003FF002301
+
+The flow control causes a bit overhead.
+This overhead scales very good for larger J1939 packets.
+
+## Advanced topics with j1939
+
+### Change priority of J1939 packets
+
+	testj1939 -B -s can0:0x80 :,0x0100
+	testj1939 -B -s -p3 can0:0x80 :,0x0200
+
+emits
+
+	1801FF80#0123456789ABCDEF
+	0C02FF80#0123456789ABCDEF
+
+### using connect
+
+### advanced filtering
+
+## dynamic addressing
diff --git a/canutils/can-j1939.md b/canutils/can-j1939.md
new file mode 100644
index 0000000000..4b970851a3
--- /dev/null
+++ b/canutils/can-j1939.md
@@ -0,0 +1,98 @@
+# CAN-J1939 on linux
+
+The [Kickstart guide is here](can-j1939-kickstart.md)
+
+## CAN on linux
+
+See [Wikipedia:socketcan](http://en.wikipedia.org/wiki/Socketcan)
+
+## J1939 networking in short
+
+* Add addressing on top of CAN (destination address & broadcast)
+
+* Any (max 1780) length packets.
+  Packets of 9 or more use **Transport Protocol** (fragmentation)
+  Such packets use different CANid for the same PGN.
+
+* only **29**bit, non-**RTR** CAN frames
+
+* CAN id is composed of
+  * 0..8: SA (source address)
+  * 9..26:
+    * PDU1: PGN+DA (destination address)
+    * PDU2: PGN
+  * 27..29: PRIO
+
+* SA / DA may be dynamically assigned via j1939-81
+  Fixed rules of precedence in Specification, no master necessary
+
+## J1939 on SocketCAN
+
+J1939 is *just another protocol* that fits
+in the Berkely sockets.
+
+	socket(AF_CAN, SOCK_DGRAM, CAN_J1939)
+
+## differences from CAN_RAW
+### addressing
+
+SA, DA & PGN are used, not CAN id.
+
+Berkeley socket API is used to communicate these to userspace:
+
+  * SA+PGN is put in sockname ([getsockname](http://man7.org/linux/man-pages/man2/getsockname.2.html))
+  * DA+PGN is put in peername ([getpeername](http://man7.org/linux/man-pages/man2/getpeername.2.html))
+    PGN is put in both structs
+
+PRIO is a datalink property, and irrelevant for interpretation
+Therefore, PRIO is not in *sockname* or *peername*.
+
+The *data* that is [recv][recvfrom] or [send][sendto] is the real payload.
+Unlike CAN_RAW, where addressing info is data.
+
+### Packet size
+
+J1939 handles packets of 8+ bytes with **Transport Protocol** fragmentation transparently.
+No fixed data size is necessary.
+
+	send(sock, data, 8, 0);
+
+will emit a single CAN frame.
+
+	send(sock, data, 9, 0);
+
+will use fragmentation, emitting 1+ CAN frames.
+
+# Using J1939
+
+## BSD socket implementation
+* socket
+* bind / connect
+* recvfrom / sendto
+* getsockname / getpeername
+
+## Modified *struct sockaddr_can*
+
+	struct sockaddr_can {
+		sa_family_t can_family;
+		int         can_ifindex;
+		union {
+			struct {
+				__u64 name;
+				__u32 pgn;
+				__u8 addr;
+			} j1939;
+		} can_addr;
+	}
+
+* *can_addr.j1939.pgn* is PGN
+
+* *can_addr.j1939.addr* & *can_addr.j1939.name*
+  determine the ECU
+
+  * receiving address information,
+    *addr* is always set,
+    *name* is set when available.
+
+  * When providing address information,
+    *name* != 0 indicates dynamic addressing
diff --git a/canutils/canbusload.c b/canutils/canbusload.c
new file mode 100644
index 0000000000..e4dfc021a6
--- /dev/null
+++ b/canutils/canbusload.c
@@ -0,0 +1,432 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * canbusload.c - monitor CAN bus load
+ *
+ * Copyright (c) 2002-2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <ctype.h>
+#include <libgen.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+
+#include "terminal.h"
+#include "canframelen.h"
+
+#define MAXSOCK 16    /* max. number of CAN interfaces given on the cmdline */
+
+#define PERCENTRES 5 /* resolution in percent for bargraph */
+#define NUMBAR (100/PERCENTRES) /* number of bargraph elements */
+
+extern int optind, opterr, optopt;
+
+static struct {
+	char devname[IFNAMSIZ+1];
+	unsigned int bitrate;
+	unsigned int dbitrate;
+	unsigned int recv_frames;
+	unsigned int recv_bits_total;
+	unsigned int recv_bits_payload;
+	unsigned int recv_bits_dbitrate;
+} stat[MAXSOCK+1];
+
+static int  max_devname_len; /* to prevent frazzled device name output */ 
+static int  max_bitrate_len;
+static int  currmax;
+static unsigned char redraw;
+static unsigned char timestamp;
+static unsigned char color;
+static unsigned char bargraph;
+static enum cfl_mode mode = CFL_WORSTCASE;
+static char *prg;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - monitor CAN bus load.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>+\n", prg);
+	fprintf(stderr, "  (use CTRL-C to terminate %s)\n\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -t  (show current time on the first line)\n");
+	fprintf(stderr, "         -c  (colorize lines)\n");
+	fprintf(stderr, "         -b  (show bargraph in %d%% resolution)\n", PERCENTRES);
+	fprintf(stderr, "         -r  (redraw the terminal - similar to top)\n");
+	fprintf(stderr, "         -i  (ignore bitstuffing in bandwidth calculation)\n");
+	fprintf(stderr, "         -e  (exact calculation of stuffed bits)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Up to %d CAN interfaces with mandatory bitrate can be specified on the \n", MAXSOCK);
+	fprintf(stderr, "commandline in the form: <ifname>@<bitrate>[,<dbitrate>]\n\n");
+	fprintf(stderr, "The bitrate is mandatory as it is needed to know the CAN bus bitrate to\n");
+	fprintf(stderr, "calculate the bus load percentage based on the received CAN frames.\n");
+	fprintf(stderr, "Due to the bitstuffing estimation the calculated busload may exceed 100%%.\n");
+	fprintf(stderr, "For each given interface the data is presented in one line which contains:\n\n");
+	fprintf(stderr, "(interface) (received CAN frames) (used bits total) (used bits for payload)\n");
+	fprintf(stderr, "\nExamples:\n");
+	fprintf(stderr, "\nuser$> canbusload can0@100000 can1@500000 can2@500000 can3@500000 -r -t -b -c\n\n");
+	fprintf(stderr, "%s 2014-02-01 21:13:16 (worst case bitstuffing)\n", prg);
+	fprintf(stderr, " can0@100000   805   74491  36656  74%% |XXXXXXXXXXXXXX......|\n");
+	fprintf(stderr, " can1@500000   796   75140  37728  15%% |XXX.................|\n");
+	fprintf(stderr, " can2@500000     0       0      0   0%% |....................|\n");
+	fprintf(stderr, " can3@500000    47    4633   2424   0%% |....................|\n");
+	fprintf(stderr, "\n");
+}
+
+void sigterm(int signo)
+{
+	exit(0);
+}
+
+void printstats(int signo)
+{
+	int i, j, percent;
+
+	if (redraw)
+		printf("%s", CSR_HOME);
+
+	if (timestamp) {
+		time_t currtime;
+		struct tm now;
+
+		if (time(&currtime) == (time_t)-1) {
+			perror("time");
+			exit(1);
+		}
+
+		localtime_r(&currtime, &now);
+
+		printf("%s %04d-%02d-%02d %02d:%02d:%02d ",
+		       prg,
+		       now.tm_year + 1900,
+		       now.tm_mon + 1,
+		       now.tm_mday,
+		       now.tm_hour,
+		       now.tm_min,
+		       now.tm_sec);
+
+		switch (mode) {
+
+		case CFL_NO_BITSTUFFING:
+			/* plain bit calculation without bitstuffing */
+			printf("(ignore bitstuffing)\n");
+			break;
+
+		case CFL_WORSTCASE:
+			/* worst case estimation - see above */
+			printf("(worst case bitstuffing)\n");
+			break;
+
+		case CFL_EXACT:
+			/* exact calculation of stuffed bits based on frame content and CRC */
+			printf("(exact bitstuffing)\n");
+			break;
+
+		default:
+			printf("(unknown bitstuffing)\n");
+			break;
+		}
+	}
+
+	for (i=0; i<currmax; i++) {
+
+		if (color) {
+			if (i%2)
+				printf("%s", FGRED);
+			else
+				printf("%s", FGBLUE);
+		}
+
+		if (stat[i].bitrate)
+			percent = ((stat[i].recv_bits_total-stat[i].recv_bits_dbitrate) * 100) / stat[i].bitrate
+				+ (stat[i].recv_bits_dbitrate * 100) / stat[i].dbitrate;
+		else
+			percent = 0;
+
+		printf(" %*s@%-*d %5d %7d %6d %6d %3d%%",
+		       max_devname_len, stat[i].devname,
+		       max_bitrate_len, stat[i].bitrate,
+		       stat[i].recv_frames,
+		       stat[i].recv_bits_total,
+		       stat[i].recv_bits_payload,
+		       stat[i].recv_bits_dbitrate,
+		       percent);
+
+		if (bargraph) {
+
+			printf(" |");
+
+			if (percent > 100)
+				percent = 100;
+
+			for (j=0; j < NUMBAR; j++){
+				if (j < percent/PERCENTRES)
+					printf("X");
+				else
+					printf(".");
+			}
+	    
+			printf("|");
+		}
+	
+		if (color)
+			printf("%s", ATTRESET);
+
+		printf("\n");
+
+		stat[i].recv_frames = 0;
+		stat[i].recv_bits_total = 0;
+		stat[i].recv_bits_dbitrate = 0;
+		stat[i].recv_bits_payload = 0;
+	}
+
+	printf("\n");
+	fflush(stdout);
+
+	alarm(1);
+}
+
+int main(int argc, char **argv)
+{
+	fd_set rdfs;
+	int s[MAXSOCK];
+
+	int opt;
+	char *ptr, *nptr;
+	struct sockaddr_can addr;
+	struct canfd_frame frame;
+	int nbytes, i;
+	struct ifreq ifr;
+	sigset_t sigmask, savesigmask;
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+	signal(SIGINT, sigterm);
+
+	signal(SIGALRM, printstats);
+
+	prg = basename(argv[0]);
+
+	while ((opt = getopt(argc, argv, "rtbcieh?")) != -1) {
+		switch (opt) {
+		case 'r':
+			redraw = 1;
+			break;
+
+		case 't':
+			timestamp = 1;
+			break;
+
+		case 'b':
+			bargraph = 1;
+			break;
+
+		case 'c':
+			color = 1;
+			break;
+
+		case 'i':
+			mode = CFL_NO_BITSTUFFING;
+			break;
+
+		case 'e':
+			mode = CFL_EXACT;
+			break;
+
+		default:
+			print_usage(prg);
+			exit(1);
+			break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(prg);
+		exit(0);
+	}
+	
+	currmax = argc - optind; /* find real number of CAN devices */
+
+	if (currmax > MAXSOCK) {
+		printf("More than %d CAN devices given on commandline!\n", MAXSOCK);
+		return 1;
+	}
+
+	for (i=0; i < currmax; i++) {
+
+		ptr = argv[optind+i];
+
+		nbytes = strlen(ptr);
+		if (nbytes >= (int)(IFNAMSIZ+sizeof("@1000000")+1)) {
+			printf("name of CAN device '%s' is too long!\n", ptr);
+			return 1;
+		}
+
+#ifdef DEBUG
+		printf("open %d '%s'.\n", i, ptr);
+#endif
+
+		s[i] = socket(PF_CAN, SOCK_RAW, CAN_RAW);
+		if (s[i] < 0) {
+			perror("socket");
+			return 1;
+		}
+
+		nptr = strchr(ptr, '@');
+
+		if (!nptr) {
+			print_usage(prg);
+			return 1;
+		}
+
+		nbytes = nptr - ptr;  /* interface name is up the first '@' */
+
+		if (nbytes >= (int)IFNAMSIZ) {
+			printf("name of CAN device '%s' is too long!\n", ptr);
+			return 1;
+		}
+
+		strncpy(stat[i].devname, ptr, nbytes);
+		memset(&ifr.ifr_name, 0, sizeof(ifr.ifr_name));
+		strncpy(ifr.ifr_name, ptr, nbytes);
+
+		if (nbytes > max_devname_len)
+			max_devname_len = nbytes; /* for nice printing */
+
+		char *endp;
+		stat[i].bitrate = strtol(nptr + 1, &endp, 0); /* bitrate is placed behind the '@' */
+		if (*endp == ',')
+			/* data bitrate is placed behind the ',' */
+			stat[i].dbitrate = strtol(endp + 1, &endp, 0);
+		else
+			stat[i].dbitrate = stat[i].bitrate;
+
+		if (!stat[i].bitrate || stat[i].bitrate > 1000000) {
+			printf("invalid bitrate for CAN device '%s'!\n", ptr);
+			return 1;
+		}
+
+		nbytes = strlen(nptr+1);
+		if (nbytes > max_bitrate_len)
+			max_bitrate_len = nbytes; /* for nice printing */
+
+
+#ifdef DEBUG
+		printf("using interface name '%s'.\n", ifr.ifr_name);
+#endif
+		/* try to switch the socket into CAN FD mode */
+		const int canfd_on = 1;
+		setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));
+
+		if (ioctl(s[i], SIOCGIFINDEX, &ifr) < 0) {
+			perror("SIOCGIFINDEX");
+			exit(1);
+		}
+
+		addr.can_family = AF_CAN;
+		addr.can_ifindex = ifr.ifr_ifindex;
+
+		if (bind(s[i], (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+			perror("bind");
+			return 1;
+		}
+	}
+
+	alarm(1);
+
+	if (redraw)
+		printf("%s", CLR_SCREEN);
+
+	while (1) {
+
+		FD_ZERO(&rdfs);
+		for (i=0; i<currmax; i++)
+			FD_SET(s[i], &rdfs);
+
+		savesigmask = sigmask;
+
+		if (pselect(s[currmax-1]+1, &rdfs, NULL, NULL, NULL, &sigmask) < 0) {
+			//perror("pselect");
+			sigmask = savesigmask;
+			continue;
+		}
+
+		for (i=0; i<currmax; i++) {  /* check all CAN RAW sockets */
+
+			if (FD_ISSET(s[i], &rdfs)) {
+
+				nbytes = read(s[i], &frame, sizeof(frame));
+
+				if (nbytes < 0) {
+					perror("read");
+					return 1;
+				}
+
+				if (nbytes < (int)sizeof(struct can_frame)) {
+					fprintf(stderr, "read: incomplete CAN frame\n");
+					return 1;
+				}
+
+				stat[i].recv_frames++;
+				stat[i].recv_bits_payload += frame.len * 8;
+				stat[i].recv_bits_dbitrate += can_frame_dbitrate_length(
+						&frame, mode, sizeof(frame));
+				stat[i].recv_bits_total += can_frame_length(&frame,
+									    mode, nbytes);
+			}
+		}
+	}
+
+	for (i=0; i<currmax; i++)
+		close(s[i]);
+
+	return 0;
+}
diff --git a/canutils/candump.c b/canutils/candump.c
new file mode 100644
index 0000000000..6fe30bbb38
--- /dev/null
+++ b/canutils/candump.c
@@ -0,0 +1,875 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * candump.c
+ *
+ * Copyright (c) 2002-2009 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <libgen.h>
+#include <signal.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/epoll.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+
+#include "terminal.h"
+#include "lib.h"
+
+/* for hardware timestamps - since Linux 2.6.30 */
+#ifndef SO_TIMESTAMPING
+#define SO_TIMESTAMPING 37
+#endif
+
+/* from #include <linux/net_tstamp.h> - since Linux 2.6.30 */
+#define SOF_TIMESTAMPING_SOFTWARE (1 << 4)
+#define SOF_TIMESTAMPING_RX_SOFTWARE (1 << 3)
+#define SOF_TIMESTAMPING_RAW_HARDWARE (1 << 6)
+#define TIMESTAMPSZ 50 /* string 'absolute with date' requires max 49 bytes */
+
+#define MAXSOCK 16    /* max. number of CAN interfaces given on the cmdline */
+#define MAXIFNAMES 30 /* size of receive name index to omit ioctls */
+#define MAXCOL 6      /* number of different colors for colorized output */
+#define ANYDEV "any"  /* name of interface to receive from any CAN interface */
+#define ANL "\r\n"    /* newline in ASC mode */
+
+#define SILENT_INI 42 /* detect user setting on commandline */
+#define SILENT_OFF 0  /* no silent mode */
+#define SILENT_ANI 1  /* silent mode with animation */
+#define SILENT_ON 2   /* silent mode (completely silent) */
+
+#define BOLD ATTBOLD
+#define RED (ATTBOLD FGRED)
+#define GREEN (ATTBOLD FGGREEN)
+#define YELLOW (ATTBOLD FGYELLOW)
+#define BLUE (ATTBOLD FGBLUE)
+#define MAGENTA (ATTBOLD FGMAGENTA)
+#define CYAN (ATTBOLD FGCYAN)
+
+static const char col_on[MAXCOL][19] = { BLUE, RED, GREEN, BOLD, MAGENTA, CYAN };
+static const char col_off[] = ATTRESET;
+
+struct if_info { /* bundled information per open socket */
+	int s; /* socket */
+	char *cmdlinename;
+	__u32 dropcnt;
+	__u32 last_dropcnt;
+};
+static struct if_info sock_info[MAXSOCK];
+
+static char devname[MAXIFNAMES][IFNAMSIZ+1];
+static int dindex[MAXIFNAMES];
+static int max_devname_len; /* to prevent frazzled device name output */
+static const int canfd_on = 1;
+
+#define MAXANI 4
+static const char anichar[MAXANI] = { '|', '/', '-', '\\' };
+static const char extra_m_info[4][4] = { "- -", "B -", "- E", "B E" };
+
+extern int optind, opterr, optopt;
+
+static volatile int running = 1;
+
+static void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - dump CAN bus traffic.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>+\n", prg);
+	fprintf(stderr, "  (use CTRL-C to terminate %s)\n\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -t <type>   (timestamp: (a)bsolute/(d)elta/(z)ero/(A)bsolute w date)\n");
+	fprintf(stderr, "         -H          (read hardware timestamps instead of system timestamps)\n");
+	fprintf(stderr, "         -c          (increment color mode level)\n");
+	fprintf(stderr, "         -i          (binary output - may exceed 80 chars/line)\n");
+	fprintf(stderr, "         -a          (enable additional ASCII output)\n");
+	fprintf(stderr, "         -S          (swap byte order in printed CAN data[] - marked with '%c' )\n", SWAP_DELIMITER);
+	fprintf(stderr, "         -s <level>  (silent mode - %d: off (default) %d: animation %d: silent)\n", SILENT_OFF, SILENT_ANI, SILENT_ON);
+	fprintf(stderr, "         -l          (log CAN-frames into file. Sets '-s %d' by default)\n", SILENT_ON);
+	fprintf(stderr, "         -f <fname>  (log CAN-frames into file <fname>. Sets '-s %d' by default)\n", SILENT_ON);
+	fprintf(stderr, "         -L          (use log file format on stdout)\n");
+	fprintf(stderr, "         -n <count>  (terminate after reception of <count> CAN frames)\n");
+	fprintf(stderr, "         -r <size>   (set socket receive buffer to <size>)\n");
+	fprintf(stderr, "         -D          (Don't exit if a \"detected\" can device goes down)\n");
+	fprintf(stderr, "         -d          (monitor dropped CAN frames)\n");
+	fprintf(stderr, "         -e          (dump CAN error frames in human-readable format)\n");
+	fprintf(stderr, "         -8          (display raw DLC values in {} for Classical CAN)\n");
+	fprintf(stderr, "         -x          (print extra message infos, rx/tx brs esi)\n");
+	fprintf(stderr, "         -T <msecs>  (terminate after <msecs> if no frames were received)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Up to %d CAN interfaces with optional filter sets can be specified\n", MAXSOCK);
+	fprintf(stderr, "on the commandline in the form: <ifname>[,filter]*\n");
+	fprintf(stderr, "\nFilters:\n");
+	fprintf(stderr, "  Comma separated filters can be specified for each given CAN interface:\n");
+	fprintf(stderr, "    <can_id>:<can_mask>\n         (matches when <received_can_id> & mask == can_id & mask)\n");
+	fprintf(stderr, "    <can_id>~<can_mask>\n         (matches when <received_can_id> & mask != can_id & mask)\n");
+	fprintf(stderr, "    #<error_mask>\n         (set error frame filter, see include/linux/can/error.h)\n");
+	fprintf(stderr, "    [j|J]\n         (join the given CAN filters - logical AND semantic)\n");
+	fprintf(stderr, "\nCAN IDs, masks and data content are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "When the can_id is 8 digits long the CAN_EFF_FLAG is set for 29 bit EFF format.\n");
+	fprintf(stderr, "Without any given filter all data frames are received ('0:0' default filter).\n");
+	fprintf(stderr, "\nUse interface name '%s' to receive from all CAN interfaces.\n", ANYDEV);
+	fprintf(stderr, "\nExamples:\n");
+	fprintf(stderr, "%s -c -c -ta can0,123:7FF,400:700,#000000FF can2,400~7F0 can3 can8\n\n", prg);
+	fprintf(stderr, "%s -l any,0~0,#FFFFFFFF\n         (log only error frames but no(!) data frames)\n", prg);
+	fprintf(stderr, "%s -l any,0:0,#FFFFFFFF\n         (log error frames and also all data frames)\n", prg);
+	fprintf(stderr, "%s vcan2,12345678:DFFFFFFF\n         (match only for extended CAN ID 12345678)\n", prg);
+	fprintf(stderr, "%s vcan2,123:7FF\n         (matches CAN ID 123 - including EFF and RTR frames)\n", prg);
+	fprintf(stderr, "%s vcan2,123:C00007FF\n         (matches CAN ID 123 - only SFF and non-RTR frames)\n", prg);
+	fprintf(stderr, "\n");
+}
+
+static void sigterm(int signo)
+{
+	running = 0;
+}
+
+static int idx2dindex(int ifidx, int socket)
+{
+
+	int i;
+	struct ifreq ifr;
+
+	for (i = 0; i < MAXIFNAMES; i++) {
+		if (dindex[i] == ifidx)
+			return i;
+	}
+
+	/* create new interface index cache entry */
+
+	/* remove index cache zombies first */
+	for (i = 0; i < MAXIFNAMES; i++) {
+		if (dindex[i]) {
+			ifr.ifr_ifindex = dindex[i];
+			if (ioctl(socket, SIOCGIFNAME, &ifr) < 0)
+				dindex[i] = 0;
+		}
+	}
+
+	for (i = 0; i < MAXIFNAMES; i++)
+		if (!dindex[i]) /* free entry */
+			break;
+
+	if (i == MAXIFNAMES) {
+		fprintf(stderr, "Interface index cache only supports %d interfaces.\n",
+			MAXIFNAMES);
+		exit(1);
+	}
+
+	dindex[i] = ifidx;
+
+	ifr.ifr_ifindex = ifidx;
+	if (ioctl(socket, SIOCGIFNAME, &ifr) < 0)
+		perror("SIOCGIFNAME");
+
+	if (max_devname_len < (int)strlen(ifr.ifr_name))
+		max_devname_len = strlen(ifr.ifr_name);
+
+	strcpy(devname[i], ifr.ifr_name);
+
+#ifdef DEBUG
+	printf("new index %d (%s)\n", i, devname[i]);
+#endif
+
+	return i;
+}
+
+static inline void sprint_timestamp(const char timestamp, const struct timeval *tv,
+				    struct timeval *const last_tv, char *ts_buffer)
+{
+	switch (timestamp) {
+
+	case 'a': /* absolute with timestamp */
+		sprintf(ts_buffer, "(%010lu.%06lu) ", tv->tv_sec, tv->tv_usec);
+		break;
+
+	case 'A': /* absolute with date */
+	{
+		struct tm tm;
+		char timestring[25];
+
+		tm = *localtime(&tv->tv_sec);
+		strftime(timestring, 24, "%Y-%m-%d %H:%M:%S", &tm);
+		sprintf(ts_buffer, "(%s.%06lu) ", timestring, tv->tv_usec);
+	}
+	break;
+
+	case 'd': /* delta */
+	case 'z': /* starting with zero */
+	{
+		struct timeval diff;
+
+		if (last_tv->tv_sec == 0)   /* first init */
+			*last_tv = *tv;
+		diff.tv_sec  = tv->tv_sec - last_tv->tv_sec;
+		diff.tv_usec = tv->tv_usec - last_tv->tv_usec;
+		if (diff.tv_usec < 0)
+			diff.tv_sec--, diff.tv_usec += 1000000;
+		if (diff.tv_sec < 0)
+			diff.tv_sec = diff.tv_usec = 0;
+		sprintf(ts_buffer, "(%03lu.%06lu) ", diff.tv_sec, diff.tv_usec);
+
+		if (timestamp == 'd')
+			*last_tv = *tv; /* update for delta calculation */
+	}
+	break;
+
+	default: /* no timestamp output */
+		break;
+	}
+}
+
+static inline void print_timestamp(const char timestamp, const struct timeval *tv,
+				   struct timeval *const last_tv)
+{
+	static char buffer[TIMESTAMPSZ];
+
+	sprint_timestamp(timestamp, tv, last_tv, buffer);
+	printf("%s", buffer);
+}
+
+int main(int argc, char **argv)
+{
+	int fd_epoll;
+	struct epoll_event events_pending[MAXSOCK];
+	struct epoll_event event_setup = {
+		.events = EPOLLIN, /* prepare the common part */
+	};
+	unsigned char timestamp = 0;
+	unsigned char logtimestamp = 'a';
+	unsigned char hwtimestamp = 0;
+	unsigned char down_causes_exit = 1;
+	unsigned char dropmonitor = 0;
+	unsigned char extra_msg_info = 0;
+	unsigned char silent = SILENT_INI;
+	unsigned char silentani = 0;
+	unsigned char color = 0;
+	unsigned char view = 0;
+	unsigned char log = 0;
+	unsigned char logfrmt = 0;
+	int count = 0;
+	int rcvbuf_size = 0;
+	int opt, num_events;
+	int currmax, numfilter;
+	int join_filter;
+	char *ptr, *nptr;
+	struct sockaddr_can addr;
+	char ctrlmsg[CMSG_SPACE(sizeof(struct timeval) + 3 * sizeof(struct timespec) + sizeof(__u32))];
+	struct iovec iov;
+	struct msghdr msg;
+	struct cmsghdr *cmsg;
+	struct can_filter *rfilter;
+	can_err_mask_t err_mask;
+	struct canfd_frame frame;
+	int nbytes, i, maxdlen;
+	struct ifreq ifr;
+	struct timeval tv, last_tv;
+	int timeout_ms = -1; /* default to no timeout */
+	FILE *logfile = NULL;
+	char *logname = NULL;
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+	signal(SIGINT, sigterm);
+
+	last_tv.tv_sec = 0;
+	last_tv.tv_usec = 0;
+
+	while ((opt = getopt(argc, argv, "t:HciaSs:lDdxLf:n:r:he8T:?")) != -1) {
+		switch (opt) {
+		case 't':
+			timestamp = optarg[0];
+			logtimestamp = optarg[0];
+			if ((timestamp != 'a') && (timestamp != 'A') &&
+			    (timestamp != 'd') && (timestamp != 'z')) {
+				fprintf(stderr, "%s: unknown timestamp mode '%c' - ignored\n",
+					basename(argv[0]), optarg[0]);
+				timestamp = 0;
+			}
+			if ((logtimestamp != 'a') && (logtimestamp != 'z')) {
+				logtimestamp = 'a';
+			}
+			break;
+
+		case 'H':
+			hwtimestamp = 1;
+			break;
+
+		case 'c':
+			color++;
+			break;
+
+		case 'i':
+			view |= CANLIB_VIEW_BINARY;
+			break;
+
+		case 'a':
+			view |= CANLIB_VIEW_ASCII;
+			break;
+
+		case 'S':
+			view |= CANLIB_VIEW_SWAP;
+			break;
+
+		case 'e':
+			view |= CANLIB_VIEW_ERROR;
+			break;
+
+		case '8':
+			view |= CANLIB_VIEW_LEN8_DLC;
+			break;
+
+		case 's':
+			silent = atoi(optarg);
+			if (silent > SILENT_ON) {
+				print_usage(basename(argv[0]));
+				exit(1);
+			}
+			break;
+
+		case 'l':
+			log = 1;
+			break;
+
+		case 'D':
+			down_causes_exit = 0;
+			break;
+
+		case 'd':
+			dropmonitor = 1;
+			break;
+
+		case 'x':
+			extra_msg_info = 1;
+			break;
+
+		case 'L':
+			logfrmt = 1;
+			break;
+
+		case 'f':
+			logname = optarg;
+			log = 1;
+			break;
+
+		case 'n':
+			count = atoi(optarg);
+			if (count < 1) {
+				print_usage(basename(argv[0]));
+				exit(1);
+			}
+			break;
+
+		case 'r':
+			rcvbuf_size = atoi(optarg);
+			if (rcvbuf_size < 1) {
+				print_usage(basename(argv[0]));
+				exit(1);
+			}
+			break;
+
+		case 'T':
+			errno = 0;
+			timeout_ms = strtol(optarg, NULL, 0);
+			if (errno != 0) {
+				print_usage(basename(argv[0]));
+				exit(1);
+			}
+			break;
+		default:
+			print_usage(basename(argv[0]));
+			exit(1);
+			break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+
+	if (logfrmt && view) {
+		fprintf(stderr, "Log file format selected: Please disable ASCII/BINARY/SWAP/RAWDLC options!\n");
+		exit(0);
+	}
+
+	/* "-f -"  is equal to "-L" (print logfile format on stdout) */
+	if (log && logname && strcmp("-", logname) == 0) {
+		log = 0; /* no logging into a file */
+		logfrmt = 1; /* print logformat output to stdout */
+	}
+
+	if (silent == SILENT_INI) {
+		if (log) {
+			fprintf(stderr, "Disabled standard output while logging.\n");
+			silent = SILENT_ON; /* disable output on stdout */
+		} else
+			silent = SILENT_OFF; /* default output */
+	}
+
+	currmax = argc - optind; /* find real number of CAN devices */
+
+	if (currmax > MAXSOCK) {
+		fprintf(stderr, "More than %d CAN devices given on commandline!\n", MAXSOCK);
+		return 1;
+	}
+
+	fd_epoll = epoll_create(1);
+	if (fd_epoll < 0) {
+		perror("epoll_create");
+		return 1;
+	}
+
+	for (i = 0; i < currmax; i++) {
+		struct if_info* obj = &sock_info[i];
+		ptr = argv[optind+i];
+		nptr = strchr(ptr, ',');
+
+#ifdef DEBUG
+		printf("open %d '%s'.\n", i, ptr);
+#endif
+
+		obj->s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
+		if (obj->s < 0) {
+			perror("socket");
+			return 1;
+		}
+
+		event_setup.data.ptr = obj; /* remember the instance as private data */
+		if (epoll_ctl(fd_epoll, EPOLL_CTL_ADD, obj->s, &event_setup)) {
+			perror("failed to add socket to epoll");
+			return 1;
+		}
+
+		obj->cmdlinename = ptr; /* save pointer to cmdline name of this socket */
+
+		if (nptr)
+			nbytes = nptr - ptr;  /* interface name is up the first ',' */
+		else
+			nbytes = strlen(ptr); /* no ',' found => no filter definitions */
+
+		if (nbytes >= IFNAMSIZ) {
+			fprintf(stderr, "name of CAN device '%s' is too long!\n", ptr);
+			return 1;
+		}
+
+		if (nbytes > max_devname_len)
+			max_devname_len = nbytes; /* for nice printing */
+
+		addr.can_family = AF_CAN;
+
+		memset(&ifr.ifr_name, 0, sizeof(ifr.ifr_name));
+		strncpy(ifr.ifr_name, ptr, nbytes);
+
+#ifdef DEBUG
+		printf("using interface name '%s'.\n", ifr.ifr_name);
+#endif
+
+		if (strcmp(ANYDEV, ifr.ifr_name) != 0) {
+			if (ioctl(obj->s, SIOCGIFINDEX, &ifr) < 0) {
+				perror("SIOCGIFINDEX");
+				exit(1);
+			}
+			addr.can_ifindex = ifr.ifr_ifindex;
+		} else
+			addr.can_ifindex = 0; /* any can interface */
+
+		if (nptr) {
+
+			/* found a ',' after the interface name => check for filters */
+
+			/* determine number of filters to alloc the filter space */
+			numfilter = 0;
+			ptr = nptr;
+			while (ptr) {
+				numfilter++;
+				ptr++; /* hop behind the ',' */
+				ptr = strchr(ptr, ','); /* exit condition */
+			}
+
+			rfilter = malloc(sizeof(struct can_filter) * numfilter);
+			if (!rfilter) {
+				fprintf(stderr, "Failed to create filter space!\n");
+				return 1;
+			}
+
+			numfilter = 0;
+			err_mask = 0;
+			join_filter = 0;
+
+			while (nptr) {
+
+				ptr = nptr + 1; /* hop behind the ',' */
+				nptr = strchr(ptr, ','); /* update exit condition */
+
+				if (sscanf(ptr, "%x:%x",
+					   &rfilter[numfilter].can_id,
+					   &rfilter[numfilter].can_mask) == 2) {
+					rfilter[numfilter].can_mask &= ~CAN_ERR_FLAG;
+					if (*(ptr + 8) == ':')
+						rfilter[numfilter].can_id |= CAN_EFF_FLAG;
+					numfilter++;
+				} else if (sscanf(ptr, "%x~%x",
+						  &rfilter[numfilter].can_id,
+						  &rfilter[numfilter].can_mask) == 2) {
+					rfilter[numfilter].can_id |= CAN_INV_FILTER;
+					rfilter[numfilter].can_mask &= ~CAN_ERR_FLAG;
+					if (*(ptr + 8) == '~')
+						rfilter[numfilter].can_id |= CAN_EFF_FLAG;
+					numfilter++;
+				} else if (*ptr == 'j' || *ptr == 'J') {
+					join_filter = 1;
+				} else if (sscanf(ptr, "#%x", &err_mask) != 1) {
+					fprintf(stderr, "Error in filter option parsing: '%s'\n", ptr);
+					return 1;
+				}
+			}
+
+			if (err_mask)
+				setsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_ERR_FILTER,
+					   &err_mask, sizeof(err_mask));
+
+			if (join_filter && setsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_JOIN_FILTERS,
+						      &join_filter, sizeof(join_filter)) < 0) {
+				perror("setsockopt CAN_RAW_JOIN_FILTERS not supported by your Linux Kernel");
+				return 1;
+			}
+
+			if (numfilter)
+				setsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_FILTER,
+					   rfilter, numfilter * sizeof(struct can_filter));
+
+			free(rfilter);
+
+		} /* if (nptr) */
+
+		/* try to switch the socket into CAN FD mode */
+		setsockopt(obj->s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));
+
+		if (rcvbuf_size) {
+			int curr_rcvbuf_size;
+			socklen_t curr_rcvbuf_size_len = sizeof(curr_rcvbuf_size);
+
+			/* try SO_RCVBUFFORCE first, if we run with CAP_NET_ADMIN */
+			if (setsockopt(obj->s, SOL_SOCKET, SO_RCVBUFFORCE,
+				       &rcvbuf_size, sizeof(rcvbuf_size)) < 0) {
+#ifdef DEBUG
+				printf("SO_RCVBUFFORCE failed so try SO_RCVBUF ...\n");
+#endif
+				if (setsockopt(obj->s, SOL_SOCKET, SO_RCVBUF,
+					       &rcvbuf_size, sizeof(rcvbuf_size)) < 0) {
+					perror("setsockopt SO_RCVBUF");
+					return 1;
+				}
+
+				if (getsockopt(obj->s, SOL_SOCKET, SO_RCVBUF,
+					       &curr_rcvbuf_size, &curr_rcvbuf_size_len) < 0) {
+					perror("getsockopt SO_RCVBUF");
+					return 1;
+				}
+
+				/* Only print a warning the first time we detect the adjustment */
+				/* n.b.: The wanted size is doubled in Linux in net/sore/sock.c */
+				if (!i && curr_rcvbuf_size < rcvbuf_size * 2)
+					fprintf(stderr, "The socket receive buffer size was "
+						"adjusted due to /proc/sys/net/core/rmem_max.\n");
+			}
+		}
+
+		if (timestamp || log || logfrmt) {
+			if (hwtimestamp) {
+				const int timestamping_flags = (SOF_TIMESTAMPING_SOFTWARE |
+								SOF_TIMESTAMPING_RX_SOFTWARE |
+								SOF_TIMESTAMPING_RAW_HARDWARE);
+
+				if (setsockopt(obj->s, SOL_SOCKET, SO_TIMESTAMPING,
+					       &timestamping_flags, sizeof(timestamping_flags)) < 0) {
+					perror("setsockopt SO_TIMESTAMPING is not supported by your Linux kernel");
+					return 1;
+				}
+			} else {
+				const int timestamp_on = 1;
+
+				if (setsockopt(obj->s, SOL_SOCKET, SO_TIMESTAMP,
+					       &timestamp_on, sizeof(timestamp_on)) < 0) {
+					perror("setsockopt SO_TIMESTAMP");
+					return 1;
+				}
+			}
+		}
+
+		if (dropmonitor) {
+			const int dropmonitor_on = 1;
+
+			if (setsockopt(obj->s, SOL_SOCKET, SO_RXQ_OVFL,
+				       &dropmonitor_on, sizeof(dropmonitor_on)) < 0) {
+				perror("setsockopt SO_RXQ_OVFL not supported by your Linux Kernel");
+				return 1;
+			}
+		}
+
+		if (bind(obj->s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+			perror("bind");
+			return 1;
+		}
+	}
+
+	if (log) {
+		if (!logname) {
+			time_t currtime;
+			struct tm now;
+			char fname[83]; /* suggested by -Wformat-overflow= */
+
+			if (time(&currtime) == (time_t)-1) {
+				perror("time");
+				return 1;
+			}
+
+			localtime_r(&currtime, &now);
+
+			sprintf(fname, "candump-%04d-%02d-%02d_%02d%02d%02d.log",
+				now.tm_year + 1900,
+				now.tm_mon + 1,
+				now.tm_mday,
+				now.tm_hour,
+				now.tm_min,
+				now.tm_sec);
+
+			logname = fname;
+		}
+
+		if (silent != SILENT_ON)
+			fprintf(stderr, "Warning: Console output active while logging!\n");
+
+		fprintf(stderr, "Enabling Logfile '%s'\n", logname);
+
+		logfile = fopen(logname, "w");
+		if (!logfile) {
+			perror("logfile");
+			return 1;
+		}
+	}
+
+	/* these settings are static and can be held out of the hot path */
+	iov.iov_base = &frame;
+	msg.msg_name = &addr;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = &ctrlmsg;
+
+	while (running) {
+		num_events = epoll_wait(fd_epoll, events_pending, currmax, timeout_ms);
+		if (num_events == -1) {
+			if (errno != EINTR)
+				running = 0;
+			continue;
+		}
+
+		/* handle timeout */
+		if (!num_events && timeout_ms >= 0) {
+			running = 0;
+			continue;
+		}
+
+		for (i = 0; i < num_events; i++) {  /* check waiting CAN RAW sockets */
+			struct if_info* obj = events_pending[i].data.ptr;
+			int idx;
+			char *extra_info = "";
+
+			/* these settings may be modified by recvmsg() */
+			iov.iov_len = sizeof(frame);
+			msg.msg_namelen = sizeof(addr);
+			msg.msg_controllen = sizeof(ctrlmsg);
+			msg.msg_flags = 0;
+
+			nbytes = recvmsg(obj->s, &msg, 0);
+			idx = idx2dindex(addr.can_ifindex, obj->s);
+
+			if (nbytes < 0) {
+				if ((errno == ENETDOWN) && !down_causes_exit) {
+					fprintf(stderr, "%s: interface down\n", devname[idx]);
+					continue;
+				}
+				perror("read");
+				return 1;
+			}
+
+			if ((size_t)nbytes == CAN_MTU)
+				maxdlen = CAN_MAX_DLEN;
+			else if ((size_t)nbytes == CANFD_MTU)
+				maxdlen = CANFD_MAX_DLEN;
+			else {
+				fprintf(stderr, "read: incomplete CAN frame\n");
+				return 1;
+			}
+
+			if (count && (--count == 0))
+				running = 0;
+
+			for (cmsg = CMSG_FIRSTHDR(&msg);
+			     cmsg && (cmsg->cmsg_level == SOL_SOCKET);
+			     cmsg = CMSG_NXTHDR(&msg,cmsg)) {
+				if (cmsg->cmsg_type == SO_TIMESTAMP) {
+					memcpy(&tv, CMSG_DATA(cmsg), sizeof(tv));
+				} else if (cmsg->cmsg_type == SO_TIMESTAMPING) {
+
+					struct timespec *stamp = (struct timespec *)CMSG_DATA(cmsg);
+
+					/*
+					 * stamp[0] is the software timestamp
+					 * stamp[1] is deprecated
+					 * stamp[2] is the raw hardware timestamp
+					 * See chapter 2.1.2 Receive timestamps in
+					 * linux/Documentation/networking/timestamping.txt
+					 */
+					tv.tv_sec = stamp[2].tv_sec;
+					tv.tv_usec = stamp[2].tv_nsec/1000;
+				} else if (cmsg->cmsg_type == SO_RXQ_OVFL)
+					memcpy(&obj->dropcnt, CMSG_DATA(cmsg), sizeof(__u32));
+			}
+
+			/* check for (unlikely) dropped frames on this specific socket */
+			if (obj->dropcnt != obj->last_dropcnt) {
+
+				__u32 frames = obj->dropcnt - obj->last_dropcnt;
+
+				if (silent != SILENT_ON)
+					printf("DROPCOUNT: dropped %d CAN frame%s on '%s' socket (total drops %d)\n",
+					       frames, (frames > 1)?"s":"", devname[idx], obj->dropcnt);
+
+				if (log)
+					fprintf(logfile, "DROPCOUNT: dropped %d CAN frame%s on '%s' socket (total drops %d)\n",
+						frames, (frames > 1)?"s":"", devname[idx], obj->dropcnt);
+
+				obj->last_dropcnt = obj->dropcnt;
+			}
+
+			/* once we detected a EFF frame indent SFF frames accordingly */
+			if (frame.can_id & CAN_EFF_FLAG)
+				view |= CANLIB_VIEW_INDENT_SFF;
+
+			if (extra_msg_info) {
+				if (msg.msg_flags & MSG_DONTROUTE)
+					extra_info = " T";
+				else
+					extra_info = " R";
+			}
+
+			if (log) {
+				char buf[CL_CFSZ]; /* max length */
+				char ts_buf[TIMESTAMPSZ];
+
+				sprint_timestamp(logtimestamp, &tv, &last_tv, ts_buf);
+
+				/* log CAN frame with absolute timestamp & device */
+				sprint_canframe(buf, &frame, 0, maxdlen);
+				fprintf(logfile, "%s%*s %s%s\n", ts_buf,
+					max_devname_len, devname[idx], buf,
+					extra_info);
+			}
+
+			if ((logfrmt) && (silent == SILENT_OFF)){
+				char buf[CL_CFSZ]; /* max length */
+
+				/* print CAN frame in log file style to stdout */
+				sprint_canframe(buf, &frame, 0, maxdlen);
+				print_timestamp(logtimestamp, &tv, &last_tv);
+
+				printf("%*s %s%s\n",
+					max_devname_len, devname[idx], buf,
+					extra_info);
+				goto out_fflush; /* no other output to stdout */
+			}
+
+			if (silent != SILENT_OFF){
+				if (silent == SILENT_ANI) {
+					printf("%c\b", anichar[silentani %= MAXANI]);
+					silentani++;
+				}
+				goto out_fflush; /* no other output to stdout */
+			}
+
+			printf(" %s", (color > 2) ? col_on[idx % MAXCOL] : "");
+			print_timestamp(timestamp, &tv, &last_tv);
+			printf(" %s", (color && (color < 3)) ? col_on[idx % MAXCOL] : "");
+			printf("%*s", max_devname_len, devname[idx]);
+
+			if (extra_msg_info) {
+
+				if (msg.msg_flags & MSG_DONTROUTE)
+					printf ("  TX %s", extra_m_info[frame.flags & 3]);
+				else
+					printf ("  RX %s", extra_m_info[frame.flags & 3]);
+			}
+
+			printf("%s  ", (color == 1) ? col_off : "");
+
+			fprint_long_canframe(stdout, &frame, NULL, view, maxdlen);
+
+			printf("%s", (color > 1) ? col_off : "");
+			printf("\n");
+
+ out_fflush:
+			fflush(stdout);
+		}
+	}
+
+	for (i = 0; i < currmax; i++)
+		close(sock_info[i].s);
+
+	close(fd_epoll);
+
+	if (log)
+		fclose(logfile);
+
+	return 0;
+}
diff --git a/canutils/canfdtest.c b/canutils/canfdtest.c
new file mode 100644
index 0000000000..704524f52f
--- /dev/null
+++ b/canutils/canfdtest.c
@@ -0,0 +1,577 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * canfdtest.c - Full-duplex test program (DUT and host part)
+ *
+ * (C) 2009 by Vladislav Gribov, IXXAT Automation GmbH, <gribov@ixxat.de>
+ * (C) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ * (C) 2021 Jean Gressmann, IAV GmbH, <jean.steven.gressmann@iav.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ */
+
+#include <errno.h>
+#include <getopt.h>
+#include <libgen.h>
+#include <limits.h>
+#include <sched.h>
+#include <signal.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+
+#define CAN_MSG_ID_PING	0x77
+#define CAN_MSG_ID_PONG	0x78
+#define CAN_MSG_LEN	8
+#define CAN_MSG_COUNT	50
+#define CAN_MSG_WAIT	27
+
+static int running = 1;
+static int verbose;
+static int sockfd;
+static int test_loops;
+static int exit_sig;
+static int inflight_count = CAN_MSG_COUNT;
+static canid_t can_id_ping = CAN_MSG_ID_PING;
+static canid_t can_id_pong = CAN_MSG_ID_PONG;
+static int has_pong_id = 0;
+static int is_can_fd = 0;
+static int bit_rate_switch = 0;
+static int msg_len = CAN_MSG_LEN;
+
+static void print_usage(char *prg)
+{
+	fprintf(stderr,
+		"%s - Full-duplex test program (DUT and host part).\n"
+		"Usage: %s [options] <can-interface>\n"
+		"\n"
+		"Options:\n"
+		"         -b       (enable CAN FD Bit Rate Switch)\n"
+		"         -d       (use CAN FD frames instead of classic CAN)\n"
+		"         -f COUNT (number of frames in flight, default: %d)\n"
+		"         -g       (generate messages)\n"
+		"         -i ID    (CAN ID to use for frames to DUT (ping), default %x)\n"
+		"         -l COUNT (test loop count)\n"
+		"         -o ID    (CAN ID to use for frames to host (pong), default %x)\n"
+		"         -s SIZE  (frame payload size in bytes)\n"
+		"         -v       (low verbosity)\n"
+		"         -vv      (high verbosity)\n"
+		"         -x       (ignore other frames on bus)\n"
+		"\n"
+		"With the option '-g' CAN messages are generated and checked\n"
+		"on <can-interface>, otherwise all messages received on the\n"
+                "<can-interface> are sent back incrementing the CAN id and\n"
+		"all data bytes. The program can be aborted with ^C.\n"
+		"\n"
+		"Examples:\n"
+		"\ton DUT:\n"
+		"%s -v can0\n"
+		"\ton Host:\n"
+		"%s -g -v can2\n",
+		prg, prg, CAN_MSG_COUNT, CAN_MSG_ID_PING, CAN_MSG_ID_PONG, prg, prg);
+
+	exit(1);
+}
+
+static void print_frame(canid_t id, const uint8_t *data, int dlc, int inc_data)
+{
+	int i;
+
+	printf("%04x: ", id);
+	if (id & CAN_RTR_FLAG) {
+		printf("remote request");
+	} else {
+		printf("[%d]", dlc);
+		for (i = 0; i < dlc; i++)
+			printf(" %02x", (uint8_t)(data[i] + inc_data));
+	}
+	printf("\n");
+}
+
+static void print_compare(
+	canid_t exp_id,
+	const uint8_t *exp_data,
+	uint8_t exp_dlc,
+	canid_t rec_id,
+	const uint8_t *rec_data,
+	uint8_t rec_dlc,
+	int inc)
+{
+	printf("expected: ");
+	print_frame(exp_id, exp_data, exp_dlc, inc);
+	printf("received: ");
+	print_frame(rec_id, rec_data, rec_dlc, 0);
+}
+
+static int compare_frame(const struct canfd_frame *exp, const struct canfd_frame *rec, int inc)
+{
+	int i, err = 0;
+	const canid_t expected_can_id = inc ? can_id_pong : can_id_ping;
+
+	if (rec->can_id != expected_can_id) {
+		printf("Message ID mismatch!\n");
+		print_compare(expected_can_id, exp->data, exp->len,
+		              rec->can_id, rec->data, rec->len, inc);
+		running = 0;
+		err = -1;
+	} else if (rec->len != exp->len) {
+		printf("Message length mismatch!\n");
+		print_compare(expected_can_id, exp->data, exp->len,
+		              rec->can_id, rec->data, rec->len, inc);
+		running = 0;
+		err = -1;
+	} else {
+		for (i = 0; i < rec->len; i++) {
+			if (rec->data[i] != (uint8_t)(exp->data[i] + inc)) {
+				printf("Databyte %x mismatch!\n", i);
+				print_compare(expected_can_id, exp->data, exp->len,
+				              rec->can_id, rec->data, rec->len, inc);
+				running = 0;
+				err = -1;
+			}
+		}
+	}
+	return err;
+}
+
+static void millisleep(int msecs)
+{
+	struct timespec rqtp, rmtp;
+	int err;
+
+	/* sleep in ms */
+	rqtp.tv_sec = msecs / 1000;
+	rqtp.tv_nsec = msecs % 1000 * 1000000;
+
+	do {
+		err = clock_nanosleep(CLOCK_MONOTONIC, 0, &rqtp, &rmtp);
+		if (err != 0 && err != EINTR) {
+			printf("t\n");
+			break;
+		}
+		rqtp = rmtp;
+	} while (err != 0);
+}
+
+static void echo_progress(unsigned char data)
+{
+	if (data == 0xff) {
+		printf(".");
+		fflush(stdout);
+	}
+}
+
+static void signal_handler(int signo)
+{
+	close(sockfd);
+	running = 0;
+	exit_sig = signo;
+}
+
+static int recv_frame(struct canfd_frame *frame)
+{
+	ssize_t ret, len;
+
+	if (is_can_fd)
+		len = sizeof(struct canfd_frame);
+	else
+		len = sizeof(struct can_frame);
+
+	ret = recv(sockfd, frame, len, 0);
+	if (ret != len) {
+		if (ret < 0)
+			perror("recv failed");
+		else
+			fprintf(stderr, "recv returned %zd", ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int send_frame(struct canfd_frame *frame)
+{
+	ssize_t ret, len;
+
+	if (is_can_fd)
+		len = sizeof(struct canfd_frame);
+	else
+		len = sizeof(struct can_frame);
+
+	if (bit_rate_switch)
+		frame->flags |= CANFD_BRS;
+
+	while ((ret = send(sockfd, frame, len, 0)) != len) {
+		if (ret >= 0) {
+			fprintf(stderr, "send returned %zd", ret);
+			return -1;
+		}
+		if (errno != ENOBUFS) {
+			perror("send failed");
+			return -1;
+		}
+		if (verbose) {
+			printf("N");
+			fflush(stdout);
+		}
+	}
+	return 0;
+}
+
+static int check_frame(const struct canfd_frame *frame)
+{
+	int err = 0;
+	int i;
+
+	if (frame->can_id != can_id_ping) {
+		printf("Unexpected Message ID 0x%04x!\n", frame->can_id);
+		err = -1;
+	}
+
+	if (frame->len != msg_len) {
+		printf("Unexpected Message length %d!\n", frame->len);
+		err = -1;
+	}
+
+	for (i = 1; i < frame->len; i++) {
+		if (frame->data[i] != (uint8_t)(frame->data[i-1] + 1)) {
+			printf("Frame inconsistent!\n");
+			print_frame(frame->can_id, frame->data, frame->len, 0);
+			err = -1;
+			goto out;
+		}
+	}
+
+ out:
+	return err;
+}
+
+static void inc_frame(struct canfd_frame *frame)
+{
+	int i;
+
+	if (has_pong_id)
+		frame->can_id = can_id_pong;
+	else
+		frame->can_id++;
+
+	for (i = 0; i < frame->len; i++)
+		frame->data[i]++;
+}
+
+static int can_echo_dut(void)
+{
+	unsigned int frame_count = 0;
+	struct canfd_frame frame;
+	int err = 0;
+
+	while (running) {
+		if (recv_frame(&frame))
+			return -1;
+		frame_count++;
+		if (verbose == 1) {
+			echo_progress(frame.data[0]);
+		} else if (verbose > 1) {
+			print_frame(frame.can_id, frame.data, frame.len, 0);
+		}
+
+		err = check_frame(&frame);
+		inc_frame(&frame);
+		if (send_frame(&frame))
+			return -1;
+
+		/*
+		 * to force a interlacing of the frames send by DUT and PC
+		 * test tool a waiting time is injected
+		 */
+		if (frame_count == CAN_MSG_WAIT) {
+			frame_count = 0;
+			millisleep(3);
+		}
+	}
+
+	return err;
+}
+
+static int can_echo_gen(void)
+{
+	struct canfd_frame *tx_frames;
+	int *recv_tx;
+	struct canfd_frame rx_frame;
+	unsigned char counter = 0;
+	int send_pos = 0, recv_rx_pos = 0, recv_tx_pos = 0, unprocessed = 0, loops = 0;
+	int err = 0;
+	int i;
+
+	tx_frames = calloc(inflight_count, sizeof(* tx_frames));
+	if (!tx_frames)
+		return -1;
+
+	recv_tx = calloc(inflight_count, sizeof(* recv_tx));
+	if (!recv_tx) {
+		err = -1;
+		goto out_free_tx_frames;
+	}
+
+	while (running) {
+		if (unprocessed < inflight_count) {
+			/* still send messages */
+			tx_frames[send_pos].len = msg_len;
+			tx_frames[send_pos].can_id = can_id_ping;
+			recv_tx[send_pos] = 0;
+
+			for (i = 0; i < msg_len; i++)
+				tx_frames[send_pos].data[i] = counter + i;
+			if (send_frame(&tx_frames[send_pos])) {
+				err = -1;
+				goto out_free;
+			}
+
+			send_pos++;
+			if (send_pos == inflight_count)
+				send_pos = 0;
+			unprocessed++;
+			if (verbose == 1)
+				echo_progress(counter);
+			counter++;
+
+			if ((counter % 33) == 0)
+				millisleep(3);
+			else
+				millisleep(1);
+		} else {
+			if (recv_frame(&rx_frame)) {
+				err = -1;
+				goto out_free;
+			}
+
+			if (verbose > 1)
+				print_frame(rx_frame.can_id, rx_frame.data, rx_frame.len, 0);
+
+			/* own frame */
+			if (rx_frame.can_id == can_id_ping) {
+				err = compare_frame(&tx_frames[recv_tx_pos], &rx_frame, 0);
+				recv_tx[recv_tx_pos] = 1;
+				recv_tx_pos++;
+				if (recv_tx_pos == inflight_count)
+					recv_tx_pos = 0;
+				continue;
+			}
+
+			if (!recv_tx[recv_rx_pos]) {
+				printf("RX before TX!\n");
+				print_frame(rx_frame.can_id, rx_frame.data, rx_frame.len, 0);
+				running = 0;
+			}
+			/* compare with expected */
+			err = compare_frame(&tx_frames[recv_rx_pos], &rx_frame, 1);
+			recv_rx_pos++;
+			if (recv_rx_pos == inflight_count)
+				recv_rx_pos = 0;
+
+			loops++;
+			if (test_loops && loops >= test_loops)
+				break;
+
+			unprocessed--;
+		}
+	}
+
+	printf("\nTest messages sent and received: %d\n", loops);
+
+ out_free:
+	free(recv_tx);
+ out_free_tx_frames:
+	free(tx_frames);
+
+	return err;
+}
+
+int main(int argc, char *argv[])
+{
+	struct sockaddr_can addr;
+	char *intf_name;
+	int family = PF_CAN, type = SOCK_RAW, proto = CAN_RAW;
+	int echo_gen = 0;
+	int opt, err;
+	int enable_socket_option = 1;
+	int filter = 0;
+
+	signal(SIGTERM, signal_handler);
+	signal(SIGHUP, signal_handler);
+	signal(SIGINT, signal_handler);
+
+	while ((opt = getopt(argc, argv, "bdf:gi:l:o:s:vx?")) != -1) {
+		switch (opt) {
+		case 'b':
+			bit_rate_switch = 1;
+			break;
+
+		case 'd':
+			is_can_fd = 1;
+			break;
+
+		case 'f':
+			inflight_count = atoi(optarg);
+			break;
+
+		case 'g':
+			echo_gen = 1;
+			break;
+
+		case 'i':
+			can_id_ping = strtoul(optarg, NULL, 16) & CAN_SFF_MASK;
+			break;
+
+		case 'l':
+			test_loops = atoi(optarg);
+			break;
+
+		case 'o':
+			can_id_pong = strtoul(optarg, NULL, 16) & CAN_SFF_MASK;
+			has_pong_id = 1;
+			break;
+
+		case 's':
+			msg_len = atoi(optarg);
+			break;
+
+		case 'v':
+			verbose++;
+			break;
+
+		case 'x':
+			filter = 1;
+			break;
+
+		case '?':
+		default:
+			print_usage(basename(argv[0]));
+			break;
+		}
+	}
+
+	/* BRS can be enabled only if CAN FD is enabled */
+	if (bit_rate_switch && !is_can_fd) {
+		printf("Bit rate switch (-b) needs CAN FD (-d) to be enabled\n");
+		return 1;
+	}
+
+	/* Make sure the message length is valid */
+	if (msg_len <= 0) {
+		printf("Message length must > 0\n");
+		return 1;
+	}
+	if (is_can_fd) {
+		if (msg_len > CANFD_MAX_DLEN) {
+			printf("Message length must be <= %d bytes for CAN FD\n", CANFD_MAX_DLEN);
+			return 1;
+		}
+	} else {
+		if (msg_len > CAN_MAX_DLEN) {
+			printf("Message length must be <= %d bytes for CAN 2.0B\n", CAN_MAX_DLEN);
+			return 1;
+		}
+	}
+
+	if ((argc - optind) != 1)
+		print_usage(basename(argv[0]));
+	intf_name = argv[optind];
+
+	printf("interface = %s, family = %d, type = %d, proto = %d\n",
+	       intf_name, family, type, proto);
+
+	if ((sockfd = socket(family, type, proto)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	if (echo_gen) {
+		if (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS,
+			   &enable_socket_option, sizeof(enable_socket_option)) == -1) {
+			perror("setsockopt CAN_RAW_RECV_OWN_MSGS");
+			return 1;
+		}
+	}
+
+	if (is_can_fd) {
+		if (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,
+			   &enable_socket_option, sizeof(enable_socket_option)) == -1) {
+			perror("setsockopt CAN_RAW_FD_FRAMES");
+			return 1;
+		}
+	}
+
+	addr.can_family = family;
+	addr.can_ifindex = if_nametoindex(intf_name);
+	if (!addr.can_ifindex) {
+		perror("if_nametoindex");
+		close(sockfd);
+		return 1;
+	}
+
+	if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		close(sockfd);
+		return 1;
+	}
+
+	if (!has_pong_id)
+		can_id_pong = can_id_ping + 1;
+
+	if (filter) {
+		const struct can_filter filters[] = {
+			{
+				.can_id = can_id_ping,
+				.can_mask = CAN_EFF_FLAG | CAN_RTR_FLAG | CAN_SFF_MASK,
+			},
+			{
+				.can_id = can_id_pong,
+				.can_mask = CAN_EFF_FLAG | CAN_RTR_FLAG | CAN_SFF_MASK,
+			},
+		};
+
+		if (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_FILTER, filters,
+					   sizeof(struct can_filter) * (1 + echo_gen))) {
+			perror("setsockopt()");
+			close(sockfd);
+			return 1;
+		}
+	}
+
+	if (echo_gen)
+		err = can_echo_gen();
+	else
+		err = can_echo_dut();
+
+	if (verbose)
+		printf("Exiting...\n");
+
+	close(sockfd);
+
+	if (exit_sig) {
+		signal(exit_sig, SIG_DFL);
+		kill(getpid(), exit_sig);
+	}
+
+	return err;
+}
diff --git a/canutils/canframelen.c b/canutils/canframelen.c
new file mode 100644
index 0000000000..e0ca1f572c
--- /dev/null
+++ b/canutils/canframelen.c
@@ -0,0 +1,283 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * canframelen.c
+ *
+ * Copyright (c) 2013, 2014 Czech Technical University in Prague
+ *
+ * Author: Michal Sojka <sojkam1@fel.cvut.cz>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Czech Technical University in Prague nor the
+ *    names of its contributors may be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <arpa/inet.h>
+#include <assert.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "canframelen.h"
+
+/**
+ * Functions and types for CRC checks.
+ *
+ * Generated on Wed Jan  8 15:14:20 2014,
+ * by pycrc v0.8.1, http://www.tty1.net/pycrc/
+ * using the configuration:
+ *    Width        = 15
+ *    Poly         = 0x4599
+ *    XorIn        = 0x0000
+ *    ReflectIn    = False
+ *    XorOut       = 0x0000
+ *    ReflectOut   = False
+ *    Algorithm    = table-driven
+ *****************************************************************************/
+
+typedef uint16_t crc_t;
+
+/**
+ * Static table used for the table_driven implementation.
+ *****************************************************************************/
+static const crc_t crc_table[256] = {
+	0x0000, 0x4599, 0x4eab, 0x0b32, 0x58cf, 0x1d56, 0x1664, 0x53fd, 0x7407, 0x319e, 0x3aac, 0x7f35, 0x2cc8, 0x6951, 0x6263, 0x27fa,
+	0x2d97, 0x680e, 0x633c, 0x26a5, 0x7558, 0x30c1, 0x3bf3, 0x7e6a, 0x5990, 0x1c09, 0x173b, 0x52a2, 0x015f, 0x44c6, 0x4ff4, 0x0a6d,
+	0x5b2e, 0x1eb7, 0x1585, 0x501c, 0x03e1, 0x4678, 0x4d4a, 0x08d3, 0x2f29, 0x6ab0, 0x6182, 0x241b, 0x77e6, 0x327f, 0x394d, 0x7cd4,
+	0x76b9, 0x3320, 0x3812, 0x7d8b, 0x2e76, 0x6bef, 0x60dd, 0x2544, 0x02be, 0x4727, 0x4c15, 0x098c, 0x5a71, 0x1fe8, 0x14da, 0x5143,
+	0x73c5, 0x365c, 0x3d6e, 0x78f7, 0x2b0a, 0x6e93, 0x65a1, 0x2038, 0x07c2, 0x425b, 0x4969, 0x0cf0, 0x5f0d, 0x1a94, 0x11a6, 0x543f,
+	0x5e52, 0x1bcb, 0x10f9, 0x5560, 0x069d, 0x4304, 0x4836, 0x0daf, 0x2a55, 0x6fcc, 0x64fe, 0x2167, 0x729a, 0x3703, 0x3c31, 0x79a8,
+	0x28eb, 0x6d72, 0x6640, 0x23d9, 0x7024, 0x35bd, 0x3e8f, 0x7b16, 0x5cec, 0x1975, 0x1247, 0x57de, 0x0423, 0x41ba, 0x4a88, 0x0f11,
+	0x057c, 0x40e5, 0x4bd7, 0x0e4e, 0x5db3, 0x182a, 0x1318, 0x5681, 0x717b, 0x34e2, 0x3fd0, 0x7a49, 0x29b4, 0x6c2d, 0x671f, 0x2286,
+	0x2213, 0x678a, 0x6cb8, 0x2921, 0x7adc, 0x3f45, 0x3477, 0x71ee, 0x5614, 0x138d, 0x18bf, 0x5d26, 0x0edb, 0x4b42, 0x4070, 0x05e9,
+	0x0f84, 0x4a1d, 0x412f, 0x04b6, 0x574b, 0x12d2, 0x19e0, 0x5c79, 0x7b83, 0x3e1a, 0x3528, 0x70b1, 0x234c, 0x66d5, 0x6de7, 0x287e,
+	0x793d, 0x3ca4, 0x3796, 0x720f, 0x21f2, 0x646b, 0x6f59, 0x2ac0, 0x0d3a, 0x48a3, 0x4391, 0x0608, 0x55f5, 0x106c, 0x1b5e, 0x5ec7,
+	0x54aa, 0x1133, 0x1a01, 0x5f98, 0x0c65, 0x49fc, 0x42ce, 0x0757, 0x20ad, 0x6534, 0x6e06, 0x2b9f, 0x7862, 0x3dfb, 0x36c9, 0x7350,
+	0x51d6, 0x144f, 0x1f7d, 0x5ae4, 0x0919, 0x4c80, 0x47b2, 0x022b, 0x25d1, 0x6048, 0x6b7a, 0x2ee3, 0x7d1e, 0x3887, 0x33b5, 0x762c,
+	0x7c41, 0x39d8, 0x32ea, 0x7773, 0x248e, 0x6117, 0x6a25, 0x2fbc, 0x0846, 0x4ddf, 0x46ed, 0x0374, 0x5089, 0x1510, 0x1e22, 0x5bbb,
+	0x0af8, 0x4f61, 0x4453, 0x01ca, 0x5237, 0x17ae, 0x1c9c, 0x5905, 0x7eff, 0x3b66, 0x3054, 0x75cd, 0x2630, 0x63a9, 0x689b, 0x2d02,
+	0x276f, 0x62f6, 0x69c4, 0x2c5d, 0x7fa0, 0x3a39, 0x310b, 0x7492, 0x5368, 0x16f1, 0x1dc3, 0x585a, 0x0ba7, 0x4e3e, 0x450c, 0x0095
+};
+
+/**
+ * Update the crc value with new data.
+ *
+ * \param crc      The current crc value.
+ * \param data     Pointer to a buffer of \a data_len bytes.
+ * \param data_len Number of bytes in the \a data buffer.
+ * \return         The updated crc value.
+ *****************************************************************************/
+static crc_t crc_update_bytewise(crc_t crc, const unsigned char *data, size_t data_len)
+{
+	unsigned int tbl_idx;
+
+	while (data_len--) {
+		tbl_idx = ((crc >> 7) ^ *data) & 0xff;
+		crc = (crc_table[tbl_idx] ^ (crc << 8)) & 0x7fff;
+
+		data++;
+	}
+	return crc & 0x7fff;
+}
+
+/**
+ * Update the crc value with new data.
+ *
+ * \param crc      The current crc value.
+ * \param data     Data value
+ * \param bits	   The number of most significant bits in data used for CRC calculation
+ * \return         The updated crc value.
+ *****************************************************************************/
+static crc_t crc_update_bitwise(crc_t crc, uint8_t data, size_t bits)
+{
+	uint8_t i;
+	bool bit;
+
+	for (i = 0x80; bits--; i >>= 1) {
+		bit = crc & 0x4000;
+		if (data & i) {
+			bit = !bit;
+		}
+		crc <<= 1;
+		if (bit) {
+			crc ^= 0x4599;
+		}
+	}
+	return crc & 0x7fff;
+}
+
+static crc_t calc_bitmap_crc(uint8_t *bitmap, unsigned start, unsigned end)
+{
+	crc_t crc = 0;
+
+	if (start % 8) {
+		crc = crc_update_bitwise(crc, bitmap[start / 8] << (start % 8), 8 - start % 8);
+		start += 8 - start % 8;
+	}
+	crc = crc_update_bytewise(crc, &bitmap[start / 8], (end - start) / 8);
+	crc = crc_update_bitwise(crc, bitmap[end / 8], end % 8);
+	return crc;
+}
+
+static unsigned cfl_exact(struct can_frame *frame)
+{
+	uint8_t bitmap[16];
+	unsigned start = 0, end;
+	crc_t crc;
+	uint16_t crc_be;
+	uint8_t mask, lookfor;
+	unsigned i, stuffed;
+	const int8_t clz[32] = /* count of leading zeros in 5 bit numbers */
+		{ 5, 4, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+	/* Prepare bitmap */
+	memset(bitmap, 0, sizeof(bitmap));
+	if (frame->can_id & CAN_EFF_FLAG) {
+		/* bit            7      0 7      0 7      0 7      0
+		 * bitmap[0-3]   |.sBBBBBB BBBBBSIE EEEEEEEE EEEEEEEE| s = SOF, B = Base ID (11 bits), S = SRR, I = IDE, E = Extended ID (18 bits)
+		 * bitmap[4-7]   |ER10DLC4 00000000 11111111 22222222| R = RTR, 0 = r0, 1 = r1, DLC4 = DLC, Data bytes
+		 * bitmap[8-11]  |33333333 44444444 55555555 66666666| Data bytes
+		 * bitmap[12-15] |77777777 ........ ........ ........| Data bytes
+		 */
+		bitmap[0] = (frame->can_id & CAN_EFF_MASK) >> 23;
+		bitmap[1] = ((frame->can_id >> 18) & 0x3f) << 3 |
+			    3 << 1	       	     	      	| /* SRR, IDE */
+			    ((frame->can_id >> 17) & 0x01);
+		bitmap[2] = (frame->can_id >> 9) & 0xff;
+		bitmap[3] = (frame->can_id >> 1) & 0xff;
+		bitmap[4] = (frame->can_id & 0x1) << 7              |
+			    (!!(frame->can_id & CAN_RTR_FLAG)) << 6 |
+			    0 << 4	      		       	    | /* r1, r0 */
+			    (frame->can_dlc & 0xf);
+		memcpy(&bitmap[5], &frame->data, frame->can_dlc);
+		start = 1;
+		end = 40 + 8*frame->can_dlc;
+	} else {
+		/* bit           7      0 7      0 7      0 7      0
+		 * bitmap[0-3]  |.....sII IIIIIIII IRE0DLC4 00000000| s = SOF, I = ID (11 bits), R = RTR, E = IDE, DLC4 = DLC
+		 * bitmap[4-7]  |11111111 22222222 33333333 44444444| Data bytes
+		 * bitmap[8-11] |55555555 66666666 77777777 ........| Data bytes
+		 */
+		bitmap[0] = (frame->can_id & CAN_SFF_MASK) >> 9;
+		bitmap[1] = (frame->can_id >> 1) & 0xff;
+		bitmap[2] = ((frame->can_id << 7) & 0xff) |
+			    (!!(frame->can_id & CAN_RTR_FLAG)) << 6 |
+			    0 << 4 | /* IDE, r0 */
+			    (frame->can_dlc & 0xf);
+		memcpy(&bitmap[3], &frame->data, frame->can_dlc);
+		start = 5;
+		end = 24 + 8 * frame->can_dlc;
+	}
+
+	/* Calc and append CRC */
+	crc = calc_bitmap_crc(bitmap, start, end);
+	crc_be = htons(crc << 1);
+	assert(end % 8 == 0);
+	memcpy(bitmap + end / 8, &crc_be, 2);
+	end += 15;
+
+	/* Count stuffed bits */
+	mask 	= 0x1f;
+	lookfor = 0;
+	i 	= start;
+	stuffed = 0;
+	while (i < end) {
+		unsigned change;
+		unsigned bits = (bitmap[i / 8] << 8 | bitmap[i / 8 + 1]) >> (16 - 5 - i % 8);
+		lookfor = lookfor ? 0 : mask; /* We alternate between looking for a series of zeros or ones */
+		change = (bits & mask) ^ lookfor; /* 1 indicates a change */
+		if (change) { /* No bit was stuffed here */
+			i += clz[change];
+			mask = 0x1f; /* Next look for 5 same bits */
+		} else {
+			i += (mask == 0x1f) ? 5 : 4;
+			if (i <= end) {
+				stuffed++;
+				mask = 0x1e; /* Next look for 4 bits (5th bit is the stuffed one) */
+			}
+		}
+	}
+	return end - start + stuffed +
+		3 + 		/* CRC del, ACK, ACK del */
+		7 +		/* EOF */
+		3;		/* IFS */
+}
+
+unsigned can_frame_dbitrate_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu)
+{
+	if (mtu != CANFD_MTU || !(frame->flags & CANFD_BRS))
+		return 0;
+	switch (mode) {
+	case CFL_NO_BITSTUFFING:
+		return 1 /* brs/crcdel */ + 1 /* esi */ + 4 /* dlc */ +
+			((frame->len >= 16) ? 21 : 17) +
+			frame->len * 8;
+	case CFL_WORSTCASE:
+		return can_frame_dbitrate_length(frame, CFL_NO_BITSTUFFING, mtu) * 5 / 4;
+	default:
+		return 0;
+	}
+}
+
+unsigned can_frame_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu)
+{
+	int eff = (frame->can_id & CAN_EFF_FLAG);
+
+	if (mtu == CANFD_MTU)
+		/* not correct, but close ? */
+		switch (mode) {
+		case CFL_NO_BITSTUFFING:
+			return 1 + (eff ? 29 : 11) + ((frame->len >= 16) ? 21 : 17) +
+				5 /* r1, ide, edl, r0, brs/crcdel, */ + 12 /* trail */ +
+				frame->len * 8;
+		case CFL_WORSTCASE:
+			return can_frame_length(frame, CFL_NO_BITSTUFFING, mtu) * 5 / 4;
+		case CFL_EXACT:
+			return 0; /* exact bittiming for CANFD not supported yet */
+		}
+	else if (mtu != CAN_MTU)
+		return 0; /* Only CAN2.0 and CANFD supported now */
+
+	switch (mode) {
+	case CFL_NO_BITSTUFFING:
+		return (eff ? 67 : 47) + frame->len * 8;
+	case CFL_WORSTCASE:
+		return (eff ? 80 : 55) + frame->len * 10;
+	case CFL_EXACT:
+		return cfl_exact((struct can_frame*)frame);
+	}
+	return 0; /* Unknown mode */
+}
diff --git a/canutils/canframelen.h b/canutils/canframelen.h
new file mode 100644
index 0000000000..47739b202c
--- /dev/null
+++ b/canutils/canframelen.h
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * canframelen.h
+ *
+ * Copyright (c) 2013, 2014 Czech Technical University in Prague
+ *
+ * Author: Michal Sojka <sojkam1@fel.cvut.cz>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Czech Technical University in Prague nor the
+ *    names of its contributors may be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#ifndef CANFRAMELEN_H
+#define CANFRAMELEN_H
+
+#include <linux/can.h>
+
+/**
+ * Frame length calculation modes.
+ *
+ * CFL_WORSTCASE corresponds to *worst* case calculation for
+ * stuff-bits - see (1)-(3) in [1]. The worst case number of bits on
+ * the wire can be calculated as:
+ *
+ * (34 + 8n - 1)/4 + 34 + 8n + 13 for SFF frames (11 bit CAN-ID) => 55 + 10n
+ * (54 + 8n - 1)/4 + 54 + 8n + 13 for EFF frames (29 bit CAN-ID) => 80 + 10n
+ *
+ * while 'n' is the data length code (number of payload bytes)
+ *
+ * [1] "Controller Area Network (CAN) schedulability analysis:
+ *     Refuted, revisited and revised", Real-Time Syst (2007)
+ *     35:239-272.
+ *
+ */
+enum cfl_mode {
+	CFL_NO_BITSTUFFING, /* plain bit calculation without bitstuffing */
+	CFL_WORSTCASE, /* worst case estimation - see above */
+	CFL_EXACT, /* exact calculation of stuffed bits based on frame
+		    * content and CRC */
+};
+
+/**
+ * Calculates the number of bits a frame needs on the wire (including
+ * inter frame space).
+ *
+ * Mode determines how to deal with stuffed bits.
+ */
+unsigned can_frame_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu);
+unsigned can_frame_dbitrate_length(struct canfd_frame *frame, enum cfl_mode mode, int mtu);
+
+#endif
diff --git a/canutils/cangen.c b/canutils/cangen.c
new file mode 100644
index 0000000000..232706467b
--- /dev/null
+++ b/canutils/cangen.c
@@ -0,0 +1,582 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * cangen.c - CAN frames generator
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <libgen.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+
+#include "lib.h"
+
+#define DEFAULT_GAP 200 /* ms */
+#define DEFAULT_BURST_COUNT 1
+
+#define MODE_RANDOM	0
+#define MODE_INCREMENT	1
+#define MODE_FIX	2
+#define MODE_RANDOM_EVEN	3
+#define MODE_RANDOM_ODD	4
+
+extern int optind, opterr, optopt;
+
+static volatile int running = 1;
+static unsigned long long enobufs_count;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - CAN frames generator.\n\n", prg);
+	fprintf(stderr, "Usage: %s [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -g <ms>       (gap in milli seconds "
+		"- default: %d ms)\n", DEFAULT_GAP);
+	fprintf(stderr, "         -e            (generate extended frame mode "
+		"(EFF) CAN frames)\n");
+	fprintf(stderr, "         -f            (generate CAN FD CAN frames)\n");
+	fprintf(stderr, "         -b            (generate CAN FD CAN frames"
+		" with bitrate switch (BRS))\n");
+	fprintf(stderr, "         -E            (generate CAN FD CAN frames"
+		" with error state (ESI))\n");
+	fprintf(stderr, "         -R            (generate RTR frames)\n");
+	fprintf(stderr, "         -8            (allow DLC values greater then 8 for Classic CAN frames)\n");
+	fprintf(stderr, "         -m            (mix -e -f -b -E -R frames)\n");
+	fprintf(stderr, "         -I <mode>     (CAN ID"
+		" generation mode - see below)\n");
+	fprintf(stderr, "         -L <mode>     (CAN data length code (dlc)"
+		" generation mode - see below)\n");
+	fprintf(stderr, "         -D <mode>     (CAN data (payload)"
+		" generation mode - see below)\n");
+	fprintf(stderr, "         -p <timeout>  (poll on -ENOBUFS to write frames"
+		" with <timeout> ms)\n");
+	fprintf(stderr, "         -n <count>    (terminate after <count> CAN frames "
+		"- default infinite)\n");
+	fprintf(stderr, "         -i            (ignore -ENOBUFS return values on"
+		" write() syscalls)\n");
+	fprintf(stderr, "         -x            (disable local loopback of "
+		"generated CAN frames)\n");
+	fprintf(stderr, "         -c <count>    (number of messages to send in burst, "
+		"default 1)\n");
+	fprintf(stderr, "         -v            (increment verbose level for "
+		"printing sent CAN frames)\n\n");
+	fprintf(stderr, "Generation modes:\n");
+	fprintf(stderr, " 'r'     => random values (default)\n");
+	fprintf(stderr, " 'e'     => random values, even ID\n");
+	fprintf(stderr, " 'o'     => random values, odd ID\n");
+	fprintf(stderr, " 'i'     => increment values\n");
+	fprintf(stderr, " <value> => fixed value (in hexadecimal for -I and -D)\n\n");
+	fprintf(stderr, "The gap value (in milliseconds) may have decimal places, e.g. '-g 4.73'\n");
+	fprintf(stderr, "When incrementing the CAN data the data length code "
+		"minimum is set to 1.\n");
+	fprintf(stderr, "CAN IDs and data content are given and expected in hexadecimal values.\n\n");
+	fprintf(stderr, "Examples:\n");
+	fprintf(stderr, "%s vcan0 -g 4 -I 42A -L 1 -D i -v -v\n", prg);
+	fprintf(stderr, "\t(fixed CAN ID and length, inc. data)\n");
+	fprintf(stderr, "%s vcan0 -e -L i -v -v -v\n", prg);
+	fprintf(stderr, "\t(generate EFF frames, incr. length)\n");
+	fprintf(stderr, "%s vcan0 -D 11223344DEADBEEF -L 8\n", prg);
+	fprintf(stderr, "\t(fixed CAN data payload and length)\n");
+	fprintf(stderr, "%s vcan0 -I 555 -D CCCCCCCCCCCCCCCC -L 8 -g 3.75\n", prg);
+	fprintf(stderr, "\t(generate a fix busload without bit-stuffing effects)\n");
+	fprintf(stderr, "%s vcan0 -g 0 -i -x\n", prg);
+	fprintf(stderr, "\t(full load test ignoring -ENOBUFS)\n");
+	fprintf(stderr, "%s vcan0 -g 0 -p 10 -x\n", prg);
+	fprintf(stderr, "\t(full load test with polling, 10ms timeout)\n");
+	fprintf(stderr, "%s vcan0\n", prg);
+	fprintf(stderr, "\t(my favourite default :)\n\n");
+}
+
+void sigterm(int signo)
+{
+	running = 0;
+}
+
+int main(int argc, char **argv)
+{
+	double gap = DEFAULT_GAP;
+	unsigned long burst_count = DEFAULT_BURST_COUNT;
+	unsigned long polltimeout = 0;
+	unsigned char ignore_enobufs = 0;
+	unsigned char extended = 0;
+	unsigned char canfd = 0;
+	unsigned char brs = 0;
+	unsigned char esi = 0;
+	unsigned char mix = 0;
+	unsigned char id_mode = MODE_RANDOM;
+	unsigned char data_mode = MODE_RANDOM;
+	unsigned char dlc_mode = MODE_RANDOM;
+	unsigned char loopback_disable = 0;
+	unsigned char verbose = 0;
+	unsigned char rtr_frame = 0;
+	unsigned char len8_dlc = 0;
+	int count = 0;
+	unsigned long burst_sent_count = 0;
+	int mtu, maxdlen;
+	uint64_t incdata = 0;
+	int incdlc = 0;
+	unsigned long rnd;
+	unsigned char fixdata[CANFD_MAX_DLEN];
+
+	int opt;
+	int s; /* socket */
+	struct pollfd fds;
+
+	struct sockaddr_can addr;
+	static struct canfd_frame frame;
+	struct can_frame *ccf = (struct can_frame *)&frame;
+	int nbytes;
+	int i;
+	struct ifreq ifr;
+
+	struct timespec ts;
+	struct timeval now;
+
+	/* set seed value for pseudo random numbers */
+	gettimeofday(&now, NULL);
+	srandom(now.tv_usec);
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+	signal(SIGINT, sigterm);
+
+	while ((opt = getopt(argc, argv, "ig:ebEfmI:L:D:xp:n:c:vR8h?")) != -1) {
+		switch (opt) {
+
+		case 'i':
+			ignore_enobufs = 1;
+			break;
+
+		case 'g':
+			gap = strtod(optarg, NULL);
+			break;
+
+		case 'e':
+			extended = 1;
+			break;
+
+		case 'f':
+			canfd = 1;
+			break;
+
+		case 'b':
+			brs = 1; /* bitrate switch implies CAN FD */
+			canfd = 1;
+			break;
+
+		case 'E':
+			esi = 1; /* error state indicator implies CAN FD */
+			canfd = 1;
+			break;
+
+		case 'm':
+			mix = 1;
+			canfd = 1; /* to switch the socket into CAN FD mode */
+			break;
+
+		case 'I':
+			if (optarg[0] == 'r') {
+				id_mode = MODE_RANDOM;
+			} else if (optarg[0] == 'i') {
+				id_mode = MODE_INCREMENT;
+			} else if (optarg[0] == 'e') {
+				id_mode = MODE_RANDOM_EVEN;
+			} else if (optarg[0] == 'o') {
+				id_mode = MODE_RANDOM_ODD;
+			} else {
+				id_mode = MODE_FIX;
+				frame.can_id = strtoul(optarg, NULL, 16);
+			}
+			break;
+
+		case 'L':
+			if (optarg[0] == 'r') {
+				dlc_mode = MODE_RANDOM;
+			} else if (optarg[0] == 'i') {
+				dlc_mode = MODE_INCREMENT;
+			} else {
+				dlc_mode = MODE_FIX;
+				frame.len = atoi(optarg) & 0xFF; /* is cut to 8 / 64 later */
+			}
+			break;
+
+		case 'D':
+			if (optarg[0] == 'r') {
+				data_mode = MODE_RANDOM;
+			} else if (optarg[0] == 'i') {
+				data_mode = MODE_INCREMENT;
+			} else {
+				data_mode = MODE_FIX;
+				if (hexstring2data(optarg, fixdata, CANFD_MAX_DLEN)) {
+					printf ("wrong fix data definition\n");
+					return 1;
+				}
+			}
+			break;
+
+		case 'c':
+			burst_count = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'v':
+			verbose++;
+			break;
+
+		case 'x':
+			loopback_disable = 1;
+			break;
+
+		case 'R':
+			rtr_frame = 1;
+			break;
+
+		case '8':
+			len8_dlc = 1;
+			break;
+
+		case 'p':
+			polltimeout = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'n':
+			count = atoi(optarg);
+			if (count < 1) {
+				print_usage(basename(argv[0]));
+				return 1;
+			}
+			break;
+
+		case '?':
+		case 'h':
+		default:
+			print_usage(basename(argv[0]));
+			return 1;
+			break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(basename(argv[0]));
+		return 1;
+	}
+
+	ts.tv_sec = gap / 1000;
+	ts.tv_nsec = (long)(((long long)(gap * 1000000)) % 1000000000LL);
+
+	/* recognize obviously missing commandline option */
+	if (id_mode == MODE_FIX && frame.can_id > 0x7FF && !extended) {
+		printf("The given CAN-ID is greater than 0x7FF and "
+		       "the '-e' option is not set.\n");
+		return 1;
+	}
+
+	if (strlen(argv[optind]) >= IFNAMSIZ) {
+		printf("Name of CAN device '%s' is too long!\n\n", argv[optind]);
+		return 1;
+	}
+
+	if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family = AF_CAN;
+
+	strcpy(ifr.ifr_name, argv[optind]);
+	if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {
+		perror("SIOCGIFINDEX");
+		return 1;
+	}
+	addr.can_ifindex = ifr.ifr_ifindex;
+
+	/* disable default receive filter on this RAW socket */
+	/* This is obsolete as we do not read from the socket at all, but for */
+	/* this reason we can remove the receive list in the Kernel to save a */
+	/* little (really a very little!) CPU usage.                          */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
+
+	if (loopback_disable) {
+		int loopback = 0;
+
+		setsockopt(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK,
+			   &loopback, sizeof(loopback));
+	}
+
+	if (canfd) {
+		int enable_canfd = 1;
+
+		/* check if the frame fits into the CAN netdevice */
+		if (ioctl(s, SIOCGIFMTU, &ifr) < 0) {
+			perror("SIOCGIFMTU");
+			return 1;
+		}
+
+		if (ifr.ifr_mtu != CANFD_MTU) {
+			printf("CAN interface is not CAN FD capable - sorry.\n");
+			return 1;
+		}
+
+		/* interface is ok - try to switch the socket into CAN FD mode */
+		if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &enable_canfd, sizeof(enable_canfd))){
+			printf("error when enabling CAN FD support\n");
+			return 1;
+		}
+
+		/* ensure discrete CAN FD length values 0..8, 12, 16, 20, 24, 32, 64 */
+		frame.len = can_fd_dlc2len(can_fd_len2dlc(frame.len));
+	} else {
+		/* sanitize Classical CAN 2.0 frame length */
+		if (len8_dlc) {
+			if (frame.len > CAN_MAX_RAW_DLC)
+				frame.len = CAN_MAX_RAW_DLC;
+
+			if (frame.len > CAN_MAX_DLEN)
+				ccf->len8_dlc = frame.len;
+		}
+
+		if (frame.len > CAN_MAX_DLEN)
+			frame.len = CAN_MAX_DLEN;
+	}
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	if (polltimeout) {
+		fds.fd = s;
+		fds.events = POLLOUT;
+	}
+
+	while (running) {
+		frame.flags = 0;
+
+		if (count && (--count == 0))
+			running = 0;
+
+		if (canfd){
+			mtu = CANFD_MTU;
+			maxdlen = CANFD_MAX_DLEN;
+			if (brs)
+				frame.flags |= CANFD_BRS;
+			if (esi)
+				frame.flags |= CANFD_ESI;
+		} else {
+			mtu = CAN_MTU;
+			maxdlen = CAN_MAX_DLEN;
+		}
+
+		if (id_mode == MODE_RANDOM)
+			frame.can_id = random();
+		else if (id_mode == MODE_RANDOM_EVEN)
+			frame.can_id = random() & ~0x1;
+		else if (id_mode == MODE_RANDOM_ODD)
+			frame.can_id = random() | 0x1;
+
+		if (extended) {
+			frame.can_id &= CAN_EFF_MASK;
+			frame.can_id |= CAN_EFF_FLAG;
+		} else
+			frame.can_id &= CAN_SFF_MASK;
+
+		if (rtr_frame && !canfd)
+			frame.can_id |= CAN_RTR_FLAG;
+
+		if (dlc_mode == MODE_RANDOM) {
+
+			if (canfd)
+				frame.len = can_fd_dlc2len(random() & 0xF);
+			else {
+				frame.len = random() & 0xF;
+
+				if (frame.len > CAN_MAX_DLEN) {
+					/* generate Classic CAN len8 DLCs? */
+					if (len8_dlc)
+						ccf->len8_dlc = frame.len;
+
+					frame.len = 8; /* for about 50% of the frames */
+				} else {
+					ccf->len8_dlc = 0;
+				}
+			}
+		}
+
+		if (data_mode == MODE_INCREMENT && !frame.len)
+			frame.len = 1; /* min dlc value for incr. data */
+
+		if (data_mode == MODE_RANDOM) {
+
+			rnd = random();
+			memcpy(&frame.data[0], &rnd, 4);
+			rnd = random();
+			memcpy(&frame.data[4], &rnd, 4);
+
+			/* omit extra random number generation for CAN FD */
+			if (canfd && frame.len > 8) {
+				memcpy(&frame.data[8], &frame.data[0], 8);
+				memcpy(&frame.data[16], &frame.data[0], 16);
+				memcpy(&frame.data[32], &frame.data[0], 32);
+			}
+		}
+
+		if (data_mode == MODE_FIX)
+			memcpy(frame.data, fixdata, CANFD_MAX_DLEN);
+
+		/* set unused payload data to zero like the CAN driver does it on rx */
+		if (frame.len < maxdlen)
+			memset(&frame.data[frame.len], 0, maxdlen - frame.len);
+
+		if (verbose) {
+
+			printf("  %s  ", argv[optind]);
+
+			if (verbose > 1)
+				fprint_long_canframe(stdout, &frame, "\n", (verbose > 2)?1:0, maxdlen);
+			else
+				fprint_canframe(stdout, &frame, "\n", 1, maxdlen);
+		}
+
+resend:
+		nbytes = write(s, &frame, mtu);
+		if (nbytes < 0) {
+			if (errno != ENOBUFS) {
+				perror("write");
+				return 1;
+			}
+			if (!ignore_enobufs && !polltimeout) {
+				perror("write");
+				return 1;
+			}
+			if (polltimeout) {
+				int ret;
+
+				/* wait for the write socket (with timeout) */
+				ret = poll(&fds, 1, polltimeout);
+				if (ret == 0 || (ret == -1 && errno != -EINTR)) {
+					perror("poll");
+					return 1;
+				}
+				goto resend;
+			} else
+				enobufs_count++;
+
+		} else if (nbytes < mtu) {
+			fprintf(stderr, "write: incomplete CAN frame\n");
+			return 1;
+		}
+
+		burst_sent_count++;
+		if (gap && burst_sent_count >= burst_count) /* gap == 0 => performance test :-] */
+			if (nanosleep(&ts, NULL))
+				return 1;
+
+		if (burst_sent_count >= burst_count)
+			burst_sent_count = 0;
+
+		if (id_mode == MODE_INCREMENT)
+			frame.can_id++;
+
+		if (dlc_mode == MODE_INCREMENT) {
+
+			incdlc++;
+			incdlc %= CAN_MAX_RAW_DLC + 1;
+
+			if (canfd && !mix)
+				frame.len = can_fd_dlc2len(incdlc);
+			else if (len8_dlc) {
+				if (incdlc > CAN_MAX_DLEN) {
+					frame.len = CAN_MAX_DLEN;
+					ccf->len8_dlc = incdlc;
+				} else {
+					frame.len = incdlc;
+					ccf->len8_dlc = 0;
+				}
+			} else {
+				incdlc %= CAN_MAX_DLEN + 1;
+				frame.len = incdlc;
+			}
+		}
+
+		if (data_mode == MODE_INCREMENT) {
+
+			incdata++;
+
+			for (i=0; i<8 ;i++)
+				frame.data[i] = (incdata >> i*8) & 0xFFULL;
+		}
+
+		if (mix) {
+			i = random();
+			extended = i&1;
+			canfd = i&2;
+			if (canfd) {
+				brs = i&4;
+				esi = i&8;
+			}
+			rtr_frame = ((i&24) == 24); /* reduce RTR frames to 1/4 */
+		}
+	}
+
+	if (enobufs_count)
+		printf("\nCounted %llu ENOBUFS return values on write().\n\n",
+		       enobufs_count);
+
+	close(s);
+
+	return 0;
+}
diff --git a/canutils/cangw.c b/canutils/cangw.c
new file mode 100644
index 0000000000..f7a6678f47
--- /dev/null
+++ b/canutils/cangw.c
@@ -0,0 +1,1030 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * cangw.c - manage PF_CAN netlink gateway
+ *
+ * Copyright (c) 2010 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <errno.h>
+#include <libgen.h>
+#include <linux/can/gw.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <net/if.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+enum {
+	UNSPEC,
+	ADD,
+	DEL,
+	FLUSH,
+	LIST
+};
+
+struct modattr {
+	struct can_frame cf;
+	__u8 modtype;
+	__u8 instruction;
+} __attribute__((packed));
+
+struct fdmodattr {
+	struct canfd_frame cf;
+	__u8 modtype;
+	__u8 instruction;
+} __attribute__((packed));
+
+
+#define RTCAN_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtcanmsg))))
+#define RTCAN_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtcanmsg))
+
+/* some netlink helpers stolen from iproute2 package */
+#define NLMSG_TAIL(nmsg) \
+        ((struct rtattr *)(((char *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
+
+int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
+	      int alen)
+{
+	int len = RTA_LENGTH(alen);
+	struct rtattr *rta;
+
+	if ((int)(NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len)) > maxlen) {
+		fprintf(stderr, "addattr_l: message exceeded bound of %d\n",
+			maxlen);
+		return -1;
+	}
+	rta = NLMSG_TAIL(n);
+	rta->rta_type = type;
+	rta->rta_len = len;
+	memcpy(RTA_DATA(rta), data, alen);
+	n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
+	return 0;
+}
+
+void printfilter(const void *data)
+{
+	struct can_filter *filter = (struct can_filter *)data;
+
+	if (filter->can_id & CAN_INV_FILTER)
+		printf("-f %03X~%X ", (filter->can_id & ~CAN_INV_FILTER), filter->can_mask);
+	else
+		printf("-f %03X:%X ", filter->can_id, filter->can_mask);
+}
+
+void printmod(const char *type, const void *data)
+{
+	struct modattr mod;
+	int i;
+
+	memcpy (&mod, data, CGW_MODATTR_LEN);
+
+	printf("-m %s:", type);
+
+	if (mod.modtype & CGW_MOD_ID)
+		printf("I");
+
+	if (mod.modtype & CGW_MOD_DLC)
+		printf("L");
+
+	if (mod.modtype & CGW_MOD_DATA)
+		printf("D");
+
+	printf(":%03X.%X.", mod.cf.can_id, mod.cf.can_dlc);
+
+	for (i = 0; i < CAN_MAX_DLEN; i++)
+		printf("%02X", mod.cf.data[i]);
+
+	printf(" ");
+}
+
+void printfdmod(const char *type, const void *data)
+{
+	struct fdmodattr mod;
+	int i;
+
+	memcpy (&mod, data, CGW_FDMODATTR_LEN);
+
+	printf("-M %s:", type);
+
+	if (mod.modtype & CGW_MOD_ID)
+		printf("I");
+
+	if (mod.modtype & CGW_MOD_FLAGS)
+		printf("F");
+
+	if (mod.modtype & CGW_MOD_LEN)
+		printf("L");
+
+	if (mod.modtype & CGW_MOD_DATA)
+		printf("D");
+
+	printf(":%03X.%X.%X.", mod.cf.can_id, mod.cf.flags, mod.cf.len);
+
+	for (i = 0; i < CANFD_MAX_DLEN; i++)
+		printf("%02X", mod.cf.data[i]);
+
+	printf(" ");
+}
+
+void print_cs_xor(struct cgw_csum_xor *cs_xor)
+{
+	printf("-x %d:%d:%d:%02X ",
+	       cs_xor->from_idx, cs_xor->to_idx,
+	       cs_xor->result_idx, cs_xor->init_xor_val);
+}
+
+void print_cs_crc8_profile(struct cgw_csum_crc8 *cs_crc8)
+{
+	int i;
+
+	printf("-p %d:", cs_crc8->profile);
+
+	switch (cs_crc8->profile) {
+
+	case  CGW_CRC8PRF_1U8:
+
+		printf("%02X", cs_crc8->profile_data[0]);
+		break;
+
+	case  CGW_CRC8PRF_16U8:
+
+		for (i = 0; i < 16; i++)
+			printf("%02X", cs_crc8->profile_data[i]);
+		break;
+
+	case  CGW_CRC8PRF_SFFID_XOR:
+		break;
+
+	default:
+		printf("<unknown profile #%d>", cs_crc8->profile);
+	}
+
+	printf(" ");
+}
+
+void print_cs_crc8(struct cgw_csum_crc8 *cs_crc8)
+{
+	int i;
+
+	printf("-c %d:%d:%d:%02X:%02X:",
+	       cs_crc8->from_idx, cs_crc8->to_idx,
+	       cs_crc8->result_idx, cs_crc8->init_crc_val,
+	       cs_crc8->final_xor_val);
+
+	for (i = 0; i < 256; i++)
+		printf("%02X", cs_crc8->crctab[i]);
+
+	printf(" ");
+
+	if (cs_crc8->profile != CGW_CRC8PRF_UNSPEC)
+		print_cs_crc8_profile(cs_crc8);
+}
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - manage PF_CAN netlink gateway.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options]\n\n", prg);
+	fprintf(stderr, "Commands:\n");
+	fprintf(stderr, "          -A  (add a new rule)\n");
+	fprintf(stderr, "          -D  (delete a rule)\n");
+	fprintf(stderr, "          -F  (flush / delete all rules)\n");
+	fprintf(stderr, "          -L  (list all rules)\n");
+	fprintf(stderr, "Mandatory:\n");
+	fprintf(stderr, "          -s <src_dev>  (source netdevice)\n");
+	fprintf(stderr, "          -d <dst_dev>  (destination netdevice)\n");
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "          -X  (this is a CAN FD rule)\n");
+	fprintf(stderr, "          -t  (preserve src_dev rx timestamp)\n");
+	fprintf(stderr, "          -e  (echo sent frames - recommended on vcanx)\n");
+	fprintf(stderr, "          -i  (allow to route to incoming interface)\n");
+	fprintf(stderr, "          -u <uid>  (user defined modification identifier)\n");
+	fprintf(stderr, "          -l <hops>  (limit the number of frame hops / routings)\n");
+	fprintf(stderr, "          -f <filter>  (set CAN filter)\n");
+	fprintf(stderr, "          -m <mod>  (set Classical CAN frame modifications)\n");
+	fprintf(stderr, "          -M <MOD>  (set CAN FD frame modifications)\n");
+	fprintf(stderr, "          -x <from_idx>:<to_idx>:<result_idx>:<init_xor_val>  (XOR checksum)\n");
+	fprintf(stderr, "          -c <from>:<to>:<result>:<init_val>:<xor_val>:<crctab[256]>  (CRC8 cs)\n");
+	fprintf(stderr, "          -p <profile>:[<profile_data>]  (CRC8 checksum profile & parameters)\n");
+	fprintf(stderr, "\nValues are given and expected in hexadecimal values. Leading 0s can be omitted.\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "<filter> is a <value><mask> CAN identifier filter:\n");
+	fprintf(stderr, "  <can_id>:<can_mask>  (matches when <received_can_id> & mask == can_id & mask)\n");
+	fprintf(stderr, "  <can_id>~<can_mask>  (matches when <received_can_id> & mask != can_id & mask)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "<mod> is a Classical CAN frame modification instruction consisting of\n");
+	fprintf(stderr, "<instruction>:<can_frame-elements>:<can_id>.<can_dlc>.<can_data>\n");
+	fprintf(stderr, "  <instruction>  is one of 'AND' 'OR' 'XOR' 'SET'\n");
+	fprintf(stderr, "  <can_frame-elements>  is _one_ or _more_ of 'I'dentifier 'L'ength 'D'ata\n");
+	fprintf(stderr, "  <can_id>  is an u32 value containing the CAN Identifier\n");
+	fprintf(stderr, "  <can_dlc>  is an u8 value containing the data length code in hex (0 .. F)\n");
+	fprintf(stderr, "  <can_data>  is always eight(!) u8 values containing the CAN frames data\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "<MOD> is a CAN FD frame modification instruction consisting of\n");
+	fprintf(stderr, "<instruction>:<canfd_frame-elements>:<can_id>.<flags>.<len>.<can_data>\n");
+	fprintf(stderr, "  <instruction>  is one of 'AND' 'OR' 'XOR' 'SET'\n");
+	fprintf(stderr, "  <canfd_frame-elements>  is _one_ or _more_ of 'I'd 'F'lags 'L'ength 'D'ata\n");
+	fprintf(stderr, "  <can_id>  is an u32 value containing the CAN FD Identifier\n");
+	fprintf(stderr, "  <flags>  is an u8 value containing CAN FD flags (CANFD_BRS, CANFD_ESI)\n");
+	fprintf(stderr, "  <len>  is an u8 value containing the data length in hex (0 .. 40)\n");
+	fprintf(stderr, "  <can_data>  is always 64(!) u8 values containing the CAN FD frames data\n");
+	fprintf(stderr, "The max. four modifications are performed in the order AND -> OR -> XOR -> SET\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Supported CRC 8 profiles:\n");
+	fprintf(stderr, " Profile '%d' (1U8)        add one additional u8 value\n", CGW_CRC8PRF_1U8);
+	fprintf(stderr, " Profile '%d' (16U8)       add u8 value from table[16] indexed by (data[1] & 0xF)\n", CGW_CRC8PRF_16U8);
+	fprintf(stderr, " Profile '%d' (SFFID_XOR)  add u8 value (can_id & 0xFF) ^ (can_id >> 8 & 0xFF)\n", CGW_CRC8PRF_SFFID_XOR);
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Examples:\n");
+	fprintf(stderr, "%s -A -s can0 -d vcan3 -e -f 123:C00007FF -m SET:IL:333.4.1122334455667788\n", prg);
+	fprintf(stderr, "\n");
+}
+
+int b64hex(char *asc, unsigned char *bin, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (!sscanf(asc+(i*2), "%2hhx", bin+i))
+			return 1;	
+	}
+	return 0;
+}
+
+int parse_crc8_profile(char *optarg, struct cgw_csum_crc8 *crc8)
+{
+	int ret = 1;
+	char *ptr;
+
+	if (sscanf(optarg, "%hhu:", &crc8->profile) != 1)
+		return ret;
+
+	switch (crc8->profile) {
+
+	case  CGW_CRC8PRF_1U8:
+
+		if (sscanf(optarg, "%hhu:%2hhx", &crc8->profile, &crc8->profile_data[0]) == 2)
+			ret = 0;
+
+		break;
+
+	case  CGW_CRC8PRF_16U8:
+
+		ptr = strchr(optarg, ':');
+
+		/* check if length contains 16 base64 hex values */
+		if (ptr != NULL &&
+		    strlen(ptr) == strlen(":00112233445566778899AABBCCDDEEFF") &&
+		    b64hex(ptr+1, (unsigned char *)&crc8->profile_data[0], 16) == 0)
+			ret = 0;
+
+		break;
+
+	case  CGW_CRC8PRF_SFFID_XOR:
+
+		/* no additional parameters needed */
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+int parse_mod(char *optarg, struct modattr *modmsg)
+{
+	char *ptr, *nptr;
+	char hexdata[(CAN_MAX_DLEN * 2) + 1] = {0};
+	canid_t can_id;
+
+	ptr = optarg;
+	nptr = strchr(ptr, ':');
+
+	if ((nptr - ptr > 3) || (nptr - ptr == 0))
+		return 1;
+
+	if (!strncmp(ptr, "AND", 3))
+		modmsg->instruction = CGW_MOD_AND;
+	else if (!strncmp(ptr, "OR", 2))
+		modmsg->instruction = CGW_MOD_OR;
+	else if (!strncmp(ptr, "XOR", 3))
+		modmsg->instruction = CGW_MOD_XOR;
+	else if (!strncmp(ptr, "SET", 3))
+		modmsg->instruction = CGW_MOD_SET;
+	else
+		return 2;
+
+	ptr = nptr+1;
+	nptr = strchr(ptr, ':');
+
+	if ((nptr - ptr > 3) || (nptr - ptr == 0))
+		return 3;
+
+	modmsg->modtype = 0;
+
+	while (*ptr != ':') {
+
+		switch (*ptr) {
+
+		case 'I':
+			modmsg->modtype |= CGW_MOD_ID;
+			break;
+
+		case 'L':
+			modmsg->modtype |= CGW_MOD_DLC;
+			break;
+
+		case 'D':
+			modmsg->modtype |= CGW_MOD_DATA;
+			break;
+
+		default:
+			return 4;
+		}
+		ptr++;
+	}
+
+	if (sscanf(++ptr, "%x.%hhx.%16s", &can_id,
+		   (unsigned char *)&modmsg->cf.can_dlc, hexdata) != 3)
+		return 5;
+
+	modmsg->cf.can_id = can_id;
+
+	if (strlen(hexdata) != (CAN_MAX_DLEN * 2))
+		return 6;
+
+	if (b64hex(hexdata, &modmsg->cf.data[0], CAN_MAX_DLEN))
+		return 7;
+
+	return 0; /* ok */
+}
+
+int parse_fdmod(char *optarg, struct fdmodattr *modmsg)
+{
+	char *ptr, *nptr;
+	char hexdata[(CANFD_MAX_DLEN * 2) + 1] = {0};
+	canid_t can_id;
+
+	ptr = optarg;
+	nptr = strchr(ptr, ':');
+
+	if ((nptr - ptr > 3) || (nptr - ptr == 0))
+		return 1;
+
+	if (!strncmp(ptr, "AND", 3))
+		modmsg->instruction = CGW_FDMOD_AND;
+	else if (!strncmp(ptr, "OR", 2))
+		modmsg->instruction = CGW_FDMOD_OR;
+	else if (!strncmp(ptr, "XOR", 3))
+		modmsg->instruction = CGW_FDMOD_XOR;
+	else if (!strncmp(ptr, "SET", 3))
+		modmsg->instruction = CGW_FDMOD_SET;
+	else
+		return 2;
+
+	ptr = nptr+1;
+	nptr = strchr(ptr, ':');
+
+	if ((nptr - ptr > 4) || (nptr - ptr == 0))
+		return 3;
+
+	modmsg->modtype = 0;
+
+	while (*ptr != ':') {
+
+		switch (*ptr) {
+
+		case 'I':
+			modmsg->modtype |= CGW_MOD_ID;
+			break;
+
+		case 'F':
+			modmsg->modtype |= CGW_MOD_FLAGS;
+			break;
+
+		case 'L':
+			modmsg->modtype |= CGW_MOD_LEN;
+			break;
+
+		case 'D':
+			modmsg->modtype |= CGW_MOD_DATA;
+			break;
+
+		default:
+			return 4;
+		}
+		ptr++;
+	}
+
+	if (sscanf(++ptr, "%x.%hhx.%hhx.%128s", &can_id,
+		   (unsigned char *)&modmsg->cf.flags,
+		   (unsigned char *)&modmsg->cf.len, hexdata) != 4)
+		return 5;
+
+	modmsg->cf.can_id = can_id;
+
+	if (strlen(hexdata) != (CANFD_MAX_DLEN * 2))
+		return 6;
+
+	if (b64hex(hexdata, &modmsg->cf.data[0], CANFD_MAX_DLEN))
+		return 7;
+
+	return 0; /* ok */
+}
+
+int parse_rtlist(char *prgname, unsigned char *rxbuf, int len)
+{
+	char ifname[IF_NAMESIZE]; /* interface name for if_indextoname() */
+	struct rtcanmsg *rtc;
+	struct rtattr *rta;
+	struct nlmsghdr *nlh;
+	unsigned int src_ifindex = 0;
+	unsigned int dst_ifindex = 0;
+	__u32 handled, dropped, deleted;
+	int rtlen;
+
+
+	nlh = (struct nlmsghdr *)rxbuf;
+
+	while (1) {
+		if (!NLMSG_OK(nlh, len))
+			return 0;
+
+		if (nlh->nlmsg_type == NLMSG_ERROR) {
+			printf("NLMSG_ERROR\n");
+			return 1;
+		}
+
+		if (nlh->nlmsg_type == NLMSG_DONE) {
+			//printf("NLMSG_DONE\n");
+			return 1;
+		}
+
+		rtc = (struct rtcanmsg *)NLMSG_DATA(nlh);
+		if (rtc->can_family != AF_CAN) {
+			printf("received msg from unknown family %d\n", rtc->can_family);
+			return -EINVAL;
+		}
+
+		if (rtc->gwtype != CGW_TYPE_CAN_CAN) {
+			printf("received msg with unknown gwtype %d\n", rtc->gwtype);
+			return -EINVAL;
+		}
+
+		/*
+		 * print list in a representation that
+		 * can be used directly for start scripts.
+		 *
+		 * To order the mandatory and optional parameters in the
+		 * output string, the NLMSG is parsed twice.
+		 */
+
+		handled = 0;
+		dropped = 0;
+		deleted = 0;
+		src_ifindex = 0;
+		dst_ifindex = 0;
+
+		printf("%s -A ", basename(prgname));
+
+		/* first parse for mandatory options */
+		rta = (struct rtattr *) RTCAN_RTA(rtc);
+		rtlen = RTCAN_PAYLOAD(nlh);
+		for(;RTA_OK(rta, rtlen);rta=RTA_NEXT(rta,rtlen))
+		{
+			//printf("(A-%d)", rta->rta_type);
+			switch(rta->rta_type) {
+
+			case CGW_FILTER:
+			case CGW_MOD_AND:
+			case CGW_MOD_OR:
+			case CGW_MOD_XOR:
+			case CGW_MOD_SET:
+			case CGW_FDMOD_AND:
+			case CGW_FDMOD_OR:
+			case CGW_FDMOD_XOR:
+			case CGW_FDMOD_SET:
+			case CGW_MOD_UID:
+			case CGW_LIM_HOPS:
+			case CGW_CS_XOR:
+			case CGW_CS_CRC8:
+				break;
+
+			case CGW_SRC_IF:
+				src_ifindex = *(__u32 *)RTA_DATA(rta);
+				break;
+
+			case CGW_DST_IF:
+				dst_ifindex = *(__u32 *)RTA_DATA(rta);
+				break;
+
+			case CGW_HANDLED:
+				handled = *(__u32 *)RTA_DATA(rta);
+				break;
+
+			case CGW_DROPPED:
+				dropped = *(__u32 *)RTA_DATA(rta);
+				break;
+
+			case CGW_DELETED:
+				deleted = *(__u32 *)RTA_DATA(rta);
+				break;
+
+			default:
+				printf("Unknown attribute %d!", rta->rta_type);
+				return -EINVAL;
+				break;
+			}
+		}
+
+
+		printf("-s %s ", if_indextoname(src_ifindex, ifname));
+		printf("-d %s ", if_indextoname(dst_ifindex, ifname));
+
+		if (rtc->flags & CGW_FLAGS_CAN_FD)
+			printf("-X ");
+
+		if (rtc->flags & CGW_FLAGS_CAN_ECHO)
+			printf("-e ");
+
+		if (rtc->flags & CGW_FLAGS_CAN_SRC_TSTAMP)
+			printf("-t ");
+
+		if (rtc->flags & CGW_FLAGS_CAN_IIF_TX_OK)
+			printf("-i ");
+
+		/* second parse for mod attributes */
+		rta = (struct rtattr *) RTCAN_RTA(rtc);
+		rtlen = RTCAN_PAYLOAD(nlh);
+		for(;RTA_OK(rta, rtlen);rta=RTA_NEXT(rta,rtlen))
+		{
+			//printf("(B-%d)", rta->rta_type);
+			switch(rta->rta_type) {
+
+			case CGW_FILTER:
+				printfilter(RTA_DATA(rta));
+				break;
+
+			case CGW_MOD_AND:
+				printmod("AND", RTA_DATA(rta));
+				break;
+
+			case CGW_MOD_OR:
+				printmod("OR", RTA_DATA(rta));
+				break;
+
+			case CGW_MOD_XOR:
+				printmod("XOR", RTA_DATA(rta));
+				break;
+
+			case CGW_MOD_SET:
+				printmod("SET", RTA_DATA(rta));
+				break;
+
+			case CGW_FDMOD_AND:
+				printfdmod("AND", RTA_DATA(rta));
+				break;
+
+			case CGW_FDMOD_OR:
+				printfdmod("OR", RTA_DATA(rta));
+				break;
+
+			case CGW_FDMOD_XOR:
+				printfdmod("XOR", RTA_DATA(rta));
+				break;
+
+			case CGW_FDMOD_SET:
+				printfdmod("SET", RTA_DATA(rta));
+				break;
+
+			case CGW_MOD_UID:
+				printf("-u %X ", *(__u32 *)RTA_DATA(rta));
+				break;
+
+			case CGW_LIM_HOPS:
+				printf("-l %d ", *(__u8 *)RTA_DATA(rta));
+				break;
+
+			case CGW_CS_XOR:
+				print_cs_xor((struct cgw_csum_xor *)RTA_DATA(rta));
+				break;
+
+			case CGW_CS_CRC8:
+				print_cs_crc8((struct cgw_csum_crc8 *)RTA_DATA(rta));
+				break;
+
+			case CGW_SRC_IF:
+			case CGW_DST_IF:
+			case CGW_HANDLED:
+			case CGW_DROPPED:
+			case CGW_DELETED:
+				break;
+
+			default:
+				printf("Unknown attribute %d!", rta->rta_type);
+				return -EINVAL;
+				break;
+			}
+		}
+
+		/* end of entry */
+		printf("# %d handled %d dropped %d deleted\n",
+		       handled, dropped, deleted);
+
+		/* jump to next NLMSG in the given buffer */
+		nlh = NLMSG_NEXT(nlh, len);
+	}
+}
+
+int main(int argc, char **argv)
+{
+	int s;
+	int err = 0;
+
+	int opt;
+	extern int optind, opterr, optopt;
+
+	int cmd = UNSPEC;
+	int have_filter = 0;
+	int have_cs_xor = 0;
+	int have_cs_crc8 = 0;
+
+	struct {
+		struct nlmsghdr nh;
+		struct rtcanmsg rtcan;
+		char buf[1500];
+	} req;
+
+	unsigned char rxbuf[8192]; /* netlink receive buffer */
+	struct nlmsghdr *nlh;
+	struct nlmsgerr *rte;
+	unsigned int src_ifindex = 0;
+	unsigned int dst_ifindex = 0;
+	__u32 uid = 0;
+	__u8 limit_hops = 0;
+	__u16 flags = 0;
+	int len;
+
+	struct can_filter filter;
+	struct sockaddr_nl nladdr;
+
+	struct cgw_csum_xor cs_xor = { 0 };
+	struct cgw_csum_crc8 cs_crc8 = { 0 };
+	char crc8tab[513] = {0};
+
+	struct modattr modmsg[CGW_MOD_FUNCS];
+	struct fdmodattr fdmodmsg[CGW_MOD_FUNCS];
+	int modidx = 0;
+	int fdmodidx = 0;
+	int i;
+
+	memset(&req, 0, sizeof(req));
+
+	while ((opt = getopt(argc, argv, "ADFLs:d:Xteiu:l:f:c:p:x:m:M:?")) != -1) {
+		switch (opt) {
+
+		case 'A':
+			if (cmd == UNSPEC)
+				cmd = ADD;
+			break;
+
+		case 'D':
+			if (cmd == UNSPEC)
+				cmd = DEL;
+			break;
+
+		case 'F':
+			if (cmd == UNSPEC)
+				cmd = FLUSH;
+			break;
+
+		case 'L':
+			if (cmd == UNSPEC)
+				cmd = LIST;
+			break;
+
+		case 's':
+			src_ifindex = if_nametoindex(optarg);
+			if (!src_ifindex) {
+				perror("src if_nametoindex");
+				exit(1);
+			}
+			break;
+
+		case 'd':
+			dst_ifindex = if_nametoindex(optarg);
+			if (!dst_ifindex) {
+				perror("dst if_nametoindex");
+				exit(1);
+			}
+			break;
+
+		case 'X':
+			flags |= CGW_FLAGS_CAN_FD;
+			break;
+
+		case 't':
+			flags |= CGW_FLAGS_CAN_SRC_TSTAMP;
+			break;
+
+		case 'e':
+			flags |= CGW_FLAGS_CAN_ECHO;
+			break;
+
+		case 'i':
+			flags |= CGW_FLAGS_CAN_IIF_TX_OK;
+			break;
+
+		case 'u':
+			uid = strtoul(optarg, NULL, 16);
+			break;
+
+		case 'l':
+			if (sscanf(optarg, "%hhu", &limit_hops) != 1 || !(limit_hops)) {
+				printf("Bad hop limit definition '%s'.\n", optarg);
+				exit(1);
+			}
+			break;
+
+		case 'f':
+			if (sscanf(optarg, "%x:%x", &filter.can_id,
+				   &filter.can_mask) == 2) {
+				have_filter = 1;
+			} else if (sscanf(optarg, "%x~%x", &filter.can_id,
+					  &filter.can_mask) == 2) {
+				filter.can_id |= CAN_INV_FILTER;
+				have_filter = 1;
+			} else {
+				printf("Bad filter definition '%s'.\n", optarg);
+				exit(1);
+			}
+			break;
+
+		case 'x':
+			if (sscanf(optarg, "%hhd:%hhd:%hhd:%hhx",
+				   &cs_xor.from_idx, &cs_xor.to_idx,
+				   &cs_xor.result_idx, &cs_xor.init_xor_val) == 4) {
+				have_cs_xor = 1;
+			} else {
+				printf("Bad XOR checksum definition '%s'.\n", optarg);
+				exit(1);
+			}
+			break;
+
+		case 'c':
+			if ((sscanf(optarg, "%hhd:%hhd:%hhd:%hhx:%hhx:%512s",
+				    &cs_crc8.from_idx, &cs_crc8.to_idx,
+				    &cs_crc8.result_idx, &cs_crc8.init_crc_val,
+				    &cs_crc8.final_xor_val, crc8tab) == 6) &&
+			    (strlen(crc8tab) == 512) &&
+			    (b64hex(crc8tab, (unsigned char *)&cs_crc8.crctab, 256) == 0)) {
+				have_cs_crc8 = 1;
+			} else {
+				printf("Bad CRC8 checksum definition '%s'.\n", optarg);
+				exit(1);
+			}
+			break;
+
+		case 'p':
+			if (parse_crc8_profile(optarg, &cs_crc8)) {
+				printf("Bad CRC8 profile definition '%s'.\n", optarg);
+				exit(1);
+			}
+			break;
+
+		case 'm':
+			/* may be triggered by each of the CGW_MOD_FUNCS functions */
+			if ((modidx < CGW_MOD_FUNCS) && (err = parse_mod(optarg, &modmsg[modidx++]))) {
+				printf("Problem %d with modification definition '%s'.\n", err, optarg);
+				exit(1);
+			}
+			break;
+
+		case 'M':
+			/* may be triggered by each of the CGW_FDMOD_FUNCS functions */
+			if ((fdmodidx < CGW_MOD_FUNCS) && (err = parse_fdmod(optarg, &fdmodmsg[fdmodidx++]))) {
+				printf("Problem %d with modification definition '%s'.\n", err, optarg);
+				exit(1);
+			}
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(0);
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			exit(1);
+			break;
+		}
+	}
+
+	if ((argc - optind != 0) || (cmd == UNSPEC)) {
+		print_usage(basename(argv[0]));
+		exit(1);
+	}
+
+	if ((cmd == ADD || cmd == DEL) &&
+	    ((!src_ifindex) || (!dst_ifindex))) {
+		print_usage(basename(argv[0]));
+		exit(1);
+	}
+
+	if (flags & CGW_FLAGS_CAN_FD) {
+		if (modidx) {
+			printf("No -m modifications allowed in CAN FD mode!\n");
+			exit(1);
+		}
+	} else {
+		if (fdmodidx) {
+			printf("No -M modifications allowed in Classic CAN mode!\n");
+			exit(1);
+		}
+	}
+
+	if ((!modidx && !fdmodidx) && (have_cs_crc8 || have_cs_xor)) {
+		printf("-c or -x can only be used in conjunction with -m/-M\n");
+		exit(1);
+	}
+
+	s = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+
+	switch (cmd) {
+
+	case ADD:
+		req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+		req.nh.nlmsg_type  = RTM_NEWROUTE;
+		break;
+
+	case DEL:
+		req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+		req.nh.nlmsg_type  = RTM_DELROUTE;
+		break;
+
+	case FLUSH:
+		req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+		req.nh.nlmsg_type  = RTM_DELROUTE;
+		/* if_index set to 0 => remove all entries */
+		src_ifindex  = 0;
+		dst_ifindex  = 0;
+		break;
+
+	case LIST:
+		req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
+		req.nh.nlmsg_type  = RTM_GETROUTE;
+		break;
+
+	default:
+		printf("This function is not yet implemented.\n");
+		exit(1);
+		break;
+	}
+
+	req.nh.nlmsg_len   = NLMSG_LENGTH(sizeof(struct rtcanmsg));
+	req.nh.nlmsg_seq   = 0;
+
+	req.rtcan.can_family  = AF_CAN;
+	req.rtcan.gwtype = CGW_TYPE_CAN_CAN;
+	req.rtcan.flags = flags;
+
+	addattr_l(&req.nh, sizeof(req), CGW_SRC_IF, &src_ifindex, sizeof(src_ifindex));
+	addattr_l(&req.nh, sizeof(req), CGW_DST_IF, &dst_ifindex, sizeof(dst_ifindex));
+
+	/* add new attributes here */
+
+	if (have_filter)
+		addattr_l(&req.nh, sizeof(req), CGW_FILTER, &filter, sizeof(filter));
+
+	if (have_cs_crc8)
+		addattr_l(&req.nh, sizeof(req), CGW_CS_CRC8, &cs_crc8, sizeof(cs_crc8));
+
+	if (have_cs_xor)
+		addattr_l(&req.nh, sizeof(req), CGW_CS_XOR, &cs_xor, sizeof(cs_xor));
+
+	if (uid)
+		addattr_l(&req.nh, sizeof(req), CGW_MOD_UID, &uid, sizeof(__u32));
+
+	if (limit_hops)
+		addattr_l(&req.nh, sizeof(req), CGW_LIM_HOPS, &limit_hops, sizeof(__u8));
+
+	/*
+	 * a better example code
+	 * modmsg.modtype = CGW_MOD_ID;
+	 * addattr_l(&req.n, sizeof(req), CGW_MOD_SET, &modmsg, CGW_MODATTR_LEN);
+	 */
+
+	/* add up to CGW_MOD_FUNCS modification definitions */
+	for (i = 0; i < modidx; i++)
+		addattr_l(&req.nh, sizeof(req), modmsg[i].instruction, &modmsg[i], CGW_MODATTR_LEN);
+
+	/* add up to CGW_FDMOD_FUNCS modification definitions */
+	for (i = 0; i < fdmodidx; i++)
+		addattr_l(&req.nh, sizeof(req), fdmodmsg[i].instruction, &fdmodmsg[i], CGW_FDMODATTR_LEN);
+
+	memset(&nladdr, 0, sizeof(nladdr));
+	nladdr.nl_family = AF_NETLINK;
+	nladdr.nl_pid    = 0;
+	nladdr.nl_groups = 0;
+
+	err = sendto(s, &req, req.nh.nlmsg_len, 0,
+		     (struct sockaddr*)&nladdr, sizeof(nladdr));
+	if (err < 0) {
+		perror("netlink sendto");
+		return err;
+	}
+
+	/* clean netlink receive buffer */
+	memset(rxbuf, 0x0, sizeof(rxbuf));
+
+	if (cmd != LIST) {
+
+		/*
+		 * cmd == ADD || cmd == DEL || cmd == FLUSH
+		 *
+		 * Parse the requested netlink acknowledge return values.
+		 */
+
+		err = recv(s, &rxbuf, sizeof(rxbuf), 0);
+		if (err < 0) {
+			perror("netlink recv");
+			return err;
+		}
+		nlh = (struct nlmsghdr *)rxbuf;
+		if (nlh->nlmsg_type != NLMSG_ERROR) {
+			fprintf(stderr, "unexpected netlink answer of type %d\n", nlh->nlmsg_type);
+			return -EINVAL;
+		}
+		rte = (struct nlmsgerr *)NLMSG_DATA(nlh);
+		err = rte->error;
+		if (err < 0)
+			fprintf(stderr, "netlink error %d (%s)\n", err, strerror(abs(err)));
+
+	} else {
+
+		/* cmd == LIST */
+
+		while (1) {
+			len = recv(s, &rxbuf, sizeof(rxbuf), 0);
+			if (len < 0) {
+				perror("netlink recv");
+				return len;
+			}
+#if 0
+			printf("received msg len %d\n", len);
+
+			for (i = 0; i < len; i++)
+				printf("%02X ", rxbuf[i]);
+
+			printf("\n");
+#endif
+			/* leave on errors or NLMSG_DONE */
+			if (parse_rtlist(argv[0], rxbuf, len))
+				break;
+		}
+	}
+
+	close(s);
+
+	return err;
+}
+
diff --git a/canutils/canlogserver.c b/canutils/canlogserver.c
new file mode 100644
index 0000000000..6425ca4219
--- /dev/null
+++ b/canutils/canlogserver.c
@@ -0,0 +1,441 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * canlogserver.c
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <ctype.h>
+#include <libgen.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/wait.h>
+
+#include <errno.h>
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <linux/sockios.h>
+#include <signal.h>
+
+#include "lib.h"
+
+#define MAXDEV 6 /* change sscanf()'s manually if changed here */
+#define ANYDEV "any"
+#define ANL "\r\n" /* newline in ASC mode */
+
+#define COMMENTSZ 200
+#define BUFSZ (sizeof("(1345212884.318850)") + IFNAMSIZ + 4 + CL_CFSZ + COMMENTSZ) /* for one line in the logfile */
+
+#define DEFPORT 28700
+
+static char devname[MAXDEV][IFNAMSIZ+1];
+static int  dindex[MAXDEV];
+static int  max_devname_len;
+
+extern int optind, opterr, optopt;
+
+static volatile int running = 1;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>+\n", prg);
+	fprintf(stderr, "  (use CTRL-C to terminate %s)\n\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -m <mask>   (ID filter mask.  Default 0x00000000) *\n");
+	fprintf(stderr, "         -v <value>  (ID filter value. Default 0x00000000) *\n");
+	fprintf(stderr, "         -i <0|1>    (invert the specified ID filter) *\n");
+	fprintf(stderr, "         -e <emask>  (mask for error frames)\n");
+	fprintf(stderr, "         -p <port>   (listen on port <port>. Default: %d)\n", DEFPORT);
+	fprintf(stderr, "\n");
+	fprintf(stderr, "* The CAN ID filter matches, when ...\n");
+	fprintf(stderr, "       <received_can_id> & mask == value & mask\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "When using more than one CAN interface the options\n");
+	fprintf(stderr, "m/v/i/e have comma separated values e.g. '-m 0,7FF,0'\n");
+	fprintf(stderr, "\nUse interface name '%s' to receive from all CAN interfaces.\n\n", ANYDEV);
+}
+
+int idx2dindex(int ifidx, int socket)
+{
+	int i;
+	struct ifreq ifr;
+
+	for (i=0; i<MAXDEV; i++) {
+		if (dindex[i] == ifidx)
+			return i;
+	}
+
+	/* create new interface index cache entry */
+
+	/* remove index cache zombies first */
+	for (i=0; i < MAXDEV; i++) {
+		if (dindex[i]) {
+			ifr.ifr_ifindex = dindex[i];
+			if (ioctl(socket, SIOCGIFNAME, &ifr) < 0)
+				dindex[i] = 0;
+		}
+	}
+
+	for (i=0; i < MAXDEV; i++)
+		if (!dindex[i]) /* free entry */
+			break;
+
+	if (i == MAXDEV) {
+		printf("Interface index cache only supports %d interfaces.\n", MAXDEV);
+		exit(1);
+	}
+
+	dindex[i] = ifidx;
+
+	ifr.ifr_ifindex = ifidx;
+	if (ioctl(socket, SIOCGIFNAME, &ifr) < 0)
+		perror("SIOCGIFNAME");
+
+	if (max_devname_len < (int)strlen(ifr.ifr_name))
+		max_devname_len = strlen(ifr.ifr_name);
+
+	strcpy(devname[i], ifr.ifr_name);
+
+#ifdef DEBUG
+	printf("new index %d (%s)\n", i, devname[i]);
+#endif
+
+	return i;
+}
+
+/* 
+ * This is a Signalhandler. When we get a signal, that a child
+ * terminated, we wait for it, so the zombie will disappear.
+ */
+void childdied(int i)
+{
+	wait(NULL);
+}
+
+/*
+ * This is a Signalhandler for a caught SIGTERM
+ */
+void shutdown_gra(int i)
+{
+	exit(0);
+}
+
+
+int main(int argc, char **argv)
+{
+	struct sigaction signalaction;
+	sigset_t sigset;
+	fd_set rdfs;
+	int s[MAXDEV];
+	int socki, accsocket;
+	canid_t mask[MAXDEV] = {0};
+	canid_t value[MAXDEV] = {0};
+	int inv_filter[MAXDEV] = {0};
+	can_err_mask_t err_mask[MAXDEV] = {0};
+	int opt, ret;
+	int currmax = 1; /* we assume at least one can bus ;-) */
+	struct sockaddr_can addr;
+	struct can_filter rfilter;
+	struct canfd_frame frame;
+	const int canfd_on = 1;
+	int nbytes, i, j, maxdlen;
+	struct ifreq ifr;
+	struct timeval tv;
+	int port = DEFPORT;
+	struct sockaddr_in inaddr;
+	struct sockaddr_in clientaddr;
+	socklen_t sin_size = sizeof(clientaddr);
+	char temp[BUFSZ];
+
+	sigemptyset(&sigset);
+	signalaction.sa_handler = &childdied;
+	signalaction.sa_mask = sigset;
+	signalaction.sa_flags = 0;
+	sigaction(SIGCHLD, &signalaction, NULL);  /* install signal for dying child */
+	signalaction.sa_handler = &shutdown_gra;
+	signalaction.sa_mask = sigset;
+	signalaction.sa_flags = 0;
+	sigaction(SIGTERM, &signalaction, NULL); /* install Signal for termination */
+	sigaction(SIGINT, &signalaction, NULL); /* install Signal for termination */
+
+	while ((opt = getopt(argc, argv, "m:v:i:e:p:?")) != -1) {
+
+		switch (opt) {
+		case 'm':
+			i = sscanf(optarg, "%x,%x,%x,%x,%x,%x",
+				   &mask[0], &mask[1], &mask[2],
+				   &mask[3], &mask[4], &mask[5]);
+			if (i > currmax)
+				currmax = i;
+			break;
+
+		case 'v':
+			i = sscanf(optarg, "%x,%x,%x,%x,%x,%x",
+				   &value[0], &value[1], &value[2],
+				   &value[3], &value[4], &value[5]);
+			if (i > currmax)
+				currmax = i;
+			break;
+
+		case 'i':
+			i = sscanf(optarg, "%d,%d,%d,%d,%d,%d",
+				   &inv_filter[0], &inv_filter[1], &inv_filter[2],
+				   &inv_filter[3], &inv_filter[4], &inv_filter[5]);
+			if (i > currmax)
+				currmax = i;
+			break;
+
+		case 'e':
+			i = sscanf(optarg, "%x,%x,%x,%x,%x,%x",
+				   &err_mask[0], &err_mask[1], &err_mask[2],
+				   &err_mask[3], &err_mask[4], &err_mask[5]);
+			if (i > currmax)
+				currmax = i;
+			break;
+		case 'p':
+			port = atoi(optarg);
+			break;
+		default:
+			print_usage(basename(argv[0]));
+			exit(1);
+			break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+
+	/* count in options higher than device count ? */
+	if (optind + currmax > argc) {
+		printf("low count of CAN devices!\n");
+		return 1;
+	}
+
+	currmax = argc - optind; /* find real number of CAN devices */
+
+	if (currmax > MAXDEV) {
+		printf("More than %d CAN devices!\n", MAXDEV);
+		return 1;
+	}
+
+
+	socki = socket(PF_INET, SOCK_STREAM, 0);
+	if (socki < 0) {
+		perror("socket");
+		exit(1);
+	}
+
+	inaddr.sin_family = AF_INET;
+	inaddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	inaddr.sin_port = htons(port);
+
+	while(bind(socki, (struct sockaddr*)&inaddr, sizeof(inaddr)) < 0) {
+		struct timespec f = {
+			.tv_nsec = 100 * 1000 * 1000,
+		};
+
+		printf(".");fflush(NULL);
+		nanosleep(&f, NULL);
+	}
+
+	if (listen(socki, 3) != 0) {
+		perror("listen");
+		exit(1);
+	}
+
+	while(1) {
+		accsocket = accept(socki, (struct sockaddr*)&clientaddr, &sin_size);
+		if (accsocket > 0) {
+			//printf("accepted\n");
+			if (!fork())
+				break;
+			close(accsocket);
+		}
+		else if (errno != EINTR) {
+			perror("accept");
+			exit(1);
+		}
+	}
+
+	for (i=0; i<currmax; i++) {
+
+#ifdef DEBUG
+		printf("open %d '%s' m%08X v%08X i%d e%d.\n",
+		       i, argv[optind+i], mask[i], value[i],
+		       inv_filter[i], err_mask[i]);
+#endif
+
+		if ((s[i] = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
+			perror("socket");
+			return 1;
+		}
+
+		if (mask[i] || value[i]) {
+
+			printf("CAN ID filter[%d] for %s set to "
+			       "mask = %08X, value = %08X %s\n",
+			       i, argv[optind+i], mask[i], value[i],
+			       (inv_filter[i]) ? "(inv_filter)" : "");
+
+			rfilter.can_id   = value[i];
+			rfilter.can_mask = mask[i];
+			if (inv_filter[i])
+				rfilter.can_id |= CAN_INV_FILTER;
+
+			setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FILTER,
+				   &rfilter, sizeof(rfilter));
+		}
+
+		if (err_mask[i])
+			setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_ERR_FILTER,
+				   &err_mask[i], sizeof(err_mask[i]));
+
+		/* try to switch the socket into CAN FD mode */
+		setsockopt(s[i], SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));
+
+		j = strlen(argv[optind+i]);
+
+		if (!(j < IFNAMSIZ)) {
+			printf("name of CAN device '%s' is too long!\n", argv[optind+i]);
+			return 1;
+		}
+
+		if (j > max_devname_len)
+			max_devname_len = j; /* for nice printing */
+
+		addr.can_family = AF_CAN;
+
+		if (strcmp(ANYDEV, argv[optind + i]) != 0) {
+			strcpy(ifr.ifr_name, argv[optind+i]);
+			if (ioctl(s[i], SIOCGIFINDEX, &ifr) < 0) {
+				perror("SIOCGIFINDEX");
+				exit(1);
+			}
+			addr.can_ifindex = ifr.ifr_ifindex;
+		} else
+			addr.can_ifindex = 0; /* any can interface */
+
+		if (bind(s[i], (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+			perror("bindcan");
+			return 1;
+		}
+	}
+
+	while (running) {
+
+		FD_ZERO(&rdfs);
+		for (i=0; i<currmax; i++)
+			FD_SET(s[i], &rdfs);
+
+		if ((ret = select(s[currmax-1]+1, &rdfs, NULL, NULL, NULL)) < 0) {
+			//perror("select");
+			running = 0;
+			continue;
+		}
+
+		for (i=0; i<currmax; i++) {  /* check all CAN RAW sockets */
+
+			if (FD_ISSET(s[i], &rdfs)) {
+
+				socklen_t len = sizeof(addr);
+				int idx;
+
+				if ((nbytes = recvfrom(s[i], &frame, CANFD_MTU, 0,
+						       (struct sockaddr*)&addr, &len)) < 0) {
+					perror("read");
+					return 1;
+				}
+
+				if ((size_t)nbytes == CAN_MTU)
+					maxdlen = CAN_MAX_DLEN;
+				else if ((size_t)nbytes == CANFD_MTU)
+					maxdlen = CANFD_MAX_DLEN;
+				else {
+					fprintf(stderr, "read: incomplete CAN frame\n");
+					return 1;
+				}
+
+				if (ioctl(s[i], SIOCGSTAMP, &tv) < 0)
+					perror("SIOCGSTAMP");
+
+
+				idx = idx2dindex(addr.can_ifindex, s[i]);
+
+				sprintf(temp, "(%lu.%06lu) %*s ",
+					tv.tv_sec, tv.tv_usec, max_devname_len, devname[idx]);
+				sprint_canframe(temp+strlen(temp), &frame, 0, maxdlen); 
+				strcat(temp, "\n");
+
+				if (write(accsocket, temp, strlen(temp)) < 0) {
+					perror("writeaccsock");
+					return 1;
+				}
+		    
+#if 0
+				/* print CAN frame in log file style to stdout */
+				printf("(%lu.%06lu) ", tv.tv_sec, tv.tv_usec);
+				printf("%*s ", max_devname_len, devname[idx]);
+				fprint_canframe(stdout, &frame, "\n", 0, maxdlen);
+#endif
+			}
+
+		}
+	}
+
+	for (i=0; i<currmax; i++)
+		close(s[i]);
+
+	close(accsocket);
+	return 0;
+}
diff --git a/canutils/canplayer.c b/canutils/canplayer.c
new file mode 100644
index 0000000000..51adc77b4d
--- /dev/null
+++ b/canutils/canplayer.c
@@ -0,0 +1,556 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * canplayer.c - replay a compact CAN frame logfile to CAN devices
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+
+#include "lib.h"
+
+#define DEFAULT_GAP	1	/* ms */
+#define DEFAULT_LOOPS	1	/* only one replay */
+#define CHANNELS	20	/* anyone using more than 20 CAN interfaces at a time? */
+#define COMMENTSZ 200
+#define BUFSZ (sizeof("(1345212884.318850)") + IFNAMSIZ + 4 + CL_CFSZ + COMMENTSZ) /* for one line in the logfile */
+#define STDOUTIDX	65536	/* interface index for printing on stdout - bigger than max uint16 */
+
+struct assignment {
+	char txif[IFNAMSIZ];
+	int  txifidx;
+	char rxif[IFNAMSIZ];
+};
+static struct assignment asgn[CHANNELS];
+const int canfd_on = 1;
+
+extern int optind, opterr, optopt;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - replay a compact CAN frame logfile to CAN devices.\n", prg);
+	fprintf(stderr, "\nUsage: %s <options> [interface assignment]*\n\n", prg);
+        fprintf(stderr, "Options:\n");
+        fprintf(stderr, "         -I <infile>  (default stdin)\n");
+        fprintf(stderr, "         -l <num>     "
+                "(process input file <num> times)\n"
+                "                      "
+                "(Use 'i' for infinite loop - default: %d)\n", DEFAULT_LOOPS);
+        fprintf(stderr, "         -t           (ignore timestamps: "
+                "send frames immediately)\n");
+        fprintf(stderr, "         -i           (interactive - wait "
+                "for ENTER key to process next frame)\n");
+	fprintf(stderr, "         -n <count>   (terminate after "
+		"processing <count> CAN frames)\n");
+        fprintf(stderr, "         -g <ms>      (gap in milli "
+                "seconds - default: %d ms)\n", DEFAULT_GAP);
+        fprintf(stderr, "         -s <s>       (skip gaps in "
+                "timestamps > 's' seconds)\n");
+        fprintf(stderr, "         -x           (disable local "
+                "loopback of sent CAN frames)\n");
+        fprintf(stderr, "         -v           (verbose: print "
+                "sent CAN frames)\n\n");
+        fprintf(stderr, "Interface assignment:\n");
+	fprintf(stderr, " 0..n assignments like <write-if>=<log-if>\n\n");
+	fprintf(stderr, " e.g. vcan2=can0  (send frames received from can0 on "
+		"vcan2)\n");
+	fprintf(stderr, " extra hook: stdout=can0  (print logfile line marked with can0 on "
+		"stdout)\n");
+	fprintf(stderr, " No assignments  => send frames to the interface(s) they "
+		"had been received from\n\n");
+	fprintf(stderr, "Lines in the logfile not beginning with '(' (start of "
+		"timestamp) are ignored.\n\n");
+}
+
+/* copied from /usr/src/linux/include/linux/time.h ...
+ * lhs < rhs:  return <0
+ * lhs == rhs: return 0
+ * lhs > rhs:  return >0
+ */
+static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)
+{
+	if (lhs->tv_sec < rhs->tv_sec)
+		return -1;
+	if (lhs->tv_sec > rhs->tv_sec)
+		return 1;
+	return lhs->tv_usec - rhs->tv_usec;
+}
+
+static inline void create_diff_tv(struct timeval *today, struct timeval *diff,
+				  struct timeval *log) {
+
+	/* create diff_tv so that log_tv + diff_tv = today_tv */
+	diff->tv_sec  = today->tv_sec  - log->tv_sec;
+	diff->tv_usec = today->tv_usec - log->tv_usec;
+}
+
+static inline int frames_to_send(struct timeval *today, struct timeval *diff,
+				 struct timeval *log)
+{
+	/* return value <0 when log + diff < today */
+
+	struct timeval cmp;
+
+	cmp.tv_sec  = log->tv_sec  + diff->tv_sec;
+	cmp.tv_usec = log->tv_usec + diff->tv_usec;
+
+	if (cmp.tv_usec >= 1000000) {
+		cmp.tv_usec -= 1000000;
+		cmp.tv_sec++;
+	}
+
+	if (cmp.tv_usec < 0) {
+		cmp.tv_usec += 1000000;
+		cmp.tv_sec--;
+	}
+
+	return timeval_compare(&cmp, today);
+}
+
+int get_txidx(char *logif_name) {
+
+	int i;
+
+	for (i=0; i<CHANNELS; i++) {
+		if (asgn[i].rxif[0] == 0) /* end of table content */
+			break;
+		if (strcmp(asgn[i].rxif, logif_name) == 0) /* found device name */
+			break;
+	}
+
+	if ((i == CHANNELS) || (asgn[i].rxif[0] == 0))
+		return 0; /* not found */
+
+	return asgn[i].txifidx; /* return interface index */
+}
+
+char *get_txname(char *logif_name) {
+
+	int i;
+
+	for (i=0; i<CHANNELS; i++) {
+		if (asgn[i].rxif[0] == 0) /* end of table content */
+			break;
+		if (strcmp(asgn[i].rxif, logif_name) == 0) /* found device name */
+			break;
+	}
+
+	if ((i == CHANNELS) || (asgn[i].rxif[0] == 0))
+		return 0; /* not found */
+
+	return asgn[i].txif; /* return interface name */
+}
+
+int add_assignment(char *mode, int socket, char *txname, char *rxname,
+		   int verbose) {
+
+	struct ifreq ifr;
+	int i;
+
+	/* find free entry */
+	for (i=0; i<CHANNELS; i++) {
+		if (asgn[i].txif[0] == 0)
+			break;
+	}
+
+	if (i == CHANNELS) {
+		fprintf(stderr, "Assignment table exceeded!\n");
+		return 1;
+	}
+
+	if (strlen(txname) >= IFNAMSIZ) {
+		fprintf(stderr, "write-if interface name '%s' too long!", txname);
+		return 1;
+	}
+	strcpy(asgn[i].txif, txname);
+
+	if (strlen(rxname) >= IFNAMSIZ) {
+		fprintf(stderr, "log-if interface name '%s' too long!", rxname);
+		return 1;
+	}
+	strcpy(asgn[i].rxif, rxname);
+
+	if (strcmp(txname, "stdout") != 0) {
+		strcpy(ifr.ifr_name, txname);
+		if (ioctl(socket, SIOCGIFINDEX, &ifr) < 0) {
+			perror("SIOCGIFINDEX");
+			fprintf(stderr, "write-if interface name '%s' is wrong!\n", txname);
+			return 1;
+		}
+		asgn[i].txifidx = ifr.ifr_ifindex;
+	} else
+		asgn[i].txifidx = STDOUTIDX;
+
+	if (verbose > 1) /* use -v -v to see this */
+		printf("added %s assignment: log-if=%s write-if=%s write-if-idx=%d\n",
+		       mode, asgn[i].rxif, asgn[i].txif, asgn[i].txifidx);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	static char buf[BUFSZ], device[BUFSZ], ascframe[BUFSZ];
+	struct sockaddr_can addr;
+	static struct canfd_frame frame;
+	static struct timeval today_tv, log_tv, last_log_tv, diff_tv;
+	struct timespec sleep_ts;
+	int s; /* CAN_RAW socket */
+	FILE *infile = stdin;
+	unsigned long gap = DEFAULT_GAP; 
+	int use_timestamps = 1;
+	int interactive = 0; /* wait for ENTER keypress to process next frame */
+	int count = 0; /* end replay after sending count frames. 0 = disabled */
+	static int verbose, opt, delay_loops;
+	static unsigned long skipgap;
+	static int loopback_disable = 0;
+	static int infinite_loops = 0;
+	static int loops = DEFAULT_LOOPS;
+	int assignments; /* assignments defined on the commandline */
+	int txidx;       /* sendto() interface index */
+	int eof, txmtu, i, j;
+	char *fret;
+
+	while ((opt = getopt(argc, argv, "I:l:tin:g:s:xv?")) != -1) {
+		switch (opt) {
+		case 'I':
+			infile = fopen(optarg, "r");
+			if (!infile) {
+				perror("infile");
+				return 1;
+			}
+			break;
+
+		case 'l':
+			if (optarg[0] == 'i')
+				infinite_loops = 1;
+			else
+				if (!(loops = atoi(optarg))) {
+					fprintf(stderr, "Invalid argument for option -l !\n");
+					return 1;
+				}
+			break;
+
+		case 't':
+			use_timestamps = 0;
+			break;
+
+		case 'i':
+			interactive = 1;
+			break;
+
+		case 'n':
+			count = atoi(optarg);
+			if (count < 1) {
+				print_usage(basename(argv[0]));
+				exit(1);
+			}
+			break;
+
+		case 'g':
+			gap = strtoul(optarg, NULL, 10);
+			break;
+
+		case 's':
+			skipgap = strtoul(optarg, NULL, 10);
+			if (skipgap < 1) {
+				fprintf(stderr, "Invalid argument for option -s !\n");
+				return 1;
+			}
+			break;
+
+		case 'x':
+			loopback_disable = 1;
+			break;
+
+		case 'v':
+			verbose++;
+			break;
+
+		case '?':
+		default:
+			print_usage(basename(argv[0]));
+			return 1;
+			break;
+		}
+	}
+
+	assignments = argc - optind; /* find real number of user assignments */
+
+	if (infile == stdin) { /* no jokes with stdin */
+		infinite_loops = 0;
+		loops = 1;
+	}
+
+	if (verbose > 1) { /* use -v -v to see this */
+		if (infinite_loops)
+			printf("infinite_loops\n");
+		else
+			printf("%d loops\n", loops);
+	}
+
+	/* ignore timestamps from logfile when in single step keypress mode */
+	if (interactive) {
+		use_timestamps = 0;
+		printf("interactive mode: press ENTER to process next CAN frame ...\n");
+	}
+
+	sleep_ts.tv_sec  =  gap / 1000;
+	sleep_ts.tv_nsec = (gap % 1000) * 1000000;
+
+	/* open socket */
+	if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family  = AF_CAN;
+	addr.can_ifindex = 0;
+
+	/* disable unneeded default receive filter on this RAW socket */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
+
+	/* try to switch the socket into CAN FD mode */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));
+
+	if (loopback_disable) {
+		int loopback = 0;
+
+		setsockopt(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK,
+			   &loopback, sizeof(loopback));
+	}
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	if (assignments) {
+		/* add & check user assignments from commandline */
+		for (i=0; i<assignments; i++) {
+			if (strlen(argv[optind+i]) >= BUFSZ) {
+				fprintf(stderr, "Assignment too long!\n");
+				print_usage(basename(argv[0]));
+				return 1;
+			}
+			strcpy(buf, argv[optind+i]);
+			for (j=0; j<(int)BUFSZ; j++) { /* find '=' in assignment */
+				if (buf[j] == '=')
+					break;
+			}
+			if ((j == BUFSZ) || (buf[j] != '=')) {
+				fprintf(stderr, "'=' missing in assignment!\n");
+				print_usage(basename(argv[0]));
+				return 1;
+			}
+			buf[j] = 0; /* cut string in two pieces */
+			if (add_assignment("user", s, &buf[0], &buf[j+1], verbose))
+				return 1;
+		}
+	}
+
+	while (infinite_loops || loops--) {
+
+		if (infile != stdin)
+			rewind(infile); /* for each loop */
+
+		if (verbose > 1) /* use -v -v to see this */
+			printf (">>>>>>>>> start reading file. remaining loops = %d\n", loops);
+
+		/* read first non-comment frame from logfile */
+		while ((fret = fgets(buf, BUFSZ-1, infile)) != NULL && buf[0] != '(') {
+			if (strlen(buf) >= BUFSZ-2) {
+				fprintf(stderr, "comment line too long for input buffer\n");
+				return 1;
+			}
+		}
+
+		if (!fret)
+			goto out; /* nothing to read */
+
+		eof = 0;
+
+		if (sscanf(buf, "(%lu.%lu) %s %s", &log_tv.tv_sec, &log_tv.tv_usec,
+			   device, ascframe) != 4) {
+			fprintf(stderr, "incorrect line format in logfile\n");
+			return 1;
+		}
+
+		if (use_timestamps) { /* throttle sending due to logfile timestamps */
+
+			gettimeofday(&today_tv, NULL);
+			create_diff_tv(&today_tv, &diff_tv, &log_tv);
+			last_log_tv = log_tv;
+		}
+
+		while (!eof) {
+
+			while ((!use_timestamps) ||
+			       (frames_to_send(&today_tv, &diff_tv, &log_tv) < 0)) {
+
+				/* wait for keypress to process next frame */
+				if (interactive)
+					getchar();
+
+				/* log_tv/device/ascframe are valid here */
+
+				if (strlen(device) >= IFNAMSIZ) {
+					fprintf(stderr, "log interface name '%s' too long!", device);
+					return 1;
+				}
+
+				txidx = get_txidx(device); /* get ifindex for sending the frame */
+ 
+				if ((!txidx) && (!assignments)) {
+					/* ifindex not found and no user assignments */
+					/* => assign this device automatically       */
+					if (add_assignment("auto", s, device, device, verbose))
+						return 1;
+					txidx = get_txidx(device);
+				}
+
+				if (txidx == STDOUTIDX) { /* hook to print logfile lines on stdout */
+
+					printf("%s", buf); /* print the line AS-IS without extra \n */
+					fflush(stdout);
+
+				} else if (txidx > 0) { /* only send to valid CAN devices */
+
+					txmtu = parse_canframe(ascframe, &frame);
+					if (!txmtu) {
+						fprintf(stderr, "wrong CAN frame format: '%s'!", ascframe);
+						return 1;
+					}
+
+					addr.can_family  = AF_CAN;
+					addr.can_ifindex = txidx; /* send via this interface */
+ 
+					if (sendto(s, &frame, txmtu, 0,	(struct sockaddr*)&addr, sizeof(addr)) != txmtu) {
+						perror("sendto");
+						return 1;
+					}
+
+					if (verbose) {
+						printf("%s (%s) ", get_txname(device), device);
+
+						if (txmtu == CAN_MTU)
+							fprint_long_canframe(stdout, &frame, "\n", CANLIB_VIEW_INDENT_SFF, CAN_MAX_DLEN);
+						else
+							fprint_long_canframe(stdout, &frame, "\n", CANLIB_VIEW_INDENT_SFF, CANFD_MAX_DLEN);
+					}
+
+					if (count && (--count == 0))
+						goto out;
+				}
+
+				/* read next non-comment frame from logfile */
+				while ((fret = fgets(buf, BUFSZ-1, infile)) != NULL && buf[0] != '(') {
+					if (strlen(buf) >= BUFSZ-2) {
+						fprintf(stderr, "comment line too long for input buffer\n");
+						return 1;
+					}
+				}
+
+				if (!fret) {
+					eof = 1; /* this file is completely processed */
+					break;
+				}
+
+				if (sscanf(buf, "(%lu.%lu) %s %s", &log_tv.tv_sec, &log_tv.tv_usec,
+					   device, ascframe) != 4) {
+					fprintf(stderr, "incorrect line format in logfile\n");
+					return 1;
+				}
+
+				/*
+				 * ensure the fractions of seconds are 6 decimal places long to catch
+				 * 3rd party or handcrafted logfiles that treat the timestamp as float
+				 */
+				if (strchr(buf, ')') - strchr(buf, '.') != 7) {
+					fprintf(stderr, "timestamp format in logfile requires 6 decimal places\n");
+					return 1;
+				}
+
+				if (use_timestamps) {
+					gettimeofday(&today_tv, NULL);
+
+					/* test for logfile timestamps jumping backwards OR      */
+					/* if the user likes to skip long gaps in the timestamps */
+					if ((last_log_tv.tv_sec > log_tv.tv_sec) ||
+					    (skipgap && labs(last_log_tv.tv_sec - log_tv.tv_sec) > (long)skipgap))
+						create_diff_tv(&today_tv, &diff_tv, &log_tv);
+
+					last_log_tv = log_tv;
+				}
+
+			} /* while frames_to_send ... */
+
+			if (nanosleep(&sleep_ts, NULL))
+				return 1;
+
+			delay_loops++; /* private statistics */
+			gettimeofday(&today_tv, NULL);
+
+		} /* while (!eof) */
+
+	} /* while (infinite_loops || loops--) */
+
+out:
+
+	close(s);
+	fclose(infile);
+
+	if (verbose > 1) /* use -v -v to see this */
+		printf("%d delay_loops\n", delay_loops);
+
+	return 0;
+}
diff --git a/canutils/cansend.c b/canutils/cansend.c
new file mode 100644
index 0000000000..ae031d9842
--- /dev/null
+++ b/canutils/cansend.c
@@ -0,0 +1,173 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * cansend.c - send CAN-frames via CAN_RAW sockets
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+
+#include "lib.h"
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - send CAN-frames via CAN_RAW sockets.\n", prg);
+	fprintf(stderr, "\nUsage: %s <device> <can_frame>.\n", prg);
+	fprintf(stderr, "\n<can_frame>:\n");
+	fprintf(stderr, " <can_id>#{data}          for Classical CAN 2.0 data frames\n");
+	fprintf(stderr, " <can_id>#R{len}          for Classical CAN 2.0 data frames\n");
+	fprintf(stderr, " <can_id>#{data}_{dlc}    for Classical CAN 2.0 data frames\n");
+	fprintf(stderr, " <can_id>#R{len}_{dlc}    for Classical CAN 2.0 data frames\n");
+	fprintf(stderr, " <can_id>##<flags>{data}  for CAN FD frames\n\n");
+	fprintf(stderr, "<can_id>:\n"
+	        " 3 (SFF) or 8 (EFF) hex chars\n");
+	fprintf(stderr, "{data}:\n"
+	        " 0..8 (0..64 CAN FD) ASCII hex-values (optionally separated by '.')\n");
+	fprintf(stderr, "{len}:\n"
+		 " an optional 0..8 value as RTR frames can contain a valid dlc field\n");
+	fprintf(stderr, "_{dlc}:\n"
+		 " an optional 9..F data length code value when payload length is 8\n");
+	fprintf(stderr, "<flags>:\n"
+	        " a single ASCII Hex value (0 .. F) which defines canfd_frame.flags\n\n");
+	fprintf(stderr, "Examples:\n");
+	fprintf(stderr, "  5A1#11.2233.44556677.88 / 123#DEADBEEF / 5AA# / 123##1 / 213##311223344 /\n"
+		 "  1F334455#1122334455667788_B / 123#R / 00000123#R3 / 333#R8_E\n\n");
+}
+
+
+
+int main(int argc, char **argv)
+{
+	int s; /* can raw socket */ 
+	int required_mtu;
+	int mtu;
+	int enable_canfd = 1;
+	struct sockaddr_can addr;
+	struct canfd_frame frame;
+	struct ifreq ifr;
+
+	/* check command line options */
+	if (argc != 3) {
+		print_usage(argv[0]);
+		return 1;
+	}
+
+	/* parse CAN frame */
+	required_mtu = parse_canframe(argv[2], &frame);
+	if (!required_mtu){
+		fprintf(stderr, "\nWrong CAN-frame format!\n\n");
+		print_usage(argv[0]);
+		return 1;
+	}
+
+	/* open socket */
+	if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	strncpy(ifr.ifr_name, argv[1], IFNAMSIZ - 1);
+	ifr.ifr_name[IFNAMSIZ - 1] = '\0';
+	ifr.ifr_ifindex = if_nametoindex(ifr.ifr_name);
+	if (!ifr.ifr_ifindex) {
+		perror("if_nametoindex");
+		return 1;
+	}
+
+	memset(&addr, 0, sizeof(addr));
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = ifr.ifr_ifindex;
+
+	if (required_mtu > (int)CAN_MTU) {
+
+		/* check if the frame fits into the CAN netdevice */
+		if (ioctl(s, SIOCGIFMTU, &ifr) < 0) {
+			perror("SIOCGIFMTU");
+			return 1;
+		}
+		mtu = ifr.ifr_mtu;
+
+		if (mtu != CANFD_MTU) {
+			printf("CAN interface is not CAN FD capable - sorry.\n");
+			return 1;
+		}
+
+		/* interface is ok - try to switch the socket into CAN FD mode */
+		if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,
+			       &enable_canfd, sizeof(enable_canfd))){
+			printf("error when enabling CAN FD support\n");
+			return 1;
+		}
+
+		/* ensure discrete CAN FD length values 0..8, 12, 16, 20, 24, 32, 64 */
+		frame.len = can_fd_dlc2len(can_fd_len2dlc(frame.len));
+	}
+
+	/* disable default receive filter on this RAW socket */
+	/* This is obsolete as we do not read from the socket at all, but for */
+	/* this reason we can remove the receive list in the Kernel to save a */
+	/* little (really a very little!) CPU usage.                          */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	/* send frame */
+	if (write(s, &frame, required_mtu) != required_mtu) {
+		perror("write");
+		return 1;
+	}
+
+	close(s);
+
+	return 0;
+}
diff --git a/canutils/cansequence.c b/canutils/cansequence.c
new file mode 100644
index 0000000000..78cf5a589f
--- /dev/null
+++ b/canutils/cansequence.c
@@ -0,0 +1,367 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+// Copyright (c) 2007, 2008, 2009, 2010, 2014, 2015, 2019 Pengutronix,
+//		 Marc Kleine-Budde <kernel@pengutronix.de>
+// Copyright (c) 2005 Pengutronix,
+//		 Sascha Hauer <kernel@pengutronix.de>
+
+#include <errno.h>
+#include <getopt.h>
+#include <libgen.h>
+#include <limits.h>
+#include <poll.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <net/if.h>
+
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+
+#define CAN_ID_DEFAULT	(2)
+
+extern int optind, opterr, optopt;
+
+static int s = -1;
+static bool running = true;
+static bool infinite = true;
+static unsigned int drop_until_quit;
+static unsigned int drop_count;
+static bool use_poll = false;
+
+static unsigned int loopcount = 1;
+static int verbose;
+
+static struct can_frame frame = {
+	.can_dlc = 1,
+};
+static struct can_filter filter[] = {
+	{ .can_id = CAN_ID_DEFAULT, },
+};
+
+static void print_usage(char *prg)
+{
+	fprintf(stderr, "Usage: %s [<can-interface>] [Options]\n"
+		"\n"
+		"cansequence sends CAN messages with a rising sequence number as payload.\n"
+		"When the -r option is given, cansequence expects to receive these messages\n"
+		"and prints an error message if a wrong sequence number is encountered.\n"
+		"The main purpose of this program is to test the reliability of CAN links.\n"
+		"\n"
+		"Options:\n"
+		" -e, --extended		send extended frame\n"
+		" -i, --identifier=ID	CAN Identifier (default = %u)\n"
+		"     --loop=COUNT	send message COUNT times\n"
+		" -p, --poll		use poll(2) to wait for buffer space while sending\n"
+		" -q, --quit <num>	quit if <num> wrong sequences are encountered\n"
+		" -r, --receive		work as receiver\n"
+		" -v, --verbose		be verbose (twice to be even more verbose\n"
+		" -h, --help		this help\n"
+		"     --version		print version information and exit\n",
+		prg, CAN_ID_DEFAULT);
+}
+
+static void sig_handler(int signo)
+{
+	running = false;
+}
+
+
+static void do_receive()
+{
+	uint8_t ctrlmsg[CMSG_SPACE(sizeof(struct timeval)) + CMSG_SPACE(sizeof(__u32))];
+	struct iovec iov = {
+		.iov_base = &frame,
+	};
+	struct msghdr msg = {
+		.msg_iov = &iov,
+		.msg_iovlen = 1,
+		.msg_control = &ctrlmsg,
+	};
+	const int dropmonitor_on = 1;
+	bool sequence_init = true;
+	unsigned int sequence_wrap = 0;
+	uint32_t sequence_mask = 0xff;
+	uint32_t sequence_rx = 0;
+	uint32_t sequence_delta = 0;
+	uint32_t sequence = 0;
+	unsigned int overflow_old = 0;
+	can_err_mask_t err_mask = CAN_ERR_MASK;
+
+	if (setsockopt(s, SOL_SOCKET, SO_RXQ_OVFL,
+		       &dropmonitor_on, sizeof(dropmonitor_on)) < 0) {
+		perror("setsockopt() SO_RXQ_OVFL not supported by your Linux Kernel");
+	}
+
+	/* enable recv. of error messages */
+	if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_ERR_FILTER, &err_mask, sizeof(err_mask))) {
+		perror("setsockopt()");
+		exit(EXIT_FAILURE);
+	}
+
+	/* enable recv. now */
+	if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, filter, sizeof(filter))) {
+		perror("setsockopt()");
+		exit(EXIT_FAILURE);
+	}
+
+	while ((infinite || loopcount--) && running) {
+		ssize_t nbytes;
+
+		msg.msg_iov[0].iov_len = sizeof(frame);
+		msg.msg_controllen = sizeof(ctrlmsg);
+		msg.msg_flags = 0;
+
+		nbytes = recvmsg(s, &msg, 0);
+		if (nbytes < 0) {
+			perror("read()");
+			exit(EXIT_FAILURE);
+		}
+
+		if (frame.can_id & CAN_ERR_FLAG) {
+			fprintf(stderr,
+				"sequence CNT: %6u, ERRORFRAME %7x   %02x %02x %02x %02x %02x %02x %02x %02x\n",
+				sequence, frame.can_id,
+				frame.data[0], frame.data[1], frame.data[2], frame.data[3],
+				frame.data[4], frame.data[5], frame.data[6], frame.data[7]);
+			continue;
+		}
+
+		sequence_rx = frame.data[0];
+
+		if (sequence_init) {
+			sequence_init = false;
+			sequence = sequence_rx;
+		}
+
+		sequence_delta = (sequence_rx - sequence) & sequence_mask;
+		if (sequence_delta) {
+			struct cmsghdr *cmsg;
+			uint32_t overflow = 0;
+			uint32_t overflow_delta;
+
+			drop_count++;
+
+			for (cmsg = CMSG_FIRSTHDR(&msg);
+			     cmsg && (cmsg->cmsg_level == SOL_SOCKET);
+			     cmsg = CMSG_NXTHDR(&msg,cmsg)) {
+				if (cmsg->cmsg_type == SO_RXQ_OVFL) {
+					memcpy(&overflow, CMSG_DATA(cmsg), sizeof(overflow));
+					break;
+				}
+			}
+
+			overflow_delta = overflow - overflow_old;
+
+			fprintf(stderr,
+				"sequence CNT: %6u, RX: %6u    expected: %3u    missing: %4u    skt overfl d: %4u a: %4u    delta: %3u    incident: %u\n",
+				sequence, sequence_rx,
+				sequence & sequence_mask, sequence_delta,
+				overflow_delta, overflow,
+				sequence_delta - overflow_delta,
+				drop_count);
+
+			if (drop_count == drop_until_quit)
+				exit(EXIT_FAILURE);
+
+			sequence = sequence_rx;
+			overflow_old = overflow;
+		} else 	if (verbose > 1) {
+			printf("sequence CNT: %6u, RX: %6u\n", sequence, sequence_rx);
+		}
+
+		sequence++;
+		if (verbose && !(sequence & sequence_mask))
+			printf("sequence wrap around (%d)\n", sequence_wrap++);
+
+	}
+}
+
+static void do_send()
+{
+	unsigned int seq_wrap = 0;
+	uint8_t sequence = 0;
+
+	while ((infinite || loopcount--) && running) {
+		ssize_t len;
+
+		if (verbose > 1)
+			printf("sending frame. sequence number: %d\n", sequence);
+
+	again:
+		len = write(s, &frame, sizeof(frame));
+		if (len == -1) {
+			switch (errno) {
+			case ENOBUFS: {
+				int err;
+				struct pollfd fds[] = {
+					{
+						.fd	= s,
+						.events	= POLLOUT,
+					},
+				};
+
+				if (!use_poll) {
+					perror("write");
+					exit(EXIT_FAILURE);
+				}
+
+				err = poll(fds, 1, 1000);
+				if (err == 0 || (err == -1 && errno != -EINTR)) {
+					perror("poll()");
+					exit(EXIT_FAILURE);
+				}
+			}
+			case EINTR:	/* fallthrough */
+				goto again;
+			default:
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		frame.data[0]++;
+		sequence++;
+
+		if (verbose && !sequence)
+			printf("sequence wrap around (%d)\n", seq_wrap++);
+	}
+}
+
+int main(int argc, char **argv)
+{
+	struct sigaction act = {
+		.sa_handler = sig_handler,
+	};
+	struct ifreq ifr;
+	struct sockaddr_can addr;
+	char *interface = "can0";
+	int family = PF_CAN, type = SOCK_RAW, proto = CAN_RAW;
+	int extended = 0;
+	int receive = 0;
+	int opt;
+
+	sigaction(SIGINT, &act, NULL);
+	sigaction(SIGTERM, &act, NULL);
+	sigaction(SIGHUP, &act, NULL);
+
+	struct option long_options[] = {
+		{ "extended",	no_argument,		0, 'e' },
+		{ "identifier",	required_argument,	0, 'i' },
+		{ "loop",	required_argument,	0, 'l' },
+		{ "poll",	no_argument,		0, 'p' },
+		{ "quit",	optional_argument,	0, 'q' },
+		{ "receive",	no_argument,		0, 'r' },
+		{ "verbose",	no_argument,		0, 'v' },
+		{ "help",	no_argument,		0, 'h' },
+		{ 0,		0,			0, 0},
+	};
+
+	while ((opt = getopt_long(argc, argv, "ei:pq::rvh", long_options, NULL)) != -1) {
+		switch (opt) {
+		case 'e':
+			extended = true;
+			break;
+
+		case 'i':
+			filter->can_id = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'r':
+			receive = true;
+			break;
+
+		case 'l':
+			if (optarg) {
+				loopcount = strtoul(optarg, NULL, 0);
+				infinite = false;
+			} else {
+				infinite = true;
+			}
+			break;
+
+		case 'p':
+			use_poll = true;
+			break;
+
+		case 'q':
+			if (optarg)
+				drop_until_quit = strtoul(optarg, NULL, 0);
+			else
+				drop_until_quit = 1;
+			break;
+
+		case 'v':
+			verbose++;
+			break;
+
+		case 'h':
+			print_usage(basename(argv[0]));
+			exit(EXIT_SUCCESS);
+			break;
+
+		default:
+			print_usage(basename(argv[0]));
+			exit(EXIT_FAILURE);
+			break;
+		}
+	}
+
+	if (argv[optind] != NULL)
+		interface = argv[optind];
+
+	if (extended) {
+		filter->can_mask = CAN_EFF_MASK;
+		filter->can_id  &= CAN_EFF_MASK;
+		filter->can_id  |= CAN_EFF_FLAG;
+	} else {
+		filter->can_mask = CAN_SFF_MASK;
+		filter->can_id  &= CAN_SFF_MASK;
+	}
+	frame.can_id = filter->can_id;
+	filter->can_mask |= CAN_EFF_FLAG;
+
+	printf("interface = %s, family = %d, type = %d, proto = %d\n",
+	       interface, family, type, proto);
+
+	s = socket(family, type, proto);
+	if (s < 0) {
+		perror("socket()");
+		exit(EXIT_FAILURE);
+	}
+
+	addr.can_family = family;
+	strncpy(ifr.ifr_name, interface, sizeof(ifr.ifr_name));
+	if (ioctl(s, SIOCGIFINDEX, &ifr)) {
+		perror("ioctl()");
+		exit(EXIT_FAILURE);
+	}
+	addr.can_ifindex = ifr.ifr_ifindex;
+
+	/* first don't recv. any msgs */
+	if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0)) {
+		perror("setsockopt()");
+		exit(EXIT_FAILURE);
+	}
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind()");
+		exit(EXIT_FAILURE);
+	}
+
+	if (receive)
+		do_receive();
+	else
+		do_send();
+
+	exit(EXIT_SUCCESS);
+}
diff --git a/canutils/cansniffer.c b/canutils/cansniffer.c
new file mode 100644
index 0000000000..5aa5e7ae5e
--- /dev/null
+++ b/canutils/cansniffer.c
@@ -0,0 +1,966 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * cansniffer.c - volatile CAN content visualizer
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <libgen.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <linux/sockios.h>
+
+#include "terminal.h"
+
+#define SETFNAME "sniffset."
+#define SETFDFNAME "sniffset_fd."
+#define FNAME_MAX_LEN 40
+
+#define ANYDEV   "any"
+#define MAX_SLOTS 2048
+
+#define CANFD_OFF  0 /* set to OFF */
+#define CANFD_ON   1 /* set to ON */
+#define CANFD_AUTO 2 /* unspecified => check for first received frame */
+
+/* flags */
+
+#define ENABLE  1 /* by filter or user */
+#define DISPLAY 2 /* is on the screen */
+#define UPDATE  4 /* needs to be printed on the screen */
+#define CLRSCR  8 /* clear screen in next loop */
+
+/* flags testing & setting */
+
+#define is_set(id, flag) (sniftab[id].flags & flag)
+#define is_clr(id, flag) (!(sniftab[id].flags & flag))
+
+#define do_set(id, flag) (sniftab[id].flags |= flag)
+#define do_clr(id, flag) (sniftab[id].flags &= ~flag)
+
+/* time defaults */
+
+#define TIMEOUT 500 /* in 10ms */
+#define HOLD    100 /* in 10ms */
+#define LOOP     20 /* in 10ms */
+
+#define ATTCOLOR ATTBOLD FGRED
+
+#define LDL " | "	/* long delimiter */
+#define SDL "|"		/* short delimiter for binary on 80 chars terminal */
+
+#define CC_SEP '#' /* interface name separator for Classical CAN */
+#define FD_SEP '*' /* interface name separator for CAN FD */
+
+static struct snif {
+	int flags;
+	long hold;
+	long timeout;
+	struct timeval laststamp;
+	struct timeval currstamp;
+	struct canfd_frame last;
+	struct canfd_frame current;
+	struct canfd_frame marker;
+	struct canfd_frame notch;
+} sniftab[MAX_SLOTS];
+
+extern int optind, opterr, optopt;
+
+static int idx;
+static int running = 1;
+static int clearscreen = 1;
+static int print_eff;
+static int print_ascii = 1;
+static int notch;
+static int max_dlen = CAN_MAX_DLEN;
+static long timeout = TIMEOUT;
+static long hold = HOLD;
+static long loop = LOOP;
+static long canfd_mode = CANFD_AUTO;
+static unsigned char binary;
+static unsigned char binary8;
+static unsigned char binary_gap;
+static unsigned char color;
+static unsigned char name_sep = CC_SEP;
+static char *interface;
+static char *vdl = LDL; /* variable delimiter */
+static char *ldl = LDL; /* long delimiter */
+
+void print_snifline(int slot);
+int handle_keyb(void);
+int handle_frame(int fd, long currcms);
+int handle_timeo(long currcms);
+int writesettings(char* name);
+int readsettings(char* name);
+int sniftab_index(canid_t id);
+
+void switchvdl(char *delim)
+{
+	/* reduce delimiter size for EFF IDs in binary display of up
+	   to 8 data bytes payload to fit into 80 chars per line */
+	if (binary8)
+		vdl = delim;
+}
+
+int comp(const void *elem1, const void *elem2)
+{
+    unsigned long f = ((struct snif*)elem1)->current.can_id;
+    unsigned long s = ((struct snif*)elem2)->current.can_id;
+
+    if (f > s)
+	    return  1;
+    if (f < s)
+	    return -1;
+
+    return 0;
+}
+
+void print_usage(char *prg)
+{
+	const char manual [] = {
+		"commands that can be entered at runtime:\n"
+		" q<ENTER>        - quit\n"
+		" b<ENTER>        - toggle binary / HEX-ASCII output\n"
+		" 8<ENTER>        - toggle binary / HEX-ASCII output (small for EFF on 80 chars)\n"
+		" B<ENTER>        - toggle binary with gap / HEX-ASCII output (exceeds 80 chars!)\n"
+		" c<ENTER>        - toggle color mode\n"
+		" @<ENTER>        - toggle ASCII output (disabled for CAN FD by default)\n"
+		" <SPACE><ENTER>  - force a clear screen\n"
+		" #<ENTER>        - notch currently marked/changed bits (can be used repeatedly)\n"
+		" *<ENTER>        - clear notched marked\n"
+		" rMYNAME<ENTER>  - read settings file (filter/notch)\n"
+		" wMYNAME<ENTER>  - write settings file (filter/notch)\n"
+		" a<ENTER>        - enable 'a'll SFF CAN-IDs to sniff\n"
+		" n<ENTER>        - enable 'n'one SFF CAN-IDs to sniff\n"
+		" A<ENTER>        - enable 'A'll EFF CAN-IDs to sniff\n"
+		" N<ENTER>        - enable 'N'one EFF CAN-IDs to sniff\n"
+		" +FILTER<ENTER>  - add CAN-IDs to sniff\n"
+		" -FILTER<ENTER>  - remove CAN-IDs to sniff\n"
+		"\n"
+		"FILTER can be a single CAN-ID or a CAN-ID/Bitmask:\n"
+		"\n"
+		" single SFF 11 bit IDs:\n"
+		"  +1F5<ENTER>               - add SFF CAN-ID 0x1F5\n"
+		"  -42E<ENTER>               - remove SFF CAN-ID 0x42E\n"
+		"\n"
+		" single EFF 29 bit IDs:\n"
+		"  +18FEDF55<ENTER>          - add EFF CAN-ID 0x18FEDF55\n"
+		"  -00000090<ENTER>          - remove EFF CAN-ID 0x00000090\n"
+		"\n"
+		" CAN-ID/Bitmask SFF:\n"
+		"  -42E7FF<ENTER>            - remove SFF CAN-ID 0x42E (using Bitmask)\n"
+		"  -500700<ENTER>            - remove SFF CAN-IDs 0x500 - 0x5FF\n"
+		"  +400600<ENTER>            - add SFF CAN-IDs 0x400 - 0x5FF\n"
+		"  +000000<ENTER>            - add all SFF CAN-IDs\n"
+		"  -000000<ENTER>            - remove all SFF CAN-IDs\n"
+		"\n"
+		" CAN-ID/Bitmask EFF:\n"
+		"  -0000000000000000<ENTER>  - remove all EFF CAN-IDs\n"
+		"  +12345678000000FF<ENTER>  - add EFF CAN IDs xxxxxx78\n"
+		"  +0000000000000000<ENTER>  - add all EFF CAN-IDs\n"
+		"\n"
+		"if (id & filter) == (sniff-id & filter) the action (+/-) is performed,\n"
+		"which is quite easy when the filter is 000 resp. 00000000 for EFF.\n"
+		"\n"
+	};
+
+	fprintf(stderr, "%s - volatile CAN content visualizer.\n", prg);
+	fprintf(stderr, "\nUsage: %s [can-interface]\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -q          (quiet - all IDs deactivated)\n");
+	fprintf(stderr, "         -r <name>   (read %sname from file)\n", SETFNAME);
+	fprintf(stderr, "         -e          (fix extended frame format output - no auto detect)\n");
+	fprintf(stderr, "         -b          (start with binary mode)\n");
+	fprintf(stderr, "         -8          (start with binary mode - for EFF on 80 chars)\n");
+	fprintf(stderr, "         -B          (start with binary mode with gap - exceeds 80 chars!)\n");
+	fprintf(stderr, "         -c          (color changes)\n");
+	fprintf(stderr, "         -f <mode>   (CAN FD mode: 0 = OFF, 1 = ON, 2 = auto detect, default: %d)\n", CANFD_AUTO);
+	fprintf(stderr, "         -t <time>   (timeout for ID display [x10ms] default: %d, 0 = OFF)\n", TIMEOUT);
+	fprintf(stderr, "         -h <time>   (hold marker on changes [x10ms] default: %d)\n", HOLD);
+	fprintf(stderr, "         -l <time>   (loop time (display) [x10ms] default: %d)\n", LOOP);
+	fprintf(stderr, "         -?          (print this help text)\n");
+	fprintf(stderr, "Use interface name '%s' to receive from all can-interfaces.\n", ANYDEV);
+	fprintf(stderr, "\n");
+	fprintf(stderr, "%s", manual);
+}
+
+void sigterm(int signo)
+{
+	running = 0;
+}
+
+int main(int argc, char **argv)
+{
+	fd_set rdfs;
+	int s;
+	long currcms = 0;
+	long lastcms = 0;
+	unsigned char quiet = 0;
+	int opt, ret = 0;
+	struct timeval timeo, start_tv, tv;
+	struct sockaddr_can addr;
+	int i;
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+	signal(SIGINT, sigterm);
+
+	for (i = 0; i < MAX_SLOTS ;i++) /* default: enable all slots */
+		do_set(i, ENABLE);
+
+	while ((opt = getopt(argc, argv, "r:t:h:l:f:qeb8Bc?")) != -1) {
+		switch (opt) {
+		case 'r':
+			if (readsettings(optarg) < 0) {
+				fprintf(stderr, "Unable to read setting file '%s%s'!\n", SETFNAME, optarg);
+				exit(1);
+			}
+			break;
+
+		case 't':
+			sscanf(optarg, "%ld", &timeout);
+			break;
+
+		case 'h':
+			sscanf(optarg, "%ld", &hold);
+			break;
+
+		case 'l':
+			sscanf(optarg, "%ld", &loop);
+			break;
+
+		case 'f':
+			sscanf(optarg, "%ld", &canfd_mode);
+			if ((canfd_mode != CANFD_ON) && (canfd_mode != CANFD_OFF))
+				canfd_mode = CANFD_AUTO;
+			break;
+
+		case 'q':
+			quiet = 1;
+			break;
+
+		case 'e':
+			print_eff = 1;
+			break;
+
+		case 'b':
+			binary = 1;
+			binary_gap = 0;
+			break;
+
+		case '8':
+			binary = 1;
+			binary8 = 1; /* enable variable delimiter for EFF */
+			switchvdl(SDL); /* switch directly to short delimiter */
+			binary_gap = 0;
+			break;
+
+		case 'B':
+			binary = 1;
+			binary_gap = 1;
+			break;
+
+		case 'c':
+			color = 1;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(0);
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			break;
+		}
+	}
+
+	if (optind == argc) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+
+	if (quiet)
+		for (i = 0; i < MAX_SLOTS; i++)
+			do_clr(i, ENABLE);
+
+	if (strlen(argv[optind]) >= IFNAMSIZ) {
+		printf("name of CAN device '%s' is too long!\n", argv[optind]);
+		return 1;
+	}
+
+	interface = argv[optind];
+
+	s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
+	if (s < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = 0; /* 'any' CAN interface */
+
+	/* check for specific CAN interface */
+	if (strcmp(ANYDEV, argv[optind]) != 0) {
+		addr.can_ifindex = if_nametoindex(argv[optind]);
+		if (!addr.can_ifindex) {
+			perror("if_nametoindex");
+			return 1;
+		}
+	}
+
+	/* enable CAN FD if not disabled by command line option */
+	if (canfd_mode != CANFD_OFF) {
+		const int enable_canfd = 1;
+
+		if (setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES,
+			       &enable_canfd, sizeof(enable_canfd))){
+			printf("error when enabling CAN FD support\n");
+			return 1;
+		}
+
+		/* might be changed in CANFD_AUTO mode */
+		max_dlen = CANFD_MAX_DLEN;
+		name_sep = FD_SEP;
+		print_ascii = 0; /* don't print ASCII for CAN FD by default */
+	}
+
+	ret = bind(s, (struct sockaddr *)&addr, sizeof(addr));
+	if (ret < 0) {
+		perror("bind");
+		close(s);
+		return ret;
+	}
+
+	gettimeofday(&start_tv, NULL);
+	tv.tv_sec = tv.tv_usec = 0;
+
+	printf("%s", CSR_HIDE); /* hide cursor */
+
+	while (running) {
+
+		FD_ZERO(&rdfs);
+		FD_SET(0, &rdfs);
+		FD_SET(s, &rdfs);
+
+		timeo.tv_sec  = 0;
+		timeo.tv_usec = 10000 * loop;
+
+		ret = select(s+1, &rdfs, NULL, NULL, &timeo);
+		if (ret < 0) {
+			//perror("select");
+			running = 0;
+			continue;
+		} else
+			ret = 0;
+
+		gettimeofday(&tv, NULL);
+		currcms = (tv.tv_sec - start_tv.tv_sec) * 100 + (tv.tv_usec / 10000);
+
+		if (FD_ISSET(0, &rdfs))
+			running &= handle_keyb();
+
+		if (FD_ISSET(s, &rdfs))
+			running &= handle_frame(s, currcms);
+
+		if (currcms - lastcms >= loop) {
+			running &= handle_timeo(currcms);
+			lastcms = currcms;
+		}
+	}
+
+	printf("%s", CSR_SHOW); /* show cursor */
+
+	close(s);
+	return ret;
+}
+
+void do_modify_sniftab(unsigned int value, unsigned int mask, char cmd)
+{
+	int i;
+
+	for (i = 0; i < idx ;i++) {
+		if ((sniftab[i].current.can_id & mask) == (value & mask)) {
+			if (cmd == '+')
+				do_set(i, ENABLE);
+			else
+				do_clr(i, ENABLE);
+		}
+	}
+}
+
+int handle_keyb(void)
+{
+	char cmd [25] = {0};
+	int i, clen;
+	unsigned int mask;
+	unsigned int value;
+
+	if (read(0, cmd, 24) > (long)strlen("+1234567812345678\n"))
+		return 1; /* ignore */
+
+	if (strlen(cmd) > 0)
+		cmd[strlen(cmd)-1] = 0; /* chop off trailing newline */
+
+	clen = strlen(&cmd[1]); /* content length behind command */
+
+	switch (cmd[0]) {
+
+	case '+':
+	case '-':
+		if (clen == 6) {
+			/* masking strict SFF ID content vvvmmm */
+			sscanf(&cmd[1], "%x", &value);
+			mask = value | 0xFFFF800; /* cleared flags! */
+			value >>= 12;
+			value &= 0x7FF;
+			do_modify_sniftab(value, mask, cmd[0]);
+			break;
+		} else if (clen == 16) {
+			sscanf(&cmd[9], "%x", &mask);
+			cmd[9] = 0; /* terminate 'value' */
+			sscanf(&cmd[1], "%x", &value);
+			mask |= CAN_EFF_FLAG;
+			value |= CAN_EFF_FLAG;
+			do_modify_sniftab(value, mask, cmd[0]);
+			break;
+		}
+
+		/* check for single SFF/EFF CAN ID length */
+		if (clen != 3 && clen != 8)
+			break;
+
+		/* enable/disable single SFF/EFF CAN ID */
+		sscanf(&cmd[1], "%x", &value);
+		if (clen == 8)
+			value |= CAN_EFF_FLAG;
+
+		i = sniftab_index(value);
+		if (i < 0)
+			break; /* No Match */
+
+		if (cmd[0] == '+')
+			do_set(i, ENABLE);
+		else
+			do_clr(i, ENABLE);
+
+		break;
+
+	case 'a' : /* all SFF CAN IDs */
+		value = 0;
+		mask = 0xFFFF800; /* cleared flags! */
+		do_modify_sniftab(value, mask, '+');
+		break;
+
+	case 'n' : /* none SFF CAN IDs */
+		value = 0;
+		mask = 0xFFFF800; /* cleared flags! */
+		do_modify_sniftab(value, mask, '-');
+		break;
+
+	case 'A' : /* all EFF CAN IDs */
+		value = CAN_EFF_FLAG;
+		mask = CAN_EFF_FLAG;
+		do_modify_sniftab(value, mask, '+');
+		break;
+
+	case 'N' : /* none EFF CAN IDs */
+		value = CAN_EFF_FLAG;
+		mask = CAN_EFF_FLAG;
+		do_modify_sniftab(value, mask, '-');
+		break;
+
+	case 'w' :
+		if (writesettings(&cmd[1]))
+			return 0;
+		break;
+
+	case 'r' :
+		if (readsettings(&cmd[1]) < 0)
+			return 0;
+		break;
+
+	case 'q' :
+		running = 0;
+		break;
+
+	case '@' :
+		/* toggle ASCII output */
+		print_ascii ^= 1;
+		break;
+
+	case 'B' :
+		binary_gap = 1;
+		switchvdl(LDL);
+		if (binary)
+			binary = 0;
+		else
+			binary = 1;
+
+		break;
+
+	case '8' :
+		binary8 = 1;
+		/* fallthrough */
+
+	case 'b' :
+		binary_gap = 0;
+		if (binary) {
+			binary = 0;
+			switchvdl(LDL);
+		} else {
+			binary = 1;
+			switchvdl(SDL);
+		}
+		break;
+
+	case 'c' :
+		if (color)
+			color = 0;
+		else
+			color = 1;
+
+		break;
+
+	case ' ' :
+		clearscreen = 1;
+		break;
+
+	case '#' :
+		notch = 1;
+		break;
+
+	case '*' :
+		for (i = 0; i < idx; i++)
+			memset(&sniftab[i].notch.data, 0, max_dlen);
+		break;
+
+	default:
+		break;
+	}
+
+	clearscreen = 1;
+
+	return 1; /* ok */
+}
+
+int handle_frame(int fd, long currcms)
+{
+	bool rx_changed = false;
+	bool run_qsort = false;
+	int nbytes, i, pos;
+	struct canfd_frame cf;
+
+	nbytes = read(fd, &cf, sizeof(cf));
+	if (nbytes < 0) {
+		perror("raw read");
+		return 0; /* quit */
+	}
+
+	if ((nbytes != CAN_MTU) && (nbytes != CANFD_MTU)) {
+		printf("received strange frame data length %d!\n", nbytes);
+		return 0; /* quit */
+	}
+
+	/* CAN FD auto mode: switch based on first reception */
+	if (canfd_mode == CANFD_AUTO) {
+		if (nbytes == CAN_MTU) {
+			canfd_mode = CANFD_OFF;
+			/* change back auto defaults for Classical CAN */
+			max_dlen = CAN_MAX_DLEN;
+			name_sep = CC_SEP;
+			print_ascii = 1;
+		} else {
+			canfd_mode = CANFD_ON;
+		}
+	}
+
+	/* filter for Classical CAN */
+	if ((canfd_mode == CANFD_OFF) && (nbytes == CANFD_MTU))
+		return 1; /* skip handling */
+
+	/* filter for CAN FD */
+	if ((canfd_mode == CANFD_ON) && (nbytes == CAN_MTU))
+		return 1; /* skip handling */
+
+	if (!print_eff && (cf.can_id & CAN_EFF_FLAG)) {
+		print_eff = 1;
+		clearscreen = 1;
+	}
+
+	pos = sniftab_index(cf.can_id);
+	if (pos < 0) {
+		/* CAN ID not existing */
+		if (idx >= MAX_SLOTS) {
+			/* informative exit */
+			perror("number of different CAN IDs exceeded MAX_SLOTS");
+			return 0; /* quit */
+		}
+		/* assign new slot */
+		pos = idx++;
+		rx_changed = true;
+		run_qsort = true;
+	}
+	else {
+		if (cf.len == sniftab[pos].current.len)
+			for (i = 0; i < cf.len; i++) {
+				if (cf.data[i] != sniftab[pos].current.data[i] ) {
+					rx_changed = true;
+					break;
+				}
+			}
+		else
+			rx_changed = true;
+	}
+
+	/* print received frame even if the data didn't change to get a gap time */
+	if ((sniftab[pos].laststamp.tv_sec == 0) && (sniftab[pos].laststamp.tv_usec == 0))
+		rx_changed = true;
+
+	if (rx_changed == true) {
+		sniftab[pos].laststamp = sniftab[pos].currstamp;
+		ioctl(fd, SIOCGSTAMP, &sniftab[pos].currstamp);
+
+		sniftab[pos].current = cf;
+		for (i = 0; i < max_dlen; i++)
+			sniftab[pos].marker.data[i] |= sniftab[pos].current.data[i] ^ sniftab[pos].last.data[i];
+
+		sniftab[pos].timeout = (timeout)?(currcms + timeout):0;
+
+		if (is_clr(pos, DISPLAY))
+			clearscreen = 1; /* new entry -> new drawing */
+
+		do_set(pos, DISPLAY);
+		do_set(pos, UPDATE);
+	}
+
+	if (run_qsort == true)
+		qsort(sniftab, idx, sizeof(sniftab[0]), comp);
+
+	return 1; /* ok */
+}
+
+int handle_timeo(long currcms)
+{
+	int i, j;
+	int force_redraw = 0;
+	static unsigned int frame_count;
+
+	if (clearscreen) {
+		if (print_eff)
+			printf("%s%sXX|ms%s-- ID --%sdata ...     < %s %c l=%ld h=%ld t=%ld slots=%d >",
+			       CLR_SCREEN, CSR_HOME, vdl, vdl, interface, name_sep, loop, hold, timeout, idx);
+		else
+			printf("%s%sXX|ms%sID %sdata ...     < %s %c l=%ld h=%ld t=%ld slots=%d >",
+			       CLR_SCREEN, CSR_HOME, ldl, ldl, interface, name_sep, loop, hold, timeout, idx);
+
+		force_redraw = 1;
+		clearscreen = 0;
+	}
+
+	if (notch) {
+		for (i = 0; i < idx; i++) {
+			for (j = 0; j < max_dlen; j++)
+				sniftab[i].notch.data[j] |= sniftab[i].marker.data[j];
+		}
+		notch = 0;
+	}
+
+	printf("%s", CSR_HOME);
+	printf("%02d\n", frame_count++); /* rolling display update counter */
+	frame_count %= 100;
+
+	for (i = 0; i < idx; i++) {
+		if is_set(i, ENABLE) {
+				if is_set(i, DISPLAY) {
+						if (is_set(i, UPDATE) || (force_redraw)) {
+							print_snifline(i);
+							sniftab[i].hold = currcms + hold;
+							do_clr(i, UPDATE);
+						}
+						else  if ((sniftab[i].hold) && (sniftab[i].hold < currcms)) {
+								memset(&sniftab[i].marker.data, 0, max_dlen);
+								print_snifline(i);
+								sniftab[i].hold = 0; /* disable update by hold */
+							}
+						else
+							printf("%s", CSR_DOWN); /* skip my line */
+
+						if (sniftab[i].timeout && sniftab[i].timeout < currcms) {
+							do_clr(i, DISPLAY);
+							do_clr(i, UPDATE);
+							clearscreen = 1; /* removed entry -> new drawing next time */
+						}
+					}
+				sniftab[i].last      = sniftab[i].current;
+			}
+	}
+
+	return 1; /* ok */
+}
+
+void print_snifline(int slot)
+{
+	long diffsec  = sniftab[slot].currstamp.tv_sec  - sniftab[slot].laststamp.tv_sec;
+	long diffusec = sniftab[slot].currstamp.tv_usec - sniftab[slot].laststamp.tv_usec;
+	int dlc_diff  = sniftab[slot].last.len - sniftab[slot].current.len;
+	canid_t cid = sniftab[slot].current.can_id;
+	int i,j;
+
+	if (diffusec < 0)
+		diffsec--, diffusec += 1000000;
+
+	if (diffsec < 0)
+		diffsec = diffusec = 0;
+
+	if (diffsec >= 100)
+		diffsec = 99, diffusec = 999999;
+
+	if (cid & CAN_EFF_FLAG)
+		printf("%02ld%03ld%s%08X%s", diffsec, diffusec/1000, vdl, cid & CAN_EFF_MASK, vdl);
+	else if (print_eff)
+		printf("%02ld%03ld%s---- %03X%s", diffsec, diffusec/1000, vdl, cid & CAN_SFF_MASK, vdl);
+	else
+		printf("%02ld%03ld%s%03X%s", diffsec, diffusec/1000, ldl, cid & CAN_SFF_MASK, ldl);
+
+	if (binary) {
+		for (i = 0; i < sniftab[slot].current.len; i++) {
+			for (j=7; j >= 0; j--) {
+				if ((color) && (sniftab[slot].marker.data[i] & 1<<j) &&
+				    (!(sniftab[slot].notch.data[i] & 1<<j)))
+					if (sniftab[slot].current.data[i] & 1<<j)
+						printf("%s1%s", ATTCOLOR, ATTRESET);
+					else
+						printf("%s0%s", ATTCOLOR, ATTRESET);
+				else
+					if (sniftab[slot].current.data[i] & 1<<j)
+						putchar('1');
+					else
+						putchar('0');
+			}
+			if (binary_gap)
+				putchar(' ');
+		}
+
+		/*
+		 * when the len decreased (dlc_diff > 0),
+		 * we need to blank the former data printout
+		 */
+		for (i = 0; i < dlc_diff; i++) {
+			printf("        ");
+			if (binary_gap)
+				putchar(' ');
+		}
+
+	} else { /* not binary -> hex data and ASCII output */
+
+		for (i = 0; i < sniftab[slot].current.len; i++)
+			if ((color) && (sniftab[slot].marker.data[i] & ~sniftab[slot].notch.data[i]))
+				printf("%s%02X%s ", ATTCOLOR, sniftab[slot].current.data[i], ATTRESET);
+			else
+				printf("%02X ", sniftab[slot].current.data[i]);
+
+		if (print_ascii) {
+			/* jump to common start for ASCII output */
+			if (sniftab[slot].current.len < max_dlen)
+				printf("%*s", (max_dlen - sniftab[slot].current.len) * 3, "");
+
+			for (i = 0; i < sniftab[slot].current.len; i++)
+				if ((sniftab[slot].current.data[i] > 0x1F) &&
+				    (sniftab[slot].current.data[i] < 0x7F))
+					if ((color) && (sniftab[slot].marker.data[i] & ~sniftab[slot].notch.data[i]))
+						printf("%s%c%s", ATTCOLOR, sniftab[slot].current.data[i], ATTRESET);
+					else
+						putchar(sniftab[slot].current.data[i]);
+				else
+					putchar('.');
+
+			/*
+			 * when the len decreased (dlc_diff > 0),
+			 * we need to blank the former data printout
+			 */
+			for (i = 0; i < dlc_diff; i++)
+				putchar(' ');
+		} else {
+			/*
+			 * when the len decreased (dlc_diff > 0),
+			 * we need to blank the former data printout
+			 */
+			for (i = 0; i < dlc_diff; i++)
+				printf("   ");
+		}
+	}
+
+	putchar('\n');
+
+	memset(&sniftab[slot].marker.data, 0, max_dlen);
+}
+
+int writesettings(char* name)
+{
+	int fd;
+	char fname[FNAME_MAX_LEN + 1];
+	int i,j;
+	char buf[13]= {0};
+
+	if (canfd_mode == CANFD_OFF)
+		strcpy(fname, SETFNAME);
+	else if (canfd_mode == CANFD_ON)
+		strcpy(fname, SETFDFNAME);
+	else {
+		printf("writesettings failed due to unspecified CAN FD mode\n");
+		return 1;
+	}
+
+	strncat(fname, name, FNAME_MAX_LEN - strlen(fname));
+	fd = open(fname, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
+	if (fd <= 0) {
+		printf("unable to write setting file '%s'!\n", fname);
+		return 1;
+	}
+
+	for (i = 0; i < idx ;i++) {
+		sprintf(buf, "<%08X>%c.", sniftab[i].current.can_id, (is_set(i, ENABLE))?'1':'0');
+		if (write(fd, buf, 12) < 0) {
+			perror("write");
+			return 1;
+		}
+		for (j = 0; j < max_dlen ; j++) {
+			sprintf(buf, "%02X", sniftab[i].notch.data[j]);
+			if (write(fd, buf, 2) < 0) {
+				perror("write");
+				return 1;
+			}
+		}
+		if (write(fd, "\n", 1) < 0) {
+			perror("write");
+			return 1;
+		}
+		/* Classical CAN: 12 + 16  + 1 = 29  bytes per entry */
+		/* CAN FD:        12 + 128 + 1 = 141 bytes per entry */
+	}
+	close(fd);
+	return 0;
+}
+
+int readsettings(char* name)
+{
+	int fd;
+	char fname[FNAME_MAX_LEN + 1];
+	char buf[142] = {0};
+	int entrylen;
+	int j;
+	bool done = false;
+
+	if (canfd_mode == CANFD_OFF) {
+		entrylen = 29;
+		strcpy(fname, SETFNAME);
+	} else if (canfd_mode == CANFD_ON) {
+		entrylen = 141;
+		strcpy(fname, SETFDFNAME);
+	} else {
+		printf("readsettings failed due to unspecified CAN FD mode\n");
+		return -1;
+	}
+
+	strncat(fname, name, FNAME_MAX_LEN - strlen(fname));
+	fd = open(fname, O_RDONLY);
+
+	if (fd <= 0) {
+		return -1;
+	}
+	idx = 0;
+	while (!done) {
+		if (read(fd, &buf, entrylen) != entrylen) {
+			done = true;
+			continue;
+		}
+		unsigned long id = strtoul(&buf[1], NULL, 16);
+
+		sniftab[idx].current.can_id = id;
+
+		if (buf[10] & 1)
+			do_set(idx, ENABLE);
+		else
+			do_clr(idx, ENABLE);
+
+		for (j = max_dlen - 1; j >= 0 ; j--) {
+			sniftab[idx].notch.data[j] =
+				(__u8) strtoul(&buf[2*j+12], NULL, 16) & 0xFF;
+			buf[2*j+12] = 0; /* cut off each time */
+		}
+
+		if (++idx >= MAX_SLOTS)
+			break;
+
+	}
+	close(fd);
+	return idx;
+}
+
+int sniftab_index(canid_t id)
+{
+	int i;
+
+	for (i = 0; i < idx; i++)
+		if (id == sniftab[i].current.can_id)
+			return i;
+
+	return -1; /* No match */
+}
diff --git a/canutils/cmake/make_uninstall.cmake b/canutils/cmake/make_uninstall.cmake
new file mode 100644
index 0000000000..451614ee72
--- /dev/null
+++ b/canutils/cmake/make_uninstall.cmake
@@ -0,0 +1,19 @@
+
+if(NOT EXISTS "${CMAKE_CURRENT_BINARY_DIR}/install_manifest.txt")
+    message(FATAL_ERROR "Cannot find install manifest: ${CMAKE_CURRENT_BINARY_DIR}/install_manifest.txt")
+endif()
+
+file(READ "${CMAKE_CURRENT_BINARY_DIR}/install_manifest.txt" files)
+string(REGEX REPLACE "[\r\n]" ";" files "${files}")
+
+foreach(file ${files})
+    message(STATUS "Uninstalling ${file}")
+    if(EXISTS "${file}")
+        file(REMOVE ${file})
+        if (EXISTS "${file}")
+            message(FATAL_ERROR "Problem when removing ${file}, please check your permissions")
+        endif()
+    else()
+        message(STATUS "File ${file} does not exist.")
+    endif()
+endforeach()
diff --git a/canutils/config/m4/.secret-world-domination-project b/canutils/config/m4/.secret-world-domination-project
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/canutils/configure.ac b/canutils/configure.ac
new file mode 100644
index 0000000000..f44a5e2121
--- /dev/null
+++ b/canutils/configure.ac
@@ -0,0 +1,120 @@
+# -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+AC_PREREQ([2.59])
+
+AC_INIT([can-utils],[trunk],[linux-can@vger.kernel.org])
+AC_CONFIG_SRCDIR([lib.c])
+AC_CONFIG_MACRO_DIR([config/m4])
+AC_CONFIG_AUX_DIR([config/autoconf])
+AC_CANONICAL_BUILD
+AC_CANONICAL_HOST
+
+#AM_MAINTAINER_MODE
+
+CFLAGS="${CFLAGS} -Wall"
+
+#
+# Checks for programs.
+#
+AC_PROG_CC
+LT_INIT(win32-dll)
+
+AM_INIT_AUTOMAKE([foreign no-exeext dist-bzip2 subdir-objects])
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+
+#
+# Checks for header files.
+#
+AC_CHECK_HEADERS([ \
+	fcntl.h \
+	limits.h \
+	locale.h \
+	stdint.h \
+	stdlib.h \
+	string.h \
+	syslog.h \
+	termios.h \
+	unistd.h \
+	\
+	netinet/in.h \
+	\
+	sys/ioctl.h \
+	sys/socket.h \
+	sys/time.h \
+])
+
+
+#
+# Checks for typedefs, structures, and compiler characteristics.
+#
+AC_C_INLINE
+AC_SYS_LARGEFILE
+AC_TYPE_OFF_T
+AC_TYPE_PID_T
+AC_TYPE_UINT64_T
+
+
+#
+# Checks for library functions.
+#
+AC_FUNC_FORK
+AC_FUNC_MKTIME
+AC_CHECK_FUNCS([ \
+	alarm \
+	gettimeofday \
+	localtime_r \
+	memset \
+	select \
+	setlocale \
+	socket \
+	strchr \
+	strerror \
+	strstr \
+	strtoul \
+])
+
+# glibc versions before 2.17 needs to link with -lrt for clock_nanosleep
+AC_SEARCH_LIBS([clock_nanosleep], [rt])
+
+AC_CHECK_DECL(SO_RXQ_OVFL,,
+    [AC_DEFINE([SO_RXQ_OVFL], [40], [SO_RXQ_OVFL])]
+)
+AC_CHECK_DECL(PF_CAN,,
+    [AC_DEFINE([PF_CAN], [29], [PF_CAN])]
+)
+AC_CHECK_DECL(AF_CAN,,
+    [AC_DEFINE([AF_CAN], [PF_CAN], [AF_CAN])]
+)
+AC_CHECK_DECL(N_SLCAN,,
+    [AC_DEFINE([N_SLCAN], [17], [N_SLCAN])]
+)
+AC_CHECK_DECL(SCM_TIMESTAMPING_OPT_STATS,,
+    [AC_DEFINE([SCM_TIMESTAMPING_OPT_STATS], [54], [SCM_TIMESTAMPING_OPT_STATS])]
+)
+AC_DEFINE(_GNU_SOURCE)
+
+
+#
+# Debugging
+#
+AC_MSG_CHECKING([whether to enable debugging])
+AC_ARG_ENABLE(debug,
+    AS_HELP_STRING([--enable-debug], [enable debugging [[default=no]]]),
+	[case "$enableval" in
+	(y | yes) CONFIG_DEBUG=yes ;;
+        (*) CONFIG_DEBUG=no ;;
+    esac],
+    [CONFIG_DEBUG=no])
+AC_MSG_RESULT([${CONFIG_DEBUG}])
+if test "${CONFIG_DEBUG}" = "yes"; then
+    CFLAGS="${CFLAGS} -Wsign-compare -Wfloat-equal -Wformat-security -g -O1"
+    AC_DEFINE(DEBUG, 1, [debugging])
+else
+    CFLAGS="${CFLAGS} -O2"
+fi
+
+
+AC_CONFIG_FILES([
+	GNUmakefile
+	])
+AC_OUTPUT
diff --git a/canutils/include/linux/can.h b/canutils/include/linux/can.h
new file mode 100644
index 0000000000..4ed1af958c
--- /dev/null
+++ b/canutils/include/linux/can.h
@@ -0,0 +1,247 @@
+/* SPDX-License-Identifier: ((GPL-2.0-only WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * linux/can.h
+ *
+ * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _UAPI_CAN_H
+#define _UAPI_CAN_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/* controller area network (CAN) kernel definitions */
+
+/* special address description flags for the CAN_ID */
+#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
+#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
+#define CAN_ERR_FLAG 0x20000000U /* error message frame */
+
+/* valid bits in CAN ID for frame formats */
+#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
+#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
+#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
+
+/*
+ * Controller Area Network Identifier structure
+ *
+ * bit 0-28	: CAN identifier (11/29 bit)
+ * bit 29	: error message frame flag (0 = data frame, 1 = error message)
+ * bit 30	: remote transmission request flag (1 = rtr frame)
+ * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
+ */
+typedef __u32 canid_t;
+
+#define CAN_SFF_ID_BITS		11
+#define CAN_EFF_ID_BITS		29
+
+/*
+ * Controller Area Network Error Message Frame Mask structure
+ *
+ * bit 0-28	: error class mask (see include/uapi/linux/can/error.h)
+ * bit 29-31	: set to zero
+ */
+typedef __u32 can_err_mask_t;
+
+/* CAN payload length and DLC definitions according to ISO 11898-1 */
+#define CAN_MAX_DLC 8
+#define CAN_MAX_RAW_DLC 15
+#define CAN_MAX_DLEN 8
+
+/* CAN FD payload length and DLC definitions according to ISO 11898-7 */
+#define CANFD_MAX_DLC 15
+#define CANFD_MAX_DLEN 64
+
+/**
+ * struct can_frame - Classical CAN frame structure (aka CAN 2.0B)
+ * @can_id:   CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
+ * @len:      CAN frame payload length in byte (0 .. 8)
+ * @can_dlc:  deprecated name for CAN frame payload length in byte (0 .. 8)
+ * @__pad:    padding
+ * @__res0:   reserved / padding
+ * @len8_dlc: optional DLC value (9 .. 15) at 8 byte payload length
+ *            len8_dlc contains values from 9 .. 15 when the payload length is
+ *            8 bytes but the DLC value (see ISO 11898-1) is greater then 8.
+ *            CAN_CTRLMODE_CC_LEN8_DLC flag has to be enabled in CAN driver.
+ * @data:     CAN frame payload (up to 8 byte)
+ */
+struct can_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	union {
+		/* CAN frame payload length in byte (0 .. CAN_MAX_DLEN)
+		 * was previously named can_dlc so we need to carry that
+		 * name for legacy support
+		 */
+		__u8 len;
+		__u8 can_dlc; /* deprecated */
+	} __attribute__((packed)); /* disable padding added in some ABIs */
+	__u8 __pad; /* padding */
+	__u8 __res0; /* reserved / padding */
+	__u8 len8_dlc; /* optional DLC for 8 byte payload length (9 .. 15) */
+	__u8 data[CAN_MAX_DLEN] __attribute__((aligned(8)));
+};
+
+/*
+ * defined bits for canfd_frame.flags
+ *
+ * The use of struct canfd_frame implies the FD Frame (FDF) bit to
+ * be set in the CAN frame bitstream on the wire. The FDF bit switch turns
+ * the CAN controllers bitstream processor into the CAN FD mode which creates
+ * two new options within the CAN FD frame specification:
+ *
+ * Bit Rate Switch - to indicate a second bitrate is/was used for the payload
+ * Error State Indicator - represents the error state of the transmitting node
+ *
+ * As the CANFD_ESI bit is internally generated by the transmitting CAN
+ * controller only the CANFD_BRS bit is relevant for real CAN controllers when
+ * building a CAN FD frame for transmission. Setting the CANFD_ESI bit can make
+ * sense for virtual CAN interfaces to test applications with echoed frames.
+ *
+ * The struct can_frame and struct canfd_frame intentionally share the same
+ * layout to be able to write CAN frame content into a CAN FD frame structure.
+ * When this is done the former differentiation via CAN_MTU / CANFD_MTU gets
+ * lost. CANFD_FDF allows programmers to mark CAN FD frames in the case of
+ * using struct canfd_frame for mixed CAN / CAN FD content (dual use).
+ * N.B. the Kernel APIs do NOT provide mixed CAN / CAN FD content inside of
+ * struct canfd_frame therefore the CANFD_FDF flag is disregarded by Linux.
+ */
+#define CANFD_BRS 0x01 /* bit rate switch (second bitrate for payload data) */
+#define CANFD_ESI 0x02 /* error state indicator of the transmitting node */
+#define CANFD_FDF 0x04 /* mark CAN FD for dual use of struct canfd_frame */
+
+/**
+ * struct canfd_frame - CAN flexible data rate frame structure
+ * @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
+ * @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)
+ * @flags:  additional flags for CAN FD
+ * @__res0: reserved / padding
+ * @__res1: reserved / padding
+ * @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)
+ */
+struct canfd_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    len;     /* frame payload length in byte */
+	__u8    flags;   /* additional flags for CAN FD */
+	__u8    __res0;  /* reserved / padding */
+	__u8    __res1;  /* reserved / padding */
+	__u8    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
+};
+
+#define CAN_MTU		(sizeof(struct can_frame))
+#define CANFD_MTU	(sizeof(struct canfd_frame))
+
+/* particular protocols of the protocol family PF_CAN */
+#define CAN_RAW		1 /* RAW sockets */
+#define CAN_BCM		2 /* Broadcast Manager */
+#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
+#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
+#define CAN_MCNET	5 /* Bosch MCNet */
+#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
+#define CAN_J1939	7 /* SAE J1939 */
+#define CAN_NPROTO	8
+
+#define SOL_CAN_BASE 100
+
+/*
+ * This typedef was introduced in Linux v3.1-rc2
+ * (commit 6602a4b net: Make userland include of netlink.h more sane)
+ * in <linux/socket.h>. It must be duplicated here to make the CAN
+ * headers self-contained.
+ */
+typedef unsigned short __kernel_sa_family_t;
+
+/**
+ * struct sockaddr_can - the sockaddr structure for CAN sockets
+ * @can_family:  address family number AF_CAN.
+ * @can_ifindex: CAN network interface index.
+ * @can_addr:    protocol specific address information
+ */
+struct sockaddr_can {
+	__kernel_sa_family_t can_family;
+	int         can_ifindex;
+	union {
+		/* transport protocol class address information (e.g. ISOTP) */
+		struct { canid_t rx_id, tx_id; } tp;
+
+		/* J1939 address information */
+		struct {
+			/* 8 byte name when using dynamic addressing */
+			__u64 name;
+
+			/* pgn:
+			 * 8 bit: PS in PDU2 case, else 0
+			 * 8 bit: PF
+			 * 1 bit: DP
+			 * 1 bit: reserved
+			 */
+			__u32 pgn;
+
+			/* 1 byte address */
+			__u8 addr;
+		} j1939;
+
+		/* reserved for future CAN protocols address information */
+	} can_addr;
+};
+
+/**
+ * struct can_filter - CAN ID based filter in can_register().
+ * @can_id:   relevant bits of CAN ID which are not masked out.
+ * @can_mask: CAN mask (see description)
+ *
+ * Description:
+ * A filter matches, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ * filter for error message frames (CAN_ERR_FLAG bit set in mask).
+ */
+struct can_filter {
+	canid_t can_id;
+	canid_t can_mask;
+};
+
+#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
+#define CAN_RAW_FILTER_MAX 512 /* maximum number of can_filter set via setsockopt() */
+
+#endif /* !_UAPI_CAN_H */
diff --git a/canutils/include/linux/can/bcm.h b/canutils/include/linux/can/bcm.h
new file mode 100644
index 0000000000..dd2b925b09
--- /dev/null
+++ b/canutils/include/linux/can/bcm.h
@@ -0,0 +1,105 @@
+/* SPDX-License-Identifier: ((GPL-2.0-only WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * linux/can/bcm.h
+ *
+ * Definitions for CAN Broadcast Manager (BCM)
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _UAPI_CAN_BCM_H
+#define _UAPI_CAN_BCM_H
+
+#include <linux/types.h>
+#include <linux/can.h>
+
+struct bcm_timeval {
+	long tv_sec;
+	long tv_usec;
+};
+
+/**
+ * struct bcm_msg_head - head of messages to/from the broadcast manager
+ * @opcode:    opcode, see enum below.
+ * @flags:     special flags, see below.
+ * @count:     number of frames to send before changing interval.
+ * @ival1:     interval for the first @count frames.
+ * @ival2:     interval for the following frames.
+ * @can_id:    CAN ID of frames to be sent or received.
+ * @nframes:   number of frames appended to the message head.
+ * @frames:    array of CAN frames.
+ */
+struct bcm_msg_head {
+	__u32 opcode;
+	__u32 flags;
+	__u32 count;
+	struct bcm_timeval ival1, ival2;
+	canid_t can_id;
+	__u32 nframes;
+	struct can_frame frames[0];
+};
+
+enum {
+	TX_SETUP = 1,	/* create (cyclic) transmission task */
+	TX_DELETE,	/* remove (cyclic) transmission task */
+	TX_READ,	/* read properties of (cyclic) transmission task */
+	TX_SEND,	/* send one CAN frame */
+	RX_SETUP,	/* create RX content filter subscription */
+	RX_DELETE,	/* remove RX content filter subscription */
+	RX_READ,	/* read properties of RX content filter subscription */
+	TX_STATUS,	/* reply to TX_READ request */
+	TX_EXPIRED,	/* notification on performed transmissions (count=0) */
+	RX_STATUS,	/* reply to RX_READ request */
+	RX_TIMEOUT,	/* cyclic message is absent */
+	RX_CHANGED	/* updated CAN frame (detected content change) */
+};
+
+#define SETTIMER            0x0001
+#define STARTTIMER          0x0002
+#define TX_COUNTEVT         0x0004
+#define TX_ANNOUNCE         0x0008
+#define TX_CP_CAN_ID        0x0010
+#define RX_FILTER_ID        0x0020
+#define RX_CHECK_DLC        0x0040
+#define RX_NO_AUTOTIMER     0x0080
+#define RX_ANNOUNCE_RESUME  0x0100
+#define TX_RESET_MULTI_IDX  0x0200
+#define RX_RTR_FRAME        0x0400
+#define CAN_FD_FRAME        0x0800
+
+#endif /* !_UAPI_CAN_BCM_H */
diff --git a/canutils/include/linux/can/error.h b/canutils/include/linux/can/error.h
new file mode 100644
index 0000000000..34633283de
--- /dev/null
+++ b/canutils/include/linux/can/error.h
@@ -0,0 +1,125 @@
+/* SPDX-License-Identifier: ((GPL-2.0-only WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * linux/can/error.h
+ *
+ * Definitions of the CAN error messages to be filtered and passed to the user.
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _UAPI_CAN_ERROR_H
+#define _UAPI_CAN_ERROR_H
+
+#define CAN_ERR_DLC 8 /* dlc for error message frames */
+
+/* error class (mask) in can_id */
+#define CAN_ERR_TX_TIMEOUT   0x00000001U /* TX timeout (by netdevice driver) */
+#define CAN_ERR_LOSTARB      0x00000002U /* lost arbitration    / data[0]    */
+#define CAN_ERR_CRTL         0x00000004U /* controller problems / data[1]    */
+#define CAN_ERR_PROT         0x00000008U /* protocol violations / data[2..3] */
+#define CAN_ERR_TRX          0x00000010U /* transceiver status  / data[4]    */
+#define CAN_ERR_ACK          0x00000020U /* received no ACK on transmission */
+#define CAN_ERR_BUSOFF       0x00000040U /* bus off */
+#define CAN_ERR_BUSERROR     0x00000080U /* bus error (may flood!) */
+#define CAN_ERR_RESTARTED    0x00000100U /* controller restarted */
+
+/* arbitration lost in bit ... / data[0] */
+#define CAN_ERR_LOSTARB_UNSPEC   0x00 /* unspecified */
+				      /* else bit number in bitstream */
+
+/* error status of CAN-controller / data[1] */
+#define CAN_ERR_CRTL_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_CRTL_RX_OVERFLOW 0x01 /* RX buffer overflow */
+#define CAN_ERR_CRTL_TX_OVERFLOW 0x02 /* TX buffer overflow */
+#define CAN_ERR_CRTL_RX_WARNING  0x04 /* reached warning level for RX errors */
+#define CAN_ERR_CRTL_TX_WARNING  0x08 /* reached warning level for TX errors */
+#define CAN_ERR_CRTL_RX_PASSIVE  0x10 /* reached error passive status RX */
+#define CAN_ERR_CRTL_TX_PASSIVE  0x20 /* reached error passive status TX */
+				      /* (at least one error counter exceeds */
+				      /* the protocol-defined level of 127)  */
+#define CAN_ERR_CRTL_ACTIVE      0x40 /* recovered to error active state */
+
+/* error in CAN protocol (type) / data[2] */
+#define CAN_ERR_PROT_UNSPEC      0x00 /* unspecified */
+#define CAN_ERR_PROT_BIT         0x01 /* single bit error */
+#define CAN_ERR_PROT_FORM        0x02 /* frame format error */
+#define CAN_ERR_PROT_STUFF       0x04 /* bit stuffing error */
+#define CAN_ERR_PROT_BIT0        0x08 /* unable to send dominant bit */
+#define CAN_ERR_PROT_BIT1        0x10 /* unable to send recessive bit */
+#define CAN_ERR_PROT_OVERLOAD    0x20 /* bus overload */
+#define CAN_ERR_PROT_ACTIVE      0x40 /* active error announcement */
+#define CAN_ERR_PROT_TX          0x80 /* error occurred on transmission */
+
+/* error in CAN protocol (location) / data[3] */
+#define CAN_ERR_PROT_LOC_UNSPEC  0x00 /* unspecified */
+#define CAN_ERR_PROT_LOC_SOF     0x03 /* start of frame */
+#define CAN_ERR_PROT_LOC_ID28_21 0x02 /* ID bits 28 - 21 (SFF: 10 - 3) */
+#define CAN_ERR_PROT_LOC_ID20_18 0x06 /* ID bits 20 - 18 (SFF: 2 - 0 )*/
+#define CAN_ERR_PROT_LOC_SRTR    0x04 /* substitute RTR (SFF: RTR) */
+#define CAN_ERR_PROT_LOC_IDE     0x05 /* identifier extension */
+#define CAN_ERR_PROT_LOC_ID17_13 0x07 /* ID bits 17-13 */
+#define CAN_ERR_PROT_LOC_ID12_05 0x0F /* ID bits 12-5 */
+#define CAN_ERR_PROT_LOC_ID04_00 0x0E /* ID bits 4-0 */
+#define CAN_ERR_PROT_LOC_RTR     0x0C /* RTR */
+#define CAN_ERR_PROT_LOC_RES1    0x0D /* reserved bit 1 */
+#define CAN_ERR_PROT_LOC_RES0    0x09 /* reserved bit 0 */
+#define CAN_ERR_PROT_LOC_DLC     0x0B /* data length code */
+#define CAN_ERR_PROT_LOC_DATA    0x0A /* data section */
+#define CAN_ERR_PROT_LOC_CRC_SEQ 0x08 /* CRC sequence */
+#define CAN_ERR_PROT_LOC_CRC_DEL 0x18 /* CRC delimiter */
+#define CAN_ERR_PROT_LOC_ACK     0x19 /* ACK slot */
+#define CAN_ERR_PROT_LOC_ACK_DEL 0x1B /* ACK delimiter */
+#define CAN_ERR_PROT_LOC_EOF     0x1A /* end of frame */
+#define CAN_ERR_PROT_LOC_INTERM  0x12 /* intermission */
+
+/* error status of CAN-transceiver / data[4] */
+/*                                             CANH CANL */
+#define CAN_ERR_TRX_UNSPEC             0x00 /* 0000 0000 */
+#define CAN_ERR_TRX_CANH_NO_WIRE       0x04 /* 0000 0100 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_BAT  0x05 /* 0000 0101 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_VCC  0x06 /* 0000 0110 */
+#define CAN_ERR_TRX_CANH_SHORT_TO_GND  0x07 /* 0000 0111 */
+#define CAN_ERR_TRX_CANL_NO_WIRE       0x40 /* 0100 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_BAT  0x50 /* 0101 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_VCC  0x60 /* 0110 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_GND  0x70 /* 0111 0000 */
+#define CAN_ERR_TRX_CANL_SHORT_TO_CANH 0x80 /* 1000 0000 */
+
+/* controller specific additional information / data[5..7] */
+
+#endif /* _UAPI_CAN_ERROR_H */
diff --git a/canutils/include/linux/can/gw.h b/canutils/include/linux/can/gw.h
new file mode 100644
index 0000000000..e4f0957554
--- /dev/null
+++ b/canutils/include/linux/can/gw.h
@@ -0,0 +1,222 @@
+/* SPDX-License-Identifier: ((GPL-2.0-only WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * linux/can/gw.h
+ *
+ * Definitions for CAN frame Gateway/Router/Bridge
+ *
+ * Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ * Copyright (c) 2011 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _UAPI_CAN_GW_H
+#define _UAPI_CAN_GW_H
+
+#include <linux/types.h>
+#include <linux/can.h>
+
+struct rtcanmsg {
+	__u8  can_family;
+	__u8  gwtype;
+	__u16 flags;
+};
+
+/* CAN gateway types */
+enum {
+	CGW_TYPE_UNSPEC,
+	CGW_TYPE_CAN_CAN,	/* CAN->CAN routing */
+	__CGW_TYPE_MAX
+};
+
+#define CGW_TYPE_MAX (__CGW_TYPE_MAX - 1)
+
+/* CAN rtnetlink attribute definitions */
+enum {
+	CGW_UNSPEC,
+	CGW_MOD_AND,	/* CAN frame modification binary AND */
+	CGW_MOD_OR,	/* CAN frame modification binary OR */
+	CGW_MOD_XOR,	/* CAN frame modification binary XOR */
+	CGW_MOD_SET,	/* CAN frame modification set alternate values */
+	CGW_CS_XOR,	/* set data[] XOR checksum into data[index] */
+	CGW_CS_CRC8,	/* set data[] CRC8 checksum into data[index] */
+	CGW_HANDLED,	/* number of handled CAN frames */
+	CGW_DROPPED,	/* number of dropped CAN frames */
+	CGW_SRC_IF,	/* ifindex of source network interface */
+	CGW_DST_IF,	/* ifindex of destination network interface */
+	CGW_FILTER,	/* specify struct can_filter on source CAN device */
+	CGW_DELETED,	/* number of deleted CAN frames (see max_hops param) */
+	CGW_LIM_HOPS,	/* limit the number of hops of this specific rule */
+	CGW_MOD_UID,	/* user defined identifier for modification updates */
+	CGW_FDMOD_AND,	/* CAN FD frame modification binary AND */
+	CGW_FDMOD_OR,	/* CAN FD frame modification binary OR */
+	CGW_FDMOD_XOR,	/* CAN FD frame modification binary XOR */
+	CGW_FDMOD_SET,	/* CAN FD frame modification set alternate values */
+	__CGW_MAX
+};
+
+#define CGW_MAX (__CGW_MAX - 1)
+
+#define CGW_FLAGS_CAN_ECHO 0x01
+#define CGW_FLAGS_CAN_SRC_TSTAMP 0x02
+#define CGW_FLAGS_CAN_IIF_TX_OK 0x04
+#define CGW_FLAGS_CAN_FD 0x08
+
+#define CGW_MOD_FUNCS 4 /* AND OR XOR SET */
+
+/* CAN frame elements that are affected by curr. 3 CAN frame modifications */
+#define CGW_MOD_ID	0x01
+#define CGW_MOD_DLC	0x02		/* Classical CAN data length code */
+#define CGW_MOD_LEN	CGW_MOD_DLC	/* CAN FD (plain) data length */
+#define CGW_MOD_DATA	0x04
+#define CGW_MOD_FLAGS	0x08		/* CAN FD flags */
+
+#define CGW_FRAME_MODS 4 /* ID DLC/LEN DATA FLAGS */
+
+#define MAX_MODFUNCTIONS (CGW_MOD_FUNCS * CGW_FRAME_MODS)
+
+struct cgw_frame_mod {
+	struct can_frame cf;
+	__u8 modtype;
+} __attribute__((packed));
+
+struct cgw_fdframe_mod {
+	struct canfd_frame cf;
+	__u8 modtype;
+} __attribute__((packed));
+
+#define CGW_MODATTR_LEN sizeof(struct cgw_frame_mod)
+#define CGW_FDMODATTR_LEN sizeof(struct cgw_fdframe_mod)
+
+struct cgw_csum_xor {
+	__s8 from_idx;
+	__s8 to_idx;
+	__s8 result_idx;
+	__u8 init_xor_val;
+} __attribute__((packed));
+
+struct cgw_csum_crc8 {
+	__s8 from_idx;
+	__s8 to_idx;
+	__s8 result_idx;
+	__u8 init_crc_val;
+	__u8 final_xor_val;
+	__u8 crctab[256];
+	__u8 profile;
+	__u8 profile_data[20];
+} __attribute__((packed));
+
+/* length of checksum operation parameters. idx = index in CAN frame data[] */
+#define CGW_CS_XOR_LEN  sizeof(struct cgw_csum_xor)
+#define CGW_CS_CRC8_LEN  sizeof(struct cgw_csum_crc8)
+
+/* CRC8 profiles (compute CRC for additional data elements - see below) */
+enum {
+	CGW_CRC8PRF_UNSPEC,
+	CGW_CRC8PRF_1U8,	/* compute one additional u8 value */
+	CGW_CRC8PRF_16U8,	/* u8 value table indexed by data[1] & 0xF */
+	CGW_CRC8PRF_SFFID_XOR,	/* (can_id & 0xFF) ^ (can_id >> 8 & 0xFF) */
+	__CGW_CRC8PRF_MAX
+};
+
+#define CGW_CRC8PRF_MAX (__CGW_CRC8PRF_MAX - 1)
+
+/*
+ * CAN rtnetlink attribute contents in detail
+ *
+ * CGW_XXX_IF (length 4 bytes):
+ * Sets an interface index for source/destination network interfaces.
+ * For the CAN->CAN gwtype the indices of _two_ CAN interfaces are mandatory.
+ *
+ * CGW_FILTER (length 8 bytes):
+ * Sets a CAN receive filter for the gateway job specified by the
+ * struct can_filter described in include/linux/can.h
+ *
+ * CGW_MOD_(AND|OR|XOR|SET) (length 17 bytes):
+ * Specifies a modification that's done to a received CAN frame before it is
+ * send out to the destination interface.
+ *
+ * <struct can_frame> data used as operator
+ * <u8> affected CAN frame elements
+ *
+ * CGW_LIM_HOPS (length 1 byte):
+ * Limit the number of hops of this specific rule. Usually the received CAN
+ * frame can be processed as much as 'max_hops' times (which is given at module
+ * load time of the can-gw module). This value is used to reduce the number of
+ * possible hops for this gateway rule to a value smaller then max_hops.
+ *
+ * CGW_MOD_UID (length 4 bytes):
+ * Optional non-zero user defined routing job identifier to alter existing
+ * modification settings at runtime.
+ *
+ * CGW_CS_XOR (length 4 bytes):
+ * Set a simple XOR checksum starting with an initial value into
+ * data[result-idx] using data[start-idx] .. data[end-idx]
+ *
+ * The XOR checksum is calculated like this:
+ *
+ * xor = init_xor_val
+ *
+ * for (i = from_idx .. to_idx)
+ *      xor ^= can_frame.data[i]
+ *
+ * can_frame.data[ result_idx ] = xor
+ *
+ * CGW_CS_CRC8 (length 282 bytes):
+ * Set a CRC8 value into data[result-idx] using a given 256 byte CRC8 table,
+ * a given initial value and a defined input data[start-idx] .. data[end-idx].
+ * Finally the result value is XOR'ed with the final_xor_val.
+ *
+ * The CRC8 checksum is calculated like this:
+ *
+ * crc = init_crc_val
+ *
+ * for (i = from_idx .. to_idx)
+ *      crc = crctab[ crc ^ can_frame.data[i] ]
+ *
+ * can_frame.data[ result_idx ] = crc ^ final_xor_val
+ *
+ * The calculated CRC may contain additional source data elements that can be
+ * defined in the handling of 'checksum profiles' e.g. shown in AUTOSAR specs
+ * like http://www.autosar.org/download/R4.0/AUTOSAR_SWS_E2ELibrary.pdf
+ * E.g. the profile_data[] may contain additional u8 values (called DATA_IDs)
+ * that are used depending on counter values inside the CAN frame data[].
+ * So far only three profiles have been implemented for illustration.
+ *
+ * Remark: In general the attribute data is a linear buffer.
+ *         Beware of sending unpacked or aligned structs!
+ */
+
+#endif /* !_UAPI_CAN_GW_H */
diff --git a/canutils/include/linux/can/isotp.h b/canutils/include/linux/can/isotp.h
new file mode 100644
index 0000000000..439c982f7e
--- /dev/null
+++ b/canutils/include/linux/can/isotp.h
@@ -0,0 +1,182 @@
+/* SPDX-License-Identifier: ((GPL-2.0-only WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * linux/can/isotp.h
+ *
+ * Definitions for isotp CAN sockets (ISO 15765-2:2016)
+ *
+ * Copyright (c) 2020 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _UAPI_CAN_ISOTP_H
+#define _UAPI_CAN_ISOTP_H
+
+#include <linux/types.h>
+#include <linux/can.h>
+
+#define SOL_CAN_ISOTP (SOL_CAN_BASE + CAN_ISOTP)
+
+/* for socket options affecting the socket (not the global system) */
+
+#define CAN_ISOTP_OPTS		1	/* pass struct can_isotp_options */
+
+#define CAN_ISOTP_RECV_FC	2	/* pass struct can_isotp_fc_options */
+
+/* sockopts to force stmin timer values for protocol regression tests */
+
+#define CAN_ISOTP_TX_STMIN	3	/* pass __u32 value in nano secs    */
+					/* use this time instead of value   */
+					/* provided in FC from the receiver */
+
+#define CAN_ISOTP_RX_STMIN	4	/* pass __u32 value in nano secs   */
+					/* ignore received CF frames which */
+					/* timestamps differ less than val */
+
+#define CAN_ISOTP_LL_OPTS	5	/* pass struct can_isotp_ll_options */
+
+struct can_isotp_options {
+
+	__u32 flags;		/* set flags for isotp behaviour.	*/
+				/* __u32 value : flags see below	*/
+
+	__u32 frame_txtime;	/* frame transmission time (N_As/N_Ar)	*/
+				/* __u32 value : time in nano secs	*/
+
+	__u8  ext_address;	/* set address for extended addressing	*/
+				/* __u8 value : extended address	*/
+
+	__u8  txpad_content;	/* set content of padding byte (tx)	*/
+				/* __u8 value : content	on tx path	*/
+
+	__u8  rxpad_content;	/* set content of padding byte (rx)	*/
+				/* __u8 value : content	on rx path	*/
+
+	__u8  rx_ext_address;	/* set address for extended addressing	*/
+				/* __u8 value : extended address (rx)	*/
+};
+
+struct can_isotp_fc_options {
+
+	__u8  bs;		/* blocksize provided in FC frame	*/
+				/* __u8 value : blocksize. 0 = off	*/
+
+	__u8  stmin;		/* separation time provided in FC frame	*/
+				/* __u8 value :				*/
+				/* 0x00 - 0x7F : 0 - 127 ms		*/
+				/* 0x80 - 0xF0 : reserved		*/
+				/* 0xF1 - 0xF9 : 100 us - 900 us	*/
+				/* 0xFA - 0xFF : reserved		*/
+
+	__u8  wftmax;		/* max. number of wait frame transmiss.	*/
+				/* __u8 value : 0 = omit FC N_PDU WT	*/
+};
+
+struct can_isotp_ll_options {
+
+	__u8  mtu;		/* generated & accepted CAN frame type	*/
+				/* __u8 value :				*/
+				/* CAN_MTU   (16) -> standard CAN 2.0	*/
+				/* CANFD_MTU (72) -> CAN FD frame	*/
+
+	__u8  tx_dl;		/* tx link layer data length in bytes	*/
+				/* (configured maximum payload length)	*/
+				/* __u8 value : 8,12,16,20,24,32,48,64	*/
+				/* => rx path supports all LL_DL values */
+
+	__u8  tx_flags;		/* set into struct canfd_frame.flags	*/
+				/* at frame creation: e.g. CANFD_BRS	*/
+				/* Obsolete when the BRS flag is fixed	*/
+				/* by the CAN netdriver configuration	*/
+};
+
+/* flags for isotp behaviour */
+
+#define CAN_ISOTP_LISTEN_MODE	0x0001	/* listen only (do not send FC) */
+#define CAN_ISOTP_EXTEND_ADDR	0x0002	/* enable extended addressing */
+#define CAN_ISOTP_TX_PADDING	0x0004	/* enable CAN frame padding tx path */
+#define CAN_ISOTP_RX_PADDING	0x0008	/* enable CAN frame padding rx path */
+#define CAN_ISOTP_CHK_PAD_LEN	0x0010	/* check received CAN frame padding */
+#define CAN_ISOTP_CHK_PAD_DATA	0x0020	/* check received CAN frame padding */
+#define CAN_ISOTP_HALF_DUPLEX	0x0040	/* half duplex error state handling */
+#define CAN_ISOTP_FORCE_TXSTMIN	0x0080	/* ignore stmin from received FC */
+#define CAN_ISOTP_FORCE_RXSTMIN	0x0100	/* ignore CFs depending on rx stmin */
+#define CAN_ISOTP_RX_EXT_ADDR	0x0200	/* different rx extended addressing */
+#define CAN_ISOTP_WAIT_TX_DONE	0x0400	/* wait for tx completion */
+#define CAN_ISOTP_SF_BROADCAST	0x0800	/* 1-to-N functional addressing */
+#define CAN_ISOTP_CF_BROADCAST	0x1000	/* 1-to-N transmission w/o FC */
+
+/* protocol machine default values */
+
+#define CAN_ISOTP_DEFAULT_FLAGS		0
+#define CAN_ISOTP_DEFAULT_EXT_ADDRESS	0x00
+#define CAN_ISOTP_DEFAULT_PAD_CONTENT	0xCC /* prevent bit-stuffing */
+#define CAN_ISOTP_DEFAULT_FRAME_TXTIME	50000 /* 50 micro seconds */
+#define CAN_ISOTP_DEFAULT_RECV_BS	0
+#define CAN_ISOTP_DEFAULT_RECV_STMIN	0x00
+#define CAN_ISOTP_DEFAULT_RECV_WFTMAX	0
+
+/*
+ * Remark on CAN_ISOTP_DEFAULT_RECV_* values:
+ *
+ * We can strongly assume, that the Linux Kernel implementation of
+ * CAN_ISOTP is capable to run with BS=0, STmin=0 and WFTmax=0.
+ * But as we like to be able to behave as a commonly available ECU,
+ * these default settings can be changed via sockopts.
+ * For that reason the STmin value is intentionally _not_ checked for
+ * consistency and copied directly into the flow control (FC) frame.
+ */
+
+/* link layer default values => make use of Classical CAN frames */
+
+#define CAN_ISOTP_DEFAULT_LL_MTU	CAN_MTU
+#define CAN_ISOTP_DEFAULT_LL_TX_DL	CAN_MAX_DLEN
+#define CAN_ISOTP_DEFAULT_LL_TX_FLAGS	0
+
+/*
+ * The CAN_ISOTP_DEFAULT_FRAME_TXTIME has become a non-zero value as
+ * it only makes sense for isotp implementation tests to run without
+ * a N_As value. As user space applications usually do not set the
+ * frame_txtime element of struct can_isotp_options the new in-kernel
+ * default is very likely overwritten with zero when the sockopt()
+ * CAN_ISOTP_OPTS is invoked.
+ * To make sure that a N_As value of zero is only set intentional the
+ * value '0' is now interpreted as 'do not change the current value'.
+ * When a frame_txtime of zero is required for testing purposes this
+ * CAN_ISOTP_FRAME_TXTIME_ZERO u32 value has to be set in frame_txtime.
+ */
+#define CAN_ISOTP_FRAME_TXTIME_ZERO	0xFFFFFFFF
+
+#endif /* !_UAPI_CAN_ISOTP_H */
diff --git a/canutils/include/linux/can/j1939.h b/canutils/include/linux/can/j1939.h
new file mode 100644
index 0000000000..38936460f6
--- /dev/null
+++ b/canutils/include/linux/can/j1939.h
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * j1939.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _UAPI_CAN_J1939_H_
+#define _UAPI_CAN_J1939_H_
+
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/can.h>
+
+#define J1939_MAX_UNICAST_ADDR 0xfd
+#define J1939_IDLE_ADDR 0xfe
+#define J1939_NO_ADDR 0xff		/* == broadcast or no addr */
+#define J1939_NO_NAME 0
+#define J1939_PGN_REQUEST 0x0ea00		/* Request PG */
+#define J1939_PGN_ADDRESS_CLAIMED 0x0ee00	/* Address Claimed */
+#define J1939_PGN_ADDRESS_COMMANDED 0x0fed8	/* Commanded Address */
+#define J1939_PGN_PDU1_MAX 0x3ff00
+#define J1939_PGN_MAX 0x3ffff
+#define J1939_NO_PGN 0x40000
+
+/* J1939 Parameter Group Number
+ *
+ * bit 0-7	: PDU Specific (PS)
+ * bit 8-15	: PDU Format (PF)
+ * bit 16	: Data Page (DP)
+ * bit 17	: Reserved (R)
+ * bit 19-31	: set to zero
+ */
+typedef __u32 pgn_t;
+
+/* J1939 Priority
+ *
+ * bit 0-2	: Priority (P)
+ * bit 3-7	: set to zero
+ */
+typedef __u8 priority_t;
+
+/* J1939 NAME
+ *
+ * bit 0-20	: Identity Number
+ * bit 21-31	: Manufacturer Code
+ * bit 32-34	: ECU Instance
+ * bit 35-39	: Function Instance
+ * bit 40-47	: Function
+ * bit 48	: Reserved
+ * bit 49-55	: Vehicle System
+ * bit 56-59	: Vehicle System Instance
+ * bit 60-62	: Industry Group
+ * bit 63	: Arbitrary Address Capable
+ */
+typedef __u64 name_t;
+
+/* J1939 socket options */
+#define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
+enum {
+	SO_J1939_FILTER = 1,	/* set filters */
+	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
+	SO_J1939_SEND_PRIO = 3,
+	SO_J1939_ERRQUEUE = 4,
+};
+
+enum {
+	SCM_J1939_DEST_ADDR = 1,
+	SCM_J1939_DEST_NAME = 2,
+	SCM_J1939_PRIO = 3,
+	SCM_J1939_ERRQUEUE = 4,
+};
+
+enum {
+	J1939_NLA_PAD,
+	J1939_NLA_BYTES_ACKED,
+	J1939_NLA_TOTAL_SIZE,
+	J1939_NLA_PGN,
+	J1939_NLA_SRC_NAME,
+	J1939_NLA_DEST_NAME,
+	J1939_NLA_SRC_ADDR,
+	J1939_NLA_DEST_ADDR,
+};
+
+enum {
+	J1939_EE_INFO_NONE,
+	J1939_EE_INFO_TX_ABORT,
+	J1939_EE_INFO_RX_RTS,
+	J1939_EE_INFO_RX_DPO,
+	J1939_EE_INFO_RX_ABORT,
+};
+
+struct j1939_filter {
+	name_t name;
+	name_t name_mask;
+	pgn_t pgn;
+	pgn_t pgn_mask;
+	__u8 addr;
+	__u8 addr_mask;
+};
+
+#define J1939_FILTER_MAX 512 /* maximum number of j1939_filter set via setsockopt() */
+
+#endif /* !_UAPI_CAN_J1939_H_ */
diff --git a/canutils/include/linux/can/netlink.h b/canutils/include/linux/can/netlink.h
new file mode 100644
index 0000000000..f730d443b9
--- /dev/null
+++ b/canutils/include/linux/can/netlink.h
@@ -0,0 +1,145 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+/*
+ * linux/can/netlink.h
+ *
+ * Definitions for the CAN netlink interface
+ *
+ * Copyright (c) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_CAN_NETLINK_H
+#define _UAPI_CAN_NETLINK_H
+
+#include <linux/types.h>
+
+/*
+ * CAN bit-timing parameters
+ *
+ * For further information, please read chapter "8 BIT TIMING
+ * REQUIREMENTS" of the "Bosch CAN Specification version 2.0"
+ * at http://www.semiconductors.bosch.de/pdf/can2spec.pdf.
+ */
+struct can_bittiming {
+	__u32 bitrate;		/* Bit-rate in bits/second */
+	__u32 sample_point;	/* Sample point in one-tenth of a percent */
+	__u32 tq;		/* Time quanta (TQ) in nanoseconds */
+	__u32 prop_seg;		/* Propagation segment in TQs */
+	__u32 phase_seg1;	/* Phase buffer segment 1 in TQs */
+	__u32 phase_seg2;	/* Phase buffer segment 2 in TQs */
+	__u32 sjw;		/* Synchronisation jump width in TQs */
+	__u32 brp;		/* Bit-rate prescaler */
+};
+
+/*
+ * CAN hardware-dependent bit-timing constant
+ *
+ * Used for calculating and checking bit-timing parameters
+ */
+struct can_bittiming_const {
+	char name[16];		/* Name of the CAN controller hardware */
+	__u32 tseg1_min;	/* Time segment 1 = prop_seg + phase_seg1 */
+	__u32 tseg1_max;
+	__u32 tseg2_min;	/* Time segment 2 = phase_seg2 */
+	__u32 tseg2_max;
+	__u32 sjw_max;		/* Synchronisation jump width */
+	__u32 brp_min;		/* Bit-rate prescaler */
+	__u32 brp_max;
+	__u32 brp_inc;
+};
+
+/*
+ * CAN clock parameters
+ */
+struct can_clock {
+	__u32 freq;		/* CAN system clock frequency in Hz */
+};
+
+/*
+ * CAN operational and error states
+ */
+enum can_state {
+	CAN_STATE_ERROR_ACTIVE = 0,	/* RX/TX error count < 96 */
+	CAN_STATE_ERROR_WARNING,	/* RX/TX error count < 128 */
+	CAN_STATE_ERROR_PASSIVE,	/* RX/TX error count < 256 */
+	CAN_STATE_BUS_OFF,		/* RX/TX error count >= 256 */
+	CAN_STATE_STOPPED,		/* Device is stopped */
+	CAN_STATE_SLEEPING,		/* Device is sleeping */
+	CAN_STATE_MAX
+};
+
+/*
+ * CAN bus error counters
+ */
+struct can_berr_counter {
+	__u16 txerr;
+	__u16 rxerr;
+};
+
+/*
+ * CAN controller mode
+ */
+struct can_ctrlmode {
+	__u32 mask;
+	__u32 flags;
+};
+
+#define CAN_CTRLMODE_LOOPBACK		0x01	/* Loopback mode */
+#define CAN_CTRLMODE_LISTENONLY		0x02	/* Listen-only mode */
+#define CAN_CTRLMODE_3_SAMPLES		0x04	/* Triple sampling mode */
+#define CAN_CTRLMODE_ONE_SHOT		0x08	/* One-Shot mode */
+#define CAN_CTRLMODE_BERR_REPORTING	0x10	/* Bus-error reporting */
+#define CAN_CTRLMODE_FD			0x20	/* CAN FD mode */
+#define CAN_CTRLMODE_PRESUME_ACK	0x40	/* Ignore missing CAN ACKs */
+#define CAN_CTRLMODE_FD_NON_ISO		0x80	/* CAN FD in non-ISO mode */
+#define CAN_CTRLMODE_CC_LEN8_DLC	0x100	/* Classic CAN DLC option */
+
+/*
+ * CAN device statistics
+ */
+struct can_device_stats {
+	__u32 bus_error;	/* Bus errors */
+	__u32 error_warning;	/* Changes to error warning state */
+	__u32 error_passive;	/* Changes to error passive state */
+	__u32 bus_off;		/* Changes to bus off state */
+	__u32 arbitration_lost; /* Arbitration lost errors */
+	__u32 restarts;		/* CAN controller re-starts */
+};
+
+/*
+ * CAN netlink interface
+ */
+enum {
+	IFLA_CAN_UNSPEC,
+	IFLA_CAN_BITTIMING,
+	IFLA_CAN_BITTIMING_CONST,
+	IFLA_CAN_CLOCK,
+	IFLA_CAN_STATE,
+	IFLA_CAN_CTRLMODE,
+	IFLA_CAN_RESTART_MS,
+	IFLA_CAN_RESTART,
+	IFLA_CAN_BERR_COUNTER,
+	IFLA_CAN_DATA_BITTIMING,
+	IFLA_CAN_DATA_BITTIMING_CONST,
+	IFLA_CAN_TERMINATION,
+	IFLA_CAN_TERMINATION_CONST,
+	IFLA_CAN_BITRATE_CONST,
+	IFLA_CAN_DATA_BITRATE_CONST,
+	IFLA_CAN_BITRATE_MAX,
+	__IFLA_CAN_MAX
+};
+
+#define IFLA_CAN_MAX	(__IFLA_CAN_MAX - 1)
+
+/* u16 termination range: 1..65535 Ohms */
+#define CAN_TERMINATION_DISABLED 0
+
+#endif /* !_UAPI_CAN_NETLINK_H */
diff --git a/canutils/include/linux/can/raw.h b/canutils/include/linux/can/raw.h
new file mode 100644
index 0000000000..3386aa81fd
--- /dev/null
+++ b/canutils/include/linux/can/raw.h
@@ -0,0 +1,67 @@
+/* SPDX-License-Identifier: ((GPL-2.0-only WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * linux/can/raw.h
+ *
+ * Definitions for raw CAN sockets
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _UAPI_CAN_RAW_H
+#define _UAPI_CAN_RAW_H
+
+#include <linux/can.h>
+
+#define SOL_CAN_RAW (SOL_CAN_BASE + CAN_RAW)
+enum {
+	SCM_CAN_RAW_ERRQUEUE = 1,
+};
+
+/* for socket options affecting the socket (not the global system) */
+
+enum {
+	CAN_RAW_FILTER = 1,	/* set 0 .. n can_filter(s)          */
+	CAN_RAW_ERR_FILTER,	/* set filter for error frames       */
+	CAN_RAW_LOOPBACK,	/* local loopback (default:on)       */
+	CAN_RAW_RECV_OWN_MSGS,	/* receive my own msgs (default:off) */
+	CAN_RAW_FD_FRAMES,	/* allow CAN FD frames (default:off) */
+	CAN_RAW_JOIN_FILTERS,	/* all filters must match to trigger */
+};
+
+#endif /* !_UAPI_CAN_RAW_H */
diff --git a/canutils/include/linux/can/vxcan.h b/canutils/include/linux/can/vxcan.h
new file mode 100644
index 0000000000..4fa9d8777a
--- /dev/null
+++ b/canutils/include/linux/can/vxcan.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
+#ifndef _UAPI_CAN_VXCAN_H
+#define _UAPI_CAN_VXCAN_H
+
+enum {
+	VXCAN_INFO_UNSPEC,
+	VXCAN_INFO_PEER,
+
+	__VXCAN_INFO_MAX
+#define VXCAN_INFO_MAX	(__VXCAN_INFO_MAX - 1)
+};
+
+#endif
diff --git a/canutils/include/linux/errqueue.h b/canutils/include/linux/errqueue.h
new file mode 100644
index 0000000000..c0151200f7
--- /dev/null
+++ b/canutils/include/linux/errqueue.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _UAPI_LINUX_ERRQUEUE_H
+#define _UAPI_LINUX_ERRQUEUE_H
+
+#include <linux/types.h>
+
+struct sock_extended_err {
+	__u32	ee_errno;	
+	__u8	ee_origin;
+	__u8	ee_type;
+	__u8	ee_code;
+	__u8	ee_pad;
+	__u32   ee_info;
+	__u32   ee_data;
+};
+
+#define SO_EE_ORIGIN_NONE	0
+#define SO_EE_ORIGIN_LOCAL	1
+#define SO_EE_ORIGIN_ICMP	2
+#define SO_EE_ORIGIN_ICMP6	3
+#define SO_EE_ORIGIN_TXSTATUS	4
+#define SO_EE_ORIGIN_ZEROCOPY	5
+#define SO_EE_ORIGIN_TXTIME	6
+#define SO_EE_ORIGIN_TIMESTAMPING SO_EE_ORIGIN_TXSTATUS
+
+#define SO_EE_OFFENDER(ee)	((struct sockaddr*)((ee)+1))
+
+#define SO_EE_CODE_ZEROCOPY_COPIED	1
+
+#define SO_EE_CODE_TXTIME_INVALID_PARAM	1
+#define SO_EE_CODE_TXTIME_MISSED	2
+
+/**
+ *	struct scm_timestamping - timestamps exposed through cmsg
+ *
+ *	The timestamping interfaces SO_TIMESTAMPING, MSG_TSTAMP_*
+ *	communicate network timestamps by passing this struct in a cmsg with
+ *	recvmsg(). See Documentation/networking/timestamping.txt for details.
+ */
+struct scm_timestamping {
+	struct timespec ts[3];
+};
+
+/* The type of scm_timestamping, passed in sock_extended_err ee_info.
+ * This defines the type of ts[0]. For SCM_TSTAMP_SND only, if ts[0]
+ * is zero, then this is a hardware timestamp and recorded in ts[2].
+ */
+enum {
+	SCM_TSTAMP_SND,		/* driver passed skb to NIC, or HW */
+	SCM_TSTAMP_SCHED,	/* data entered the packet scheduler */
+	SCM_TSTAMP_ACK,		/* data acknowledged by peer */
+};
+
+#endif /* _UAPI_LINUX_ERRQUEUE_H */
diff --git a/canutils/include/linux/kernel.h b/canutils/include/linux/kernel.h
new file mode 100644
index 0000000000..b7cbdb3625
--- /dev/null
+++ b/canutils/include/linux/kernel.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _LINUX_KERNEL_H
+#define _LINUX_KERNEL_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+#include <linux/can.h>
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint32_t __le32;
+
+struct mcp251xfd_mem;
+
+struct regmap {
+	struct mcp251xfd_mem *mem;
+};
+
+#define pr_info(...) fprintf(stdout, ## __VA_ARGS__)
+#define pr_cont(...) fprintf(stdout, ## __VA_ARGS__)
+#define netdev_info(ndev, ...) fprintf(stdout, ## __VA_ARGS__)
+#define BUILD_BUG_ON(...)
+
+#define BITS_PER_LONG (sizeof(long) * 8)
+
+#define ____cacheline_aligned
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+int regmap_bulk_read(struct regmap *map, unsigned int reg,
+		     void *val, size_t val_count);
+
+#define SZ_2K				0x00000800
+
+#define __packed                        __attribute__((__packed__))
+
+#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))
+
+#define BIT(nr)			(UL(1) << (nr))
+
+#define __stringify_1(x...)	#x
+#define __stringify(x...)	__stringify_1(x)
+
+#ifdef __ASSEMBLY__
+#define _AC(X,Y)	X
+#define _AT(T,X)	X
+#else
+#define __AC(X,Y)	(X##Y)
+#define _AC(X,Y)	__AC(X,Y)
+#define _AT(T,X)	((T)(X))
+#endif
+
+#define _UL(x)		(_AC(x, UL))
+#define _ULL(x)		(_AC(x, ULL))
+
+#define UL(x)		(_UL(x))
+#define ULL(x)		(_ULL(x))
+
+#define GENMASK(h, l) \
+	(((~UL(0)) - (UL(1) << (l)) + 1) & \
+	 (~UL(0) >> (BITS_PER_LONG - 1 - (h))))
+
+#define __bf_shf(x) (__builtin_ffsll(x) - 1)
+
+#define FIELD_PREP(_mask, _val)						\
+	({								\
+		((typeof(_mask))(_val) << __bf_shf(_mask)) & (_mask);	\
+	})
+
+#define FIELD_GET(_mask, _reg)						\
+	({								\
+		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
+	})
+
+#define min_t(type, x, y) ({			\
+	type __min1 = (x);			\
+	type __min2 = (y);			\
+	__min1 < __min2 ? __min1 : __min2; })
+
+#define get_canfd_dlc(i)	(min_t(__u8, (i), CANFD_MAX_DLC))
+
+static const u8 dlc2len[] = {0, 1, 2, 3, 4, 5, 6, 7,
+			     8, 12, 16, 20, 24, 32, 48, 64};
+
+/* get data length from can_dlc with sanitized can_dlc */
+static inline u8 can_dlc2len(u8 can_dlc)
+{
+	return dlc2len[can_dlc & 0x0F];
+}
+
+#endif /* _LINUX_KERNEL_H */
diff --git a/canutils/include/linux/net_tstamp.h b/canutils/include/linux/net_tstamp.h
new file mode 100644
index 0000000000..e5b39721c6
--- /dev/null
+++ b/canutils/include/linux/net_tstamp.h
@@ -0,0 +1,162 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Userspace API for hardware time stamping of network packets
+ *
+ * Copyright (C) 2008,2009 Intel Corporation
+ * Author: Patrick Ohly <patrick.ohly@intel.com>
+ *
+ */
+
+#ifndef _NET_TIMESTAMPING_H
+#define _NET_TIMESTAMPING_H
+
+#include <linux/types.h>
+#include <linux/socket.h>   /* for SO_TIMESTAMPING */
+
+/* SO_TIMESTAMPING gets an integer bit field comprised of these values */
+enum {
+	SOF_TIMESTAMPING_TX_HARDWARE = (1<<0),
+	SOF_TIMESTAMPING_TX_SOFTWARE = (1<<1),
+	SOF_TIMESTAMPING_RX_HARDWARE = (1<<2),
+	SOF_TIMESTAMPING_RX_SOFTWARE = (1<<3),
+	SOF_TIMESTAMPING_SOFTWARE = (1<<4),
+	SOF_TIMESTAMPING_SYS_HARDWARE = (1<<5),
+	SOF_TIMESTAMPING_RAW_HARDWARE = (1<<6),
+	SOF_TIMESTAMPING_OPT_ID = (1<<7),
+	SOF_TIMESTAMPING_TX_SCHED = (1<<8),
+	SOF_TIMESTAMPING_TX_ACK = (1<<9),
+	SOF_TIMESTAMPING_OPT_CMSG = (1<<10),
+	SOF_TIMESTAMPING_OPT_TSONLY = (1<<11),
+	SOF_TIMESTAMPING_OPT_STATS = (1<<12),
+	SOF_TIMESTAMPING_OPT_PKTINFO = (1<<13),
+	SOF_TIMESTAMPING_OPT_TX_SWHW = (1<<14),
+
+	SOF_TIMESTAMPING_LAST = SOF_TIMESTAMPING_OPT_TX_SWHW,
+	SOF_TIMESTAMPING_MASK = (SOF_TIMESTAMPING_LAST - 1) |
+				 SOF_TIMESTAMPING_LAST
+};
+
+/*
+ * SO_TIMESTAMPING flags are either for recording a packet timestamp or for
+ * reporting the timestamp to user space.
+ * Recording flags can be set both via socket options and control messages.
+ */
+#define SOF_TIMESTAMPING_TX_RECORD_MASK	(SOF_TIMESTAMPING_TX_HARDWARE | \
+					 SOF_TIMESTAMPING_TX_SOFTWARE | \
+					 SOF_TIMESTAMPING_TX_SCHED | \
+					 SOF_TIMESTAMPING_TX_ACK)
+
+/**
+ * struct hwtstamp_config - %SIOCGHWTSTAMP and %SIOCSHWTSTAMP parameter
+ *
+ * @flags:	no flags defined right now, must be zero for %SIOCSHWTSTAMP
+ * @tx_type:	one of HWTSTAMP_TX_*
+ * @rx_filter:	one of HWTSTAMP_FILTER_*
+ *
+ * %SIOCGHWTSTAMP and %SIOCSHWTSTAMP expect a &struct ifreq with a
+ * ifr_data pointer to this structure.  For %SIOCSHWTSTAMP, if the
+ * driver or hardware does not support the requested @rx_filter value,
+ * the driver may use a more general filter mode.  In this case
+ * @rx_filter will indicate the actual mode on return.
+ */
+struct hwtstamp_config {
+	int flags;
+	int tx_type;
+	int rx_filter;
+};
+
+/* possible values for hwtstamp_config->tx_type */
+enum hwtstamp_tx_types {
+	/*
+	 * No outgoing packet will need hardware time stamping;
+	 * should a packet arrive which asks for it, no hardware
+	 * time stamping will be done.
+	 */
+	HWTSTAMP_TX_OFF,
+
+	/*
+	 * Enables hardware time stamping for outgoing packets;
+	 * the sender of the packet decides which are to be
+	 * time stamped by setting %SOF_TIMESTAMPING_TX_SOFTWARE
+	 * before sending the packet.
+	 */
+	HWTSTAMP_TX_ON,
+
+	/*
+	 * Enables time stamping for outgoing packets just as
+	 * HWTSTAMP_TX_ON does, but also enables time stamp insertion
+	 * directly into Sync packets. In this case, transmitted Sync
+	 * packets will not received a time stamp via the socket error
+	 * queue.
+	 */
+	HWTSTAMP_TX_ONESTEP_SYNC,
+};
+
+/* possible values for hwtstamp_config->rx_filter */
+enum hwtstamp_rx_filters {
+	/* time stamp no incoming packet at all */
+	HWTSTAMP_FILTER_NONE,
+
+	/* time stamp any incoming packet */
+	HWTSTAMP_FILTER_ALL,
+
+	/* return value: time stamp all packets requested plus some others */
+	HWTSTAMP_FILTER_SOME,
+
+	/* PTP v1, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_EVENT,
+	/* PTP v1, UDP, Sync packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_SYNC,
+	/* PTP v1, UDP, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ,
+	/* PTP v2, UDP, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_EVENT,
+	/* PTP v2, UDP, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_SYNC,
+	/* PTP v2, UDP, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ,
+
+	/* 802.AS1, Ethernet, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_EVENT,
+	/* 802.AS1, Ethernet, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_SYNC,
+	/* 802.AS1, Ethernet, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ,
+
+	/* PTP v2/802.AS1, any layer, any kind of event packet */
+	HWTSTAMP_FILTER_PTP_V2_EVENT,
+	/* PTP v2/802.AS1, any layer, Sync packet */
+	HWTSTAMP_FILTER_PTP_V2_SYNC,
+	/* PTP v2/802.AS1, any layer, Delay_req packet */
+	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ,
+
+	/* NTP, UDP, all versions and packet modes */
+	HWTSTAMP_FILTER_NTP_ALL,
+};
+
+/* SCM_TIMESTAMPING_PKTINFO control message */
+struct scm_ts_pktinfo {
+	__u32 if_index;
+	__u32 pkt_length;
+	__u32 reserved[2];
+};
+
+/*
+ * SO_TXTIME gets a struct sock_txtime with flags being an integer bit
+ * field comprised of these values.
+ */
+enum txtime_flags {
+	SOF_TXTIME_DEADLINE_MODE = (1 << 0),
+	SOF_TXTIME_REPORT_ERRORS = (1 << 1),
+
+	SOF_TXTIME_FLAGS_LAST = SOF_TXTIME_REPORT_ERRORS,
+	SOF_TXTIME_FLAGS_MASK = (SOF_TXTIME_FLAGS_LAST - 1) |
+				 SOF_TXTIME_FLAGS_LAST
+};
+
+struct sock_txtime {
+	__kernel_clockid_t	clockid;/* reference clockid */
+	__u32			flags;	/* as defined by enum txtime_flags */
+};
+
+#endif /* _NET_TIMESTAMPING_H */
diff --git a/canutils/include/linux/netlink.h b/canutils/include/linux/netlink.h
new file mode 100644
index 0000000000..8e8b8e7a7b
--- /dev/null
+++ b/canutils/include/linux/netlink.h
@@ -0,0 +1,252 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _UAPI__LINUX_NETLINK_H
+#define _UAPI__LINUX_NETLINK_H
+
+#include <linux/kernel.h>
+#include <linux/socket.h> /* for __kernel_sa_family_t */
+#include <linux/types.h>
+
+#define NETLINK_ROUTE		0	/* Routing/device hook				*/
+#define NETLINK_UNUSED		1	/* Unused number				*/
+#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
+#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
+#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
+#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
+#define NETLINK_XFRM		6	/* ipsec */
+#define NETLINK_SELINUX		7	/* SELinux event notifications */
+#define NETLINK_ISCSI		8	/* Open-iSCSI */
+#define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_CONNECTOR	11
+#define NETLINK_NETFILTER	12	/* netfilter subsystem */
+#define NETLINK_IP6_FW		13
+#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_GENERIC		16
+/* leave room for NETLINK_DM (DM Events) */
+#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
+#define NETLINK_ECRYPTFS	19
+#define NETLINK_RDMA		20
+#define NETLINK_CRYPTO		21	/* Crypto layer */
+#define NETLINK_SMC		22	/* SMC monitoring */
+
+#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
+
+#define MAX_LINKS 32		
+
+struct sockaddr_nl {
+	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
+	unsigned short	nl_pad;		/* zero		*/
+	__u32		nl_pid;		/* port ID	*/
+       	__u32		nl_groups;	/* multicast groups mask */
+};
+
+struct nlmsghdr {
+	__u32		nlmsg_len;	/* Length of message including header */
+	__u16		nlmsg_type;	/* Message content */
+	__u16		nlmsg_flags;	/* Additional flags */
+	__u32		nlmsg_seq;	/* Sequence number */
+	__u32		nlmsg_pid;	/* Sending process port ID */
+};
+
+/* Flags values */
+
+#define NLM_F_REQUEST		0x01	/* It is request message. 	*/
+#define NLM_F_MULTI		0x02	/* Multipart message, terminated by NLMSG_DONE */
+#define NLM_F_ACK		0x04	/* Reply with ack, with zero or error code */
+#define NLM_F_ECHO		0x08	/* Echo this request 		*/
+#define NLM_F_DUMP_INTR		0x10	/* Dump was inconsistent due to sequence change */
+#define NLM_F_DUMP_FILTERED	0x20	/* Dump was filtered as requested */
+
+/* Modifiers to GET request */
+#define NLM_F_ROOT	0x100	/* specify tree	root	*/
+#define NLM_F_MATCH	0x200	/* return all matching	*/
+#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/* Modifiers to NEW request */
+#define NLM_F_REPLACE	0x100	/* Override existing		*/
+#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
+#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
+#define NLM_F_APPEND	0x800	/* Add to end of list		*/
+
+/* Modifiers to DELETE request */
+#define NLM_F_NONREC	0x100	/* Do not delete recursively	*/
+
+/* Flags for ACK message */
+#define NLM_F_CAPPED	0x100	/* request was capped */
+#define NLM_F_ACK_TLVS	0x200	/* extended ACK TVLs were included */
+
+/*
+   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
+   4.4BSD CHANGE	NLM_F_REPLACE
+
+   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
+   Append		NLM_F_CREATE
+   Check		NLM_F_EXCL
+ */
+
+#define NLMSG_ALIGNTO	4U
+#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
+#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)
+#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
+#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
+#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
+				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
+#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
+			   (int)((nlh)->nlmsg_len) <= (len))
+#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
+
+#define NLMSG_NOOP		0x1	/* Nothing.		*/
+#define NLMSG_ERROR		0x2	/* Error		*/
+#define NLMSG_DONE		0x3	/* End of a dump	*/
+#define NLMSG_OVERRUN		0x4	/* Data lost		*/
+
+#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
+
+struct nlmsgerr {
+	int		error;
+	struct nlmsghdr msg;
+	/*
+	 * followed by the message contents unless NETLINK_CAP_ACK was set
+	 * or the ACK indicates success (error == 0)
+	 * message length is aligned with NLMSG_ALIGN()
+	 */
+	/*
+	 * followed by TLVs defined in enum nlmsgerr_attrs
+	 * if NETLINK_EXT_ACK was set
+	 */
+};
+
+/**
+ * enum nlmsgerr_attrs - nlmsgerr attributes
+ * @NLMSGERR_ATTR_UNUSED: unused
+ * @NLMSGERR_ATTR_MSG: error message string (string)
+ * @NLMSGERR_ATTR_OFFS: offset of the invalid attribute in the original
+ *	 message, counting from the beginning of the header (u32)
+ * @NLMSGERR_ATTR_COOKIE: arbitrary subsystem specific cookie to
+ *	be used - in the success case - to identify a created
+ *	object or operation or similar (binary)
+ * @__NLMSGERR_ATTR_MAX: number of attributes
+ * @NLMSGERR_ATTR_MAX: highest attribute number
+ */
+enum nlmsgerr_attrs {
+	NLMSGERR_ATTR_UNUSED,
+	NLMSGERR_ATTR_MSG,
+	NLMSGERR_ATTR_OFFS,
+	NLMSGERR_ATTR_COOKIE,
+
+	__NLMSGERR_ATTR_MAX,
+	NLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1
+};
+
+#define NETLINK_ADD_MEMBERSHIP		1
+#define NETLINK_DROP_MEMBERSHIP		2
+#define NETLINK_PKTINFO			3
+#define NETLINK_BROADCAST_ERROR		4
+#define NETLINK_NO_ENOBUFS		5
+#ifndef __KERNEL__
+#define NETLINK_RX_RING			6
+#define NETLINK_TX_RING			7
+#endif
+#define NETLINK_LISTEN_ALL_NSID		8
+#define NETLINK_LIST_MEMBERSHIPS	9
+#define NETLINK_CAP_ACK			10
+#define NETLINK_EXT_ACK			11
+#define NETLINK_GET_STRICT_CHK		12
+
+struct nl_pktinfo {
+	__u32	group;
+};
+
+struct nl_mmap_req {
+	unsigned int	nm_block_size;
+	unsigned int	nm_block_nr;
+	unsigned int	nm_frame_size;
+	unsigned int	nm_frame_nr;
+};
+
+struct nl_mmap_hdr {
+	unsigned int	nm_status;
+	unsigned int	nm_len;
+	__u32		nm_group;
+	/* credentials */
+	__u32		nm_pid;
+	__u32		nm_uid;
+	__u32		nm_gid;
+};
+
+#ifndef __KERNEL__
+enum nl_mmap_status {
+	NL_MMAP_STATUS_UNUSED,
+	NL_MMAP_STATUS_RESERVED,
+	NL_MMAP_STATUS_VALID,
+	NL_MMAP_STATUS_COPY,
+	NL_MMAP_STATUS_SKIP,
+};
+
+#define NL_MMAP_MSG_ALIGNMENT		NLMSG_ALIGNTO
+#define NL_MMAP_MSG_ALIGN(sz)		__ALIGN_KERNEL(sz, NL_MMAP_MSG_ALIGNMENT)
+#define NL_MMAP_HDRLEN			NL_MMAP_MSG_ALIGN(sizeof(struct nl_mmap_hdr))
+#endif
+
+#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED,
+};
+
+/*
+ *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ * |        Header       | Pad |     Payload       | Pad |
+ * |   (struct nlattr)   | ing |                   | ing |
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ *  <-------------- nlattr->nla_len -------------->
+ */
+
+struct nlattr {
+	__u16           nla_len;
+	__u16           nla_type;
+};
+
+/*
+ * nla_type (16 bits)
+ * +---+---+-------------------------------+
+ * | N | O | Attribute Type                |
+ * +---+---+-------------------------------+
+ * N := Carries nested attributes
+ * O := Payload stored in network byte order
+ *
+ * Note: The N and O flag are mutually exclusive.
+ */
+#define NLA_F_NESTED		(1 << 15)
+#define NLA_F_NET_BYTEORDER	(1 << 14)
+#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
+
+#define NLA_ALIGNTO		4
+#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
+#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
+
+/* Generic 32 bitflags attribute content sent to the kernel.
+ *
+ * The value is a bitmap that defines the values being set
+ * The selector is a bitmask that defines which value is legit
+ *
+ * Examples:
+ *  value = 0x0, and selector = 0x1
+ *  implies we are selecting bit 1 and we want to set its value to 0.
+ *
+ *  value = 0x2, and selector = 0x2
+ *  implies we are selecting bit 2 and we want to set its value to 1.
+ *
+ */
+struct nla_bitfield32 {
+	__u32 value;
+	__u32 selector;
+};
+
+#endif /* _UAPI__LINUX_NETLINK_H */
diff --git a/canutils/isotpdump.c b/canutils/isotpdump.c
new file mode 100644
index 0000000000..d22725ee6e
--- /dev/null
+++ b/canutils/isotpdump.c
@@ -0,0 +1,515 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotpdump.c - dump and explain ISO15765-2 protocol CAN frames
+ *
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <linux/sockios.h>
+
+#include "terminal.h"
+
+#define NO_CAN_ID 0xFFFFFFFFU
+
+const char fc_info [4][9] = { "CTS", "WT", "OVFLW", "reserved" };
+const int canfd_on = 1;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -x <addr>    (extended addressing mode. Use 'any' for all addresses)\n");
+	fprintf(stderr, "         -X <addr>    (extended addressing mode (rx addr). Use 'any' for all)\n");
+	fprintf(stderr, "         -c           (color mode)\n");
+	fprintf(stderr, "         -a           (print data also in ASCII-chars)\n");
+	fprintf(stderr, "         -t <type>    (timestamp: (a)bsolute/(d)elta/(z)ero/(A)bsolute w date)\n");
+	fprintf(stderr, "         -u           (print uds messages)\n");
+	fprintf(stderr, "\nCAN IDs and addresses are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "\nUDS output contains a flag which provides information about the type of the \n");
+	fprintf(stderr, "message.\n\n");
+	fprintf(stderr, "Flags:\n");
+	fprintf(stderr, "       [SRQ]  = Service Request\n");
+	fprintf(stderr, "       [PSR]  = Positive Service Response\n");
+	fprintf(stderr, "       [NRC]  = Negative Response Code\n");
+	fprintf(stderr, "       [???]  = Unknown (not specified)\n");
+	fprintf(stderr, "\n");
+}
+
+void print_uds_message(int service, int nrc)
+{
+	char *service_name;
+	char *flag = "[???]";
+
+	if ((service >= 0x50 && service <= 0x7E) || (service >= 0xC3 && service <= 0xC8)) {
+		flag = "[PSR]";
+		service = service - 0x40;
+	} else if ((service >= 0x10 && service <= 0x3E) ||
+		   (service >= 0x83 && service <= 0x88) ||
+		   (service >= 0xBA && service <= 0xBE))
+		flag = "[SRQ]";
+	
+	switch(service) {
+	case 0x10: service_name = "DiagnosticSessionControl"; break;
+	case 0x11: service_name = "ECUReset"; break;
+	case 0x14: service_name = "ClearDiagnosticInformation"; break;
+	case 0x19: service_name = "ReadDTCInformation"; break;
+	case 0x22: service_name = "ReadDataByIdentifier"; break;
+	case 0x23: service_name = "ReadMemoryByAddress"; break;
+	case 0x24: service_name = "ReadScalingDataByIdentifier"; break;
+	case 0x27: service_name = "SecurityAccess"; break;
+	case 0x28: service_name = "CommunicationControl"; break;
+	case 0x2A: service_name = "ReadDataByPeriodicIdentifier"; break;
+	case 0x2C: service_name = "DynamicallyDefineDataIdentifier"; break;
+	case 0x2E: service_name = "WriteDataByIdentifier"; break;
+	case 0x2F: service_name = "InputOutputControlByIdentifier"; break;
+	case 0x31: service_name = "RoutineControl"; break;
+	case 0x34: service_name = "RequestDownload"; break;
+	case 0x35: service_name = "RequestUpload"; break;
+	case 0x36: service_name = "TransferData"; break;
+	case 0x37: service_name = "RequestTransferExit"; break;
+	case 0x38: service_name = "RequestFileTransfer"; break;
+	case 0x3D: service_name = "WriteMemoryByAddress"; break;
+	case 0x3E: service_name = "TesterPresent"; break;
+	case 0x83: service_name = "AccessTimingParameter"; break;
+	case 0x84: service_name = "SecuredDataTransmission"; break;
+	case 0x85: service_name = "ControlDTCSetting"; break;
+	case 0x86: service_name = "ResponseOnEvent"; break;
+	case 0x87: service_name = "LinkControl"; break;
+	case 0x7F: flag = "[NRC]";
+		switch (nrc) {
+		case 0x00: service_name = "positiveResponse"; break;
+		case 0x10: service_name = "generalReject"; break;
+		case 0x11: service_name = "serviceNotSupported"; break;
+		case 0x12: service_name = "sub-functionNotSupported"; break;
+		case 0x13: service_name = "incorrectMessageLengthOrInvalidFormat"; break;
+		case 0x14: service_name = "responseTooLong"; break;
+		case 0x21: service_name = "busyRepeatRequest"; break;
+		case 0x22: service_name = "conditionsNotCorrect"; break;
+		case 0x24: service_name = "requestSequenceError"; break;
+		case 0x25: service_name = "noResponseFromSubnetComponent"; break;
+		case 0x26: service_name = "FailurePreventsExecutionOfRequestedAction"; break;
+		case 0x31: service_name = "requestOutOfRange"; break;
+		case 0x33: service_name = "securityAccessDenied"; break;
+		case 0x35: service_name = "invalidKey"; break;
+		case 0x36: service_name = "exceedNumberOfAttempts"; break;
+		case 0x37: service_name = "requiredTimeDelayNotExpired"; break;
+		case 0x70: service_name = "uploadDownloadNotAccepted"; break;
+		case 0x71: service_name = "transferDataSuspended"; break;
+		case 0x72: service_name = "generalProgrammingFailure"; break;
+		case 0x73: service_name = "wrongBlockSequenceCounter"; break;
+		case 0x78: service_name = "requestCorrectlyReceived-ResponsePending"; break;
+		case 0x7E: service_name = "sub-functionNotSupportedInActiveSession"; break;
+		case 0x7F: service_name = "serviceNotSupportedInActiveSession"; break;
+		case 0x81: service_name = "rpmTooHigh"; break;
+		case 0x82: service_name = "rpmTooLow"; break;
+		case 0x83: service_name = "engineIsRunning"; break;
+		case 0x84: service_name = "engineIsNotRunning"; break;
+		case 0x85: service_name = "engineRunTimeTooLow"; break;
+		case 0x86: service_name = "temperatureTooHigh"; break;
+		case 0x87: service_name = "temperatureTooLow"; break;
+		case 0x88: service_name = "vehicleSpeedTooHigh"; break;
+		case 0x89: service_name = "vehicleSpeedTooLow"; break;
+		case 0x8A: service_name = "throttle/PedalTooHigh"; break;
+		case 0x8B: service_name = "throttle/PedalTooLow"; break;
+		case 0x8C: service_name = "transmissionRangeNotInNeutral"; break;
+		case 0x8D: service_name = "transmissionRangeNotInGear"; break;
+		case 0x8F: service_name = "brakeSwitch(es)NotClosed (Brake Pedal not pressed or not applied)"; break;
+		case 0x90: service_name = "shifterLeverNotInPark"; break;
+		case 0x91: service_name = "torqueConverterClutchLocked"; break;
+		case 0x92: service_name = "voltageTooHigh"; break;
+		case 0x93: service_name = "voltageTooLow"; break;
+
+		default:
+			if (nrc > 0x37 && nrc < 0x50) {
+				service_name = "reservedByExtendedDataLinkSecurityDocument"; break;
+			}
+			else if (nrc > 0x93 && nrc < 0xF0) {
+				service_name = "reservedForSpecificConditionsNotCorrect"; break;
+			}
+			else if (nrc > 0xEF && nrc < 0xFE) {
+				service_name = "vehicleManufacturerSpecificConditionsNotCorrect"; break;
+			}
+			else {
+				service_name = "ISOSAEReserved"; break;
+			}
+		}
+		break;
+	default: service_name = "Unknown";
+	}
+	printf("%s %s", flag, service_name);
+}
+
+int main(int argc, char **argv)
+{
+	int s;
+	struct sockaddr_can addr;
+	struct can_filter rfilter[2];
+	struct canfd_frame frame;
+	int nbytes, i;
+	canid_t src = NO_CAN_ID;
+	canid_t dst = NO_CAN_ID;
+	int ext = 0;
+	int extaddr = 0;
+	int extany = 0;
+	int rx_ext = 0;
+	int rx_extaddr = 0;
+	int rx_extany = 0;
+	int asc = 0;
+	int color = 0;
+	int uds_output = 0;
+	int is_ff = 0;
+	int timestamp = 0;
+	int datidx = 0;
+	unsigned long fflen = 0;
+	struct timeval tv, last_tv;
+	unsigned int n_pci;
+	int opt;
+
+	last_tv.tv_sec  = 0;
+	last_tv.tv_usec = 0;
+
+	while ((opt = getopt(argc, argv, "s:d:ax:X:ct:u?")) != -1) {
+		switch (opt) {
+		case 's':
+			src = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				src |= CAN_EFF_FLAG;
+			break;
+
+		case 'd':
+			dst = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				dst |= CAN_EFF_FLAG;
+			break;
+
+		case 'c':
+			color = 1;
+			break;
+
+		case 'a':
+			asc = 1;
+			break;
+
+		case 'x':
+			ext = 1;
+			if (!strncmp(optarg, "any", 3))
+				extany = 1;
+			else
+				extaddr = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'X':
+			rx_ext = 1;
+			if (!strncmp(optarg, "any", 3))
+				rx_extany = 1;
+			else
+				rx_extaddr = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 't':
+			timestamp = optarg[0];
+			if ((timestamp != 'a') && (timestamp != 'A') &&
+			    (timestamp != 'd') && (timestamp != 'z')) {
+				printf("%s: unknown timestamp mode '%c' - ignored\n",
+				       basename(argv[0]), optarg[0]);
+				timestamp = 0;
+			}
+			break;
+
+		case 'u':
+		        uds_output = 1;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(0);
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			exit(1);
+			break;
+		}
+	}
+
+	if (rx_ext && !ext) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+
+	if ((argc - optind) != 1 || src == NO_CAN_ID || dst == NO_CAN_ID) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+
+	if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	/* try to switch the socket into CAN FD mode */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));
+
+	if (src & CAN_EFF_FLAG) {
+		rfilter[0].can_id   = src & (CAN_EFF_MASK | CAN_EFF_FLAG);
+		rfilter[0].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	} else {
+		rfilter[0].can_id   = src & CAN_SFF_MASK;
+		rfilter[0].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	}
+
+	if (dst & CAN_EFF_FLAG) {
+		rfilter[1].can_id   = dst & (CAN_EFF_MASK | CAN_EFF_FLAG);
+		rfilter[1].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	} else {
+		rfilter[1].can_id   = dst & CAN_SFF_MASK;
+		rfilter[1].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	}
+
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));
+
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = if_nametoindex(argv[optind]);
+	if (!addr.can_ifindex) {
+		perror("if_nametoindex");
+		return 1;
+	}
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	while (1) {
+		nbytes = read(s, &frame, sizeof(frame));
+		if (nbytes < 0) {
+			perror("read");
+			return 1;
+		}
+		if (nbytes != CAN_MTU && nbytes != CANFD_MTU) {
+			fprintf(stderr, "read: incomplete CAN frame %zu %d\n", sizeof(frame), nbytes);
+			return 1;
+		}
+		if (frame.can_id == src && ext && !extany &&
+		    extaddr != frame.data[0])
+			continue;
+
+		if (frame.can_id == dst && rx_ext && !rx_extany &&
+		    rx_extaddr != frame.data[0])
+			continue;
+
+		if (color)
+			printf("%s", (frame.can_id == src) ? FGRED : FGBLUE);
+
+		if (timestamp) {
+			ioctl(s, SIOCGSTAMP, &tv);
+
+			switch (timestamp) {
+			case 'a': /* absolute with timestamp */
+				printf("(%lu.%06lu) ", tv.tv_sec, tv.tv_usec);
+				break;
+
+			case 'A': /* absolute with date */
+			{
+				struct tm tm;
+				char timestring[25];
+
+				tm = *localtime(&tv.tv_sec);
+				strftime(timestring, 24, "%Y-%m-%d %H:%M:%S",
+					 &tm);
+				printf("(%s.%06lu) ", timestring, tv.tv_usec);
+			} break;
+
+			case 'd': /* delta */
+			case 'z': /* starting with zero */
+			{
+				struct timeval diff;
+
+				if (last_tv.tv_sec == 0) /* first init */
+					last_tv = tv;
+				diff.tv_sec = tv.tv_sec - last_tv.tv_sec;
+				diff.tv_usec = tv.tv_usec - last_tv.tv_usec;
+				if (diff.tv_usec < 0)
+					diff.tv_sec--, diff.tv_usec += 1000000;
+				if (diff.tv_sec < 0)
+					diff.tv_sec = diff.tv_usec = 0;
+				printf("(%lu.%06lu) ", diff.tv_sec,
+				       diff.tv_usec);
+
+				if (timestamp == 'd')
+					last_tv =
+						tv; /* update for delta calculation */
+			} break;
+
+			default: /* no timestamp output */
+				break;
+			}
+		}
+
+			if (frame.can_id & CAN_EFF_FLAG)
+				printf(" %s  %8X", argv[optind], frame.can_id & CAN_EFF_MASK);
+			else
+				printf(" %s  %3X", argv[optind], frame.can_id & CAN_SFF_MASK);
+
+			if (ext)
+				printf("{%02X}", frame.data[0]);
+
+			if (nbytes == CAN_MTU)
+				printf("  [%d]  ", frame.len);
+			else
+				printf(" [%02d]  ", frame.len);
+
+			datidx = 0;
+			n_pci = frame.data[ext];
+
+			switch (n_pci & 0xF0) {
+			case 0x00:
+			        is_ff = 1;
+				if (n_pci & 0xF) {
+					printf("[SF] ln: %-4d data:", n_pci & 0xF);
+					datidx = ext+1;
+				} else {
+					printf("[SF] ln: %-4d data:", frame.data[ext + 1]);
+					datidx = ext+2;
+				}
+				break;
+
+			case 0x10:
+			        is_ff = 1;
+				fflen = ((n_pci & 0x0F)<<8) + frame.data[ext+1];
+				if (fflen)
+					datidx = ext+2;
+				else {
+					fflen = (frame.data[ext+2]<<24) +
+						(frame.data[ext+3]<<16) +
+						(frame.data[ext+4]<<8) +
+						frame.data[ext+5];
+					datidx = ext+6;
+				}
+				printf("[FF] ln: %-4lu data:", fflen);
+				break;
+
+			case 0x20:
+				printf("[CF] sn: %X    data:", n_pci & 0x0F);
+				datidx = ext+1;
+				break;
+
+			case 0x30:
+				n_pci &= 0x0F;
+				printf("[FC] FC: %d ", n_pci);
+
+				if (n_pci > 3)
+					n_pci = 3;
+
+				printf("= %s # ", fc_info[n_pci]);
+
+				printf("BS: %d %s# ", frame.data[ext+1],
+				       (frame.data[ext+1])? "":"= off ");
+
+				i = frame.data[ext+2];
+				printf("STmin: 0x%02X = ", i);
+
+				if (i < 0x80)
+					printf("%d ms", i);
+				else if (i > 0xF0 && i < 0xFA)
+					printf("%d us", (i & 0x0F) * 100);
+				else
+					printf("reserved");
+				break;
+
+			default:
+				printf("[??]");
+			}
+
+			if (datidx && frame.len > datidx) {
+				printf(" ");
+				for (i = datidx; i < frame.len; i++) {
+					printf("%02X ", frame.data[i]);
+				}
+
+				if (asc) {
+					printf("%*s", ((7-ext) - (frame.len-datidx))*3 + 5 ,
+					       "-  '");
+					for (i = datidx; i < frame.len; i++) {
+						printf("%c",((frame.data[i] > 0x1F) &&
+							     (frame.data[i] < 0x7F))?
+						       frame.data[i] : '.');
+					}
+					printf("'");
+				}
+				if (uds_output && is_ff) {
+					int offset = 3;
+					if (asc)
+						offset = 1;
+					printf("%*s", ((7-ext) - (frame.len-datidx))*offset + 3,
+					       " - ");
+					print_uds_message(frame.data[datidx], frame.data[datidx+2]);
+					is_ff = 0;
+				}
+			}
+
+			if (color)
+				printf("%s", ATTRESET);
+			printf("\n");
+			fflush(stdout);
+	}
+
+	close(s);
+
+	return 0;
+}
diff --git a/canutils/isotpperf.c b/canutils/isotpperf.c
new file mode 100644
index 0000000000..154d5cd69f
--- /dev/null
+++ b/canutils/isotpperf.c
@@ -0,0 +1,422 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotpperf.c - ISO15765-2 protocol performance visualisation
+ *
+ * Copyright (c) 2014 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <linux/sockios.h>
+
+#define NO_CAN_ID 0xFFFFFFFFU
+#define PERCENTRES 2 /* resolution in percent for bargraph */
+#define NUMBAR (100/PERCENTRES) /* number of bargraph elements */
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - ISO15765-2 protocol performance visualisation.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -x <addr>    (extended addressing mode)\n");
+	fprintf(stderr, "         -X <addr>    (extended addressing mode (rx addr))\n");
+	fprintf(stderr, "\nCAN IDs and addresses are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "\n");
+}
+
+/* substitute math.h function log10(value)+1 */
+unsigned int getdigits(unsigned int value)
+{
+	int  digits = 1;
+
+	while (value > 9) {
+		digits++;
+		value /= 10;
+	}
+	return digits;
+}
+
+int main(int argc, char **argv)
+{
+	fd_set rdfs;
+	int s;
+	int running = 1;
+	struct sockaddr_can addr;
+	struct can_filter rfilter[2];
+	struct canfd_frame frame;
+	int canfd_on = 1;
+	int nbytes, i, ret;
+	canid_t src = NO_CAN_ID;
+	canid_t dst = NO_CAN_ID;
+	int ext = 0;
+	int extaddr = 0;
+	int rx_ext = 0;
+	int rx_extaddr = 0;
+	int datidx = 0;
+	unsigned char bs = 0;
+	unsigned char stmin = 0;
+	unsigned char brs = 0;
+	unsigned char ll_dl = 0;
+	unsigned long fflen = 0;
+	unsigned fflen_digits = 0;
+	unsigned long rcvlen = 0;
+	unsigned long percent = 0;
+	struct timeval start_tv, end_tv, diff_tv, timeo;
+	unsigned int n_pci;
+	unsigned int sn, last_sn = 0;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "s:d:x:X:?")) != -1) {
+		switch (opt) {
+		case 's':
+			src = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				src |= CAN_EFF_FLAG;
+			break;
+
+		case 'd':
+			dst = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				dst |= CAN_EFF_FLAG;
+			break;
+
+		case 'x':
+			ext = 1;
+			extaddr = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'X':
+			rx_ext = 1;
+			rx_extaddr = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(0);
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			exit(1);
+			break;
+		}
+	}
+
+	if ((argc - optind) != 1 || src == NO_CAN_ID || dst == NO_CAN_ID) {
+		print_usage(basename(argv[0]));
+		exit(0);
+	}
+
+	if ((s = socket(PF_CAN, SOCK_RAW, CAN_RAW)) < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	/* try to switch the socket into CAN FD mode */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FD_FRAMES, &canfd_on, sizeof(canfd_on));
+
+	/* set single CAN ID raw filters for src and dst frames */
+	if (src & CAN_EFF_FLAG) {
+		rfilter[0].can_id   = src & (CAN_EFF_MASK | CAN_EFF_FLAG);
+		rfilter[0].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	} else {
+		rfilter[0].can_id   = src & CAN_SFF_MASK;
+		rfilter[0].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	}
+
+	if (dst & CAN_EFF_FLAG) {
+		rfilter[1].can_id   = dst & (CAN_EFF_MASK | CAN_EFF_FLAG);
+		rfilter[1].can_mask = (CAN_EFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	} else {
+		rfilter[1].can_id   = dst & CAN_SFF_MASK;
+		rfilter[1].can_mask = (CAN_SFF_MASK|CAN_EFF_FLAG|CAN_RTR_FLAG);
+	}
+
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &rfilter, sizeof(rfilter));
+
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = if_nametoindex(argv[optind]);
+	if (!addr.can_ifindex) {
+		perror("if_nametoindex");
+		return 1;
+	}
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	while (running) {
+
+		FD_ZERO(&rdfs);
+		FD_SET(s, &rdfs);
+
+		/* timeout for ISO TP transmissions */
+		timeo.tv_sec  = 1;
+		timeo.tv_usec = 0;
+
+		if ((ret = select(s+1, &rdfs, NULL, NULL, &timeo)) < 0) {
+			running = 0;
+			continue;
+		}
+
+		/* detected timeout of already started transmission */
+		if (rcvlen && !(FD_ISSET(s, &rdfs))) {
+			printf("\r%-*s",78, " (transmission timed out)");
+			fflush(stdout);
+			fflen = rcvlen = 0;
+			continue;
+		}
+
+		nbytes = read(s, &frame, sizeof(frame));
+		if (nbytes < 0) {
+			perror("read");
+			ret = nbytes;
+			running = 0;
+			continue;
+		}
+		if (nbytes != CAN_MTU && nbytes != CANFD_MTU) {
+			fprintf(stderr, "read: incomplete CAN frame %zu %d\n", sizeof(frame), nbytes);
+			ret = nbytes;
+			running = 0;
+			continue;
+		}
+
+		if (rcvlen) {
+			/* make sure to process only the detected PDU CAN frame type */
+			if (canfd_on && (nbytes != CANFD_MTU))
+				continue;
+			if (!canfd_on && (nbytes != CAN_MTU))
+				continue;
+		}
+
+			/* check extended address if provided */
+			if (ext && extaddr != frame.data[0])
+				continue;
+
+			/* only get flow control information from dst CAN ID */
+			if (frame.can_id == dst) {
+				/* check extended address if provided */
+				if (rx_ext && frame.data[0] != rx_extaddr)
+					continue;
+
+				n_pci = frame.data[rx_ext];
+				/* check flow control PCI only */
+				if ((n_pci & 0xF0) != 0x30)
+					continue;
+
+				bs = frame.data[rx_ext + 1];
+				stmin = frame.data[rx_ext + 2];
+			}
+
+			/* data content starts and index datidx */
+			datidx = 0;
+
+			n_pci = frame.data[ext];
+			switch (n_pci & 0xF0) {
+
+			case 0x00:
+				/* SF */
+				if (n_pci & 0xF) {
+					fflen = rcvlen = n_pci & 0xF;
+					datidx = ext+1;
+				} else {
+					fflen = rcvlen = frame.data[ext + 1];
+					datidx = ext+2;
+				}
+
+				/* ignore incorrect SF PDUs */
+				if (frame.len < rcvlen + datidx)
+					fflen = rcvlen = 0;
+
+				/* get number of digits for printing */
+				fflen_digits = getdigits(fflen);
+
+				/* get CAN FD bitrate & LL_DL setting information */
+				brs = frame.flags & CANFD_BRS;
+				ll_dl = frame.len;
+				if (ll_dl < 8)
+					ll_dl = 8;
+
+				ioctl(s, SIOCGSTAMP, &start_tv);
+
+				/* determine CAN frame mode for this PDU */
+				if (nbytes == CAN_MTU)
+					canfd_on = 0;
+				else
+					canfd_on = 1;
+
+				break;
+
+			case 0x10:
+				/* FF */
+				fflen = ((n_pci & 0x0F)<<8) + frame.data[ext+1];
+				if (fflen)
+					datidx = ext+2;
+				else {
+					fflen = (frame.data[ext+2]<<24) +
+						(frame.data[ext+3]<<16) +
+						(frame.data[ext+4]<<8) +
+						frame.data[ext+5];
+					datidx = ext+6;
+				}
+
+				/* to increase the time resolution we multiply fflen with 1000 later */
+				if (fflen >= (UINT32_MAX / 1000)) {
+					printf("fflen %lu is more than ~4.2 MB - ignoring PDU\n", fflen);
+					fflush(stdout);
+					fflen = rcvlen = 0;
+					continue;
+				}
+				rcvlen = frame.len - datidx;
+				last_sn = 0;
+
+				/* get number of digits for printing */
+				fflen_digits = getdigits(fflen);
+
+				/* get CAN FD bitrate & LL_DL setting information */
+				brs = frame.flags & CANFD_BRS;
+				ll_dl = frame.len;
+
+				ioctl(s, SIOCGSTAMP, &start_tv);
+
+				/* determine CAN frame mode for this PDU */
+				if (nbytes == CAN_MTU)
+					canfd_on = 0;
+				else
+					canfd_on = 1;
+
+				break;
+
+			case 0x20:
+				/* CF */
+				if (rcvlen) {
+					sn = n_pci & 0x0F;
+					if (sn == ((last_sn + 1) & 0xF)) {
+						last_sn = sn;
+						datidx = ext+1;
+						rcvlen += frame.len - datidx;
+					}
+				}
+				break;
+
+			default:
+				break;
+			}
+
+			/* PDU reception in process */
+			if (rcvlen) {
+				if (rcvlen > fflen)
+					rcvlen = fflen;
+
+				percent = (rcvlen * 100 / fflen);
+				printf("\r %3lu%% ", percent);
+
+				printf("|");
+
+				if (percent > 100)
+					percent = 100;
+
+				for (i=0; i < NUMBAR; i++){
+					if (i < (int)(percent/PERCENTRES))
+						printf("X");
+					else
+						printf(".");
+				}
+				printf("| %*lu/%lu ", fflen_digits, rcvlen, fflen);
+			}
+
+			/* PDU complete */
+			if (rcvlen && rcvlen >= fflen) {
+
+				printf("\r%s %02d%c (BS:%2hhu # ", canfd_on?"CAN-FD":"CAN2.0", ll_dl, brs?'*':' ', bs);
+				if (stmin < 0x80)
+					printf("STmin:%3hhu msec)", stmin);
+				else if (stmin > 0xF0 && stmin < 0xFA)
+					printf("STmin:%3u usec)", (stmin & 0xF) * 100);
+				else
+					printf("STmin: invalid   )");
+
+				printf(" : %lu byte in ", fflen);
+
+				/* calculate time */
+				ioctl(s, SIOCGSTAMP, &end_tv);
+				diff_tv.tv_sec  = end_tv.tv_sec  - start_tv.tv_sec;
+				diff_tv.tv_usec = end_tv.tv_usec - start_tv.tv_usec;
+				if (diff_tv.tv_usec < 0)
+					diff_tv.tv_sec--, diff_tv.tv_usec += 1000000;
+				if (diff_tv.tv_sec < 0)
+					diff_tv.tv_sec = diff_tv.tv_usec = 0;
+
+				/* check devisor to be not zero */
+				if (diff_tv.tv_sec * 1000 + diff_tv.tv_usec / 1000){
+					printf("%lu.%06lus ", diff_tv.tv_sec, diff_tv.tv_usec);
+					printf("=> %lu byte/s", (fflen * 1000) /
+					       (diff_tv.tv_sec * 1000 + diff_tv.tv_usec / 1000));
+				} else
+					printf("(no time available)     ");
+
+				printf("\n");
+				/* wait for next PDU */
+				fflen = rcvlen = 0;
+			}
+			fflush(stdout);
+	}
+
+	close(s);
+
+	return ret;
+}
diff --git a/canutils/isotprecv.c b/canutils/isotprecv.c
new file mode 100644
index 0000000000..e07e36a4ee
--- /dev/null
+++ b/canutils/isotprecv.c
@@ -0,0 +1,259 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotprecv.c
+ *
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/isotp.h>
+
+#define NO_CAN_ID 0xFFFFFFFFU
+#define BUFSIZE 67000 /* size > 66000 to check socket API internal checks */
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -s <can_id>   (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>   (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\n");
+	fprintf(stderr, "         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\n");
+	fprintf(stderr, "         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\n");
+	fprintf(stderr, "         -b <bs>       (blocksize. 0 = off)\n");
+	fprintf(stderr, "         -m <val>      (STmin in ms/ns. See spec.)\n");
+	fprintf(stderr, "         -f <time ns>  (force rx stmin value in nanosecs)\n");
+	fprintf(stderr, "         -w <num>      (max. wait frame transmissions.)\n");
+	fprintf(stderr, "         -l            (loop: do not exit after pdu reception.)\n");
+	fprintf(stderr, "         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\n");
+	fprintf(stderr, "\nCAN IDs and addresses are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "The pdu data is written on STDOUT in space separated ASCII hex values.\n");
+	fprintf(stderr, "\n");
+}
+
+int main(int argc, char **argv)
+{
+    int s;
+    struct sockaddr_can addr;
+    static struct can_isotp_options opts;
+    static struct can_isotp_fc_options fcopts;
+    static struct can_isotp_ll_options llopts;
+    int opt, i;
+    extern int optind, opterr, optopt;
+    __u32 force_rx_stmin = 0;
+    int loop = 0;
+
+    unsigned char msg[BUFSIZE];
+    int nbytes;
+
+    addr.can_addr.tp.tx_id = addr.can_addr.tp.rx_id = NO_CAN_ID;
+
+    while ((opt = getopt(argc, argv, "s:d:x:p:P:b:m:w:f:lL:?")) != -1) {
+	    switch (opt) {
+	    case 's':
+		    addr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);
+		    if (strlen(optarg) > 7)
+			    addr.can_addr.tp.tx_id |= CAN_EFF_FLAG;
+		    break;
+
+	    case 'd':
+		    addr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);
+		    if (strlen(optarg) > 7)
+			    addr.can_addr.tp.rx_id |= CAN_EFF_FLAG;
+		    break;
+
+	    case 'x':
+	    {
+		    int elements = sscanf(optarg, "%hhx:%hhx",
+					  &opts.ext_address,
+					  &opts.rx_ext_address);
+
+		    if (elements == 1)
+			    opts.flags |= CAN_ISOTP_EXTEND_ADDR;
+		    else if (elements == 2)
+			    opts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);
+		    else {
+			    printf("incorrect extended addr values '%s'.\n", optarg);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+	    }
+
+	    case 'p':
+	    {
+		    int elements = sscanf(optarg, "%hhx:%hhx",
+					  &opts.txpad_content,
+					  &opts.rxpad_content);
+
+		    if (elements == 1)
+			    opts.flags |= CAN_ISOTP_TX_PADDING;
+		    else if (elements == 2)
+			    opts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);
+		    else if (sscanf(optarg, ":%hhx", &opts.rxpad_content) == 1)
+			    opts.flags |= CAN_ISOTP_RX_PADDING;
+		    else {
+			    printf("incorrect padding values '%s'.\n", optarg);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+	    }
+
+	    case 'P':
+		    if (optarg[0] == 'l')
+			    opts.flags |= CAN_ISOTP_CHK_PAD_LEN;
+		    else if (optarg[0] == 'c')
+			    opts.flags |= CAN_ISOTP_CHK_PAD_DATA;
+		    else if (optarg[0] == 'a')
+			    opts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);
+		    else {
+			    printf("unknown padding check option '%c'.\n", optarg[0]);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+
+	    case 'b':
+		    fcopts.bs = strtoul(optarg, NULL, 16) & 0xFF;
+		    break;
+
+	    case 'm':
+		    fcopts.stmin = strtoul(optarg, NULL, 16) & 0xFF;
+		    break;
+
+	    case 'w':
+		    fcopts.wftmax = strtoul(optarg, NULL, 16) & 0xFF;
+		    break;
+
+	    case 'f':
+		    opts.flags |= CAN_ISOTP_FORCE_RXSTMIN;
+		    force_rx_stmin = strtoul(optarg, NULL, 10);
+		    break;
+
+	    case 'l':
+		    loop = 1;
+		    break;
+
+	    case 'L':
+		    if (sscanf(optarg, "%hhu:%hhu:%hhu",
+			       &llopts.mtu,
+			       &llopts.tx_dl,
+			       &llopts.tx_flags) != 3) {
+			    printf("unknown link layer options '%s'.\n", optarg);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+
+	    case '?':
+		    print_usage(basename(argv[0]));
+		    exit(0);
+		    break;
+
+	    default:
+		    fprintf(stderr, "Unknown option %c\n", opt);
+		    print_usage(basename(argv[0]));
+		    exit(1);
+		    break;
+	    }
+    }
+
+    if ((argc - optind != 1) ||
+	(addr.can_addr.tp.tx_id == NO_CAN_ID) ||
+	(addr.can_addr.tp.rx_id == NO_CAN_ID)) {
+	    print_usage(basename(argv[0]));
+	    exit(1);
+    }
+  
+    if ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {
+	perror("socket");
+	exit(1);
+    }
+
+    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));
+    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fcopts, sizeof(fcopts));
+
+    if (llopts.tx_dl) {
+	if (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {
+	    perror("link layer sockopt");
+	    exit(1);
+	}
+    }
+
+    if (opts.flags & CAN_ISOTP_FORCE_RXSTMIN)
+	    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RX_STMIN, &force_rx_stmin, sizeof(force_rx_stmin));
+
+    addr.can_family = AF_CAN;
+    addr.can_ifindex = if_nametoindex(argv[optind]);
+    if (!addr.can_ifindex) {
+	perror("if_nametoindex");
+	exit(1);
+    }
+
+    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+	perror("bind");
+	close(s);
+	exit(1);
+    }
+
+    do {
+	    nbytes = read(s, msg, BUFSIZE);
+	    if (nbytes > 0 && nbytes < BUFSIZE)
+		    for (i=0; i < nbytes; i++)
+			    printf("%02X ", msg[i]);
+	    printf("\n");
+    } while (loop);
+
+    close(s);
+
+    return 0;
+}
diff --git a/canutils/isotpsend.c b/canutils/isotpsend.c
new file mode 100644
index 0000000000..deac601821
--- /dev/null
+++ b/canutils/isotpsend.c
@@ -0,0 +1,323 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotpsend.c
+ *
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/isotp.h>
+
+#define NO_CAN_ID 0xFFFFFFFFU
+#define BUFSIZE 67000 /* size > 66000 kernel buf to test socket API internal checks */
+#define ZERO_STRING "ZERO"
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\n");
+	fprintf(stderr, "         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\n");
+	fprintf(stderr, "         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\n");
+	fprintf(stderr, "         -t <time ns>  (frame transmit time (N_As) in nanosecs) (*)\n");
+	fprintf(stderr, "         -f <time ns>  (ignore FC and force local tx stmin value in nanosecs)\n");
+	fprintf(stderr, "         -D <len>      (send a fixed PDU with len bytes - no STDIN data)\n");
+	fprintf(stderr, "         -l <num>      (send num PDUs - use 'i' for infinite loop)\n");
+	fprintf(stderr, "         -g <usecs>    (wait given usecs before sending a PDU)\n");
+	fprintf(stderr, "         -b            (block until the PDU transmission is completed)\n");
+	fprintf(stderr, "         -S            (SF broadcast mode - for functional addressing)\n");
+	fprintf(stderr, "         -C            (CF broadcast mode - no wait for flow controls)\n");
+	fprintf(stderr, "         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\n");
+	fprintf(stderr, "\nCAN IDs and addresses are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "The pdu data is expected on STDIN in space separated ASCII hex values.\n");
+	fprintf(stderr, "(*) = Use '-t %s' to set N_As to zero for Linux version 5.18+\n", ZERO_STRING);
+	fprintf(stderr, "\n");
+}
+
+int main(int argc, char **argv)
+{
+    int s;
+    struct sockaddr_can addr;
+    static struct can_isotp_options opts;
+    static struct can_isotp_ll_options llopts;
+    int opt;
+    extern int optind, opterr, optopt;
+    unsigned int loops = 1; /* one (== no) loop by default */
+    useconds_t usecs = 0; /* wait before sending the PDU */
+    __u32 force_tx_stmin = 0;
+    unsigned char buf[BUFSIZE];
+    int buflen = 0;
+    int datalen = 0;
+    int retval = 0;
+
+    addr.can_addr.tp.tx_id = addr.can_addr.tp.rx_id = NO_CAN_ID;
+
+    while ((opt = getopt(argc, argv, "s:d:x:p:P:t:f:D:l:g:bSCL:?")) != -1) {
+	    switch (opt) {
+	    case 's':
+		    addr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);
+		    if (strlen(optarg) > 7)
+			    addr.can_addr.tp.tx_id |= CAN_EFF_FLAG;
+		    break;
+
+	    case 'd':
+		    addr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);
+		    if (strlen(optarg) > 7)
+			    addr.can_addr.tp.rx_id |= CAN_EFF_FLAG;
+		    break;
+
+	    case 'x':
+	    {
+		    int elements = sscanf(optarg, "%hhx:%hhx",
+					  &opts.ext_address,
+					  &opts.rx_ext_address);
+
+		    if (elements == 1)
+			    opts.flags |= CAN_ISOTP_EXTEND_ADDR;
+		    else if (elements == 2)
+			    opts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);
+		    else {
+			    printf("incorrect extended addr values '%s'.\n", optarg);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+	    }
+
+	    case 'p':
+	    {
+		    int elements = sscanf(optarg, "%hhx:%hhx",
+					  &opts.txpad_content,
+					  &opts.rxpad_content);
+
+		    if (elements == 1)
+			    opts.flags |= CAN_ISOTP_TX_PADDING;
+		    else if (elements == 2)
+			    opts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);
+		    else if (sscanf(optarg, ":%hhx", &opts.rxpad_content) == 1)
+			    opts.flags |= CAN_ISOTP_RX_PADDING;
+		    else {
+			    printf("incorrect padding values '%s'.\n", optarg);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+	    }
+
+	    case 'P':
+		    if (optarg[0] == 'l')
+			    opts.flags |= CAN_ISOTP_CHK_PAD_LEN;
+		    else if (optarg[0] == 'c')
+			    opts.flags |= CAN_ISOTP_CHK_PAD_DATA;
+		    else if (optarg[0] == 'a')
+			    opts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);
+		    else {
+			    printf("unknown padding check option '%c'.\n", optarg[0]);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+
+	    case 't':
+		    if (!strncmp(optarg, ZERO_STRING, strlen(ZERO_STRING)))
+			    opts.frame_txtime = CAN_ISOTP_FRAME_TXTIME_ZERO;
+		    else
+			    opts.frame_txtime = strtoul(optarg, NULL, 10);
+		    break;
+
+	    case 'f':
+		    opts.flags |= CAN_ISOTP_FORCE_TXSTMIN;
+		    force_tx_stmin = strtoul(optarg, NULL, 10);
+		    break;
+
+	    case 'D':
+		    datalen = strtoul(optarg, NULL, 10);
+		    if (!datalen || datalen >= BUFSIZE) {
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+
+	    case 'l':
+		    if (optarg[0] == 'i') {
+			    loops = 0; /* infinite loop */
+		    } else {
+			    loops = strtoul(optarg, NULL, 10);
+			    if (!loops) {
+				    fprintf(stderr, "Invalid argument for option -l!\n");
+				    return 1;
+			    }
+		    }
+		    break;
+
+	    case 'g':
+		    usecs = strtoul(optarg, NULL, 10);
+		    break;
+
+	    case 'b':
+		    opts.flags |= CAN_ISOTP_WAIT_TX_DONE;
+		    break;
+
+	    case 'S':
+		    opts.flags |= CAN_ISOTP_SF_BROADCAST;
+		    break;
+
+	    case 'C':
+		    opts.flags |= CAN_ISOTP_CF_BROADCAST;
+		    break;
+
+	    case 'L':
+		    if (sscanf(optarg, "%hhu:%hhu:%hhu",
+			       &llopts.mtu,
+			       &llopts.tx_dl,
+			       &llopts.tx_flags) != 3) {
+			    printf("unknown link layer options '%s'.\n", optarg);
+			    print_usage(basename(argv[0]));
+			    exit(0);
+		    }
+		    break;
+
+	    case '?':
+		    print_usage(basename(argv[0]));
+		    exit(0);
+		    break;
+
+	    default:
+		    fprintf(stderr, "Unknown option %c\n", opt);
+		    print_usage(basename(argv[0]));
+		    exit(1);
+		    break;
+	    }
+    }
+
+#define BC_FLAGS (CAN_ISOTP_SF_BROADCAST | CAN_ISOTP_CF_BROADCAST)
+
+    if ((argc - optind != 1) ||
+	(addr.can_addr.tp.tx_id == NO_CAN_ID) ||
+	((opts.flags & BC_FLAGS) == BC_FLAGS) ||
+	((addr.can_addr.tp.rx_id == NO_CAN_ID) &&
+	 (!(opts.flags & BC_FLAGS)))) {
+	    print_usage(basename(argv[0]));
+	    exit(1);
+    }
+
+    if ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {
+	perror("socket");
+	exit(1);
+    }
+
+    if (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts)) < 0) {
+	perror("sockopt");
+	exit(1);
+    }
+
+
+    if (llopts.tx_dl) {
+	if (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {
+	    perror("link layer sockopt");
+	    exit(1);
+	}
+    }
+
+    if (opts.flags & CAN_ISOTP_FORCE_TXSTMIN)
+	    setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_TX_STMIN, &force_tx_stmin, sizeof(force_tx_stmin));
+
+    addr.can_family = AF_CAN;
+    addr.can_ifindex = if_nametoindex(argv[optind]);
+    if (!addr.can_ifindex) {
+	perror("if_nametoindex");
+	exit(1);
+    }
+
+    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+	perror("bind");
+	close(s);
+	exit(1);
+    }
+
+    if (!datalen) {
+	    while (buflen < BUFSIZE && scanf("%hhx", &buf[buflen]) == 1)
+		    buflen++;
+    } else {
+	    for (buflen = 0; buflen < datalen; buflen++)
+		    buf[buflen] = ((buflen % 0xFF) + 1) & 0xFF;
+    }
+
+loop:
+    if (usecs)
+	    usleep(usecs);
+
+    retval = write(s, buf, buflen);
+    if (retval < 0) {
+	    perror("write");
+	    return retval;
+    }
+
+    if (retval != buflen)
+	    fprintf(stderr, "wrote only %d from %d byte\n", retval, buflen);
+
+    if (loops) {
+	    if (--loops)
+		    goto loop;
+    } else {
+	    goto loop;
+    }
+
+    /* 
+     * due to a Kernel internal wait queue the PDU is sent completely
+     * before close() returns.
+     */
+    close(s);
+
+    return 0;
+}
diff --git a/canutils/isotpserver.c b/canutils/isotpserver.c
new file mode 100644
index 0000000000..6fdb0db5bf
--- /dev/null
+++ b/canutils/isotpserver.c
@@ -0,0 +1,441 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotpserver.c
+ *
+ * Implements a socket server which understands ASCII HEX
+ * messages for simple TCP/IP <-> ISO 15765-2 bridging.
+ *
+ * General message format: <[data]+>
+ *
+ * e.g. for an eight bytes PDU
+ *
+ * <1122334455667788>
+ *
+ * Valid ISO 15625-2 PDUs have a length from 1-4095 bytes.
+ *
+ * Authors:
+ * Andre Naujoks (the socket server stuff)
+ * Oliver Hartkopp (the rest)
+ *
+ * Copyright (c) 2002-2010 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <errno.h>
+#include <libgen.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <sys/wait.h>
+
+#include <linux/can.h>
+#include <linux/can/isotp.h>
+
+#define NO_CAN_ID 0xFFFFFFFFU
+
+/* allow PDUs greater 4095 bytes according ISO 15765-2:2015 */
+#define MAX_PDU_LENGTH 6000
+
+int b64hex(char *asc, unsigned char *bin, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (!sscanf(asc+(i*2), "%2hhx", bin+i))
+			return 1;	
+	}
+	return 0;
+}
+
+void childdied(int i)
+{
+	wait(NULL);
+}
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "\nUsage: %s -l <port> -s <can_id> -d <can_id> [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "ip addressing:\n");
+	fprintf(stderr, "         -l <port>    * (local port for the server)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "isotp addressing:\n");
+	fprintf(stderr, "         -s <can_id>  * (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>  * (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\n");
+	fprintf(stderr, "         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "padding:\n");
+	fprintf(stderr, "         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\n");
+	fprintf(stderr, "         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "rx path:\n (config, which is sent to the sender / data source)\n");
+	fprintf(stderr, "         -b <bs>       (blocksize. 0 = off)\n");
+	fprintf(stderr, "         -m <val>      (STmin in ms/ns. See spec.)\n");
+	fprintf(stderr, "         -w <num>      (max. wait frame transmissions)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "tx path:\n (config, which changes local tx settings)\n");
+	fprintf(stderr, "         -t <time ns>  (transmit time in nanosecs)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "(* = mandatory option)\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "All values except for '-l' and '-t' are expected in hexadecimal values.\n");
+	fprintf(stderr, "\n");
+}
+
+int main(int argc, char **argv)
+{
+	extern int optind, opterr, optopt;
+	int opt;
+
+	int sl, sa, sc; /* (L)isten, (A)ccept, (C)AN sockets */ 
+	struct sockaddr_in  saddr, clientaddr;
+	struct sockaddr_can caddr;
+	static struct can_isotp_options opts;
+	static struct can_isotp_fc_options fcopts;
+	static struct can_isotp_ll_options llopts;
+	socklen_t sin_size = sizeof(clientaddr);
+	socklen_t caddrlen = sizeof(caddr);
+
+	struct sigaction signalaction;
+	sigset_t sigset;
+
+	fd_set readfds;
+
+	int i;
+	int nbytes;
+
+	int local_port = 0;
+	int verbose = 0;
+
+	int idx = 0; /* index in txmsg[] */
+
+	unsigned char msg[MAX_PDU_LENGTH + 1];   /* isotp socket message buffer (4095 + test_for_too_long_byte)*/
+	char rxmsg[MAX_PDU_LENGTH * 2 + 4]; /* isotp->tcp ASCII message buffer (4095*2 + < > \n null) */
+	char txmsg[MAX_PDU_LENGTH * 2 + 3]; /* tcp->isotp ASCII message buffer (4095*2 + < > null) */
+
+	/* mark missing mandatory commandline options as missing */
+	caddr.can_addr.tp.tx_id = caddr.can_addr.tp.rx_id = NO_CAN_ID;
+
+	while ((opt = getopt(argc, argv, "l:s:d:x:p:P:b:m:w:t:L:v?")) != -1) {
+		switch (opt) {
+		case 'l':
+			local_port = strtoul(optarg, NULL, 10);
+			break;
+
+		case 's':
+			caddr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				caddr.can_addr.tp.tx_id |= CAN_EFF_FLAG;
+			break;
+
+		case 'd':
+			caddr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				caddr.can_addr.tp.rx_id |= CAN_EFF_FLAG;
+			break;
+
+		case 'x':
+		{
+			int elements = sscanf(optarg, "%hhx:%hhx",
+					      &opts.ext_address,
+					      &opts.rx_ext_address);
+
+			if (elements == 1)
+				opts.flags |= CAN_ISOTP_EXTEND_ADDR;
+			else if (elements == 2)
+				opts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);
+			else {
+				printf("incorrect extended addr values '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(0);
+			}
+			break;
+		}
+
+		case 'p':
+		{
+			int elements = sscanf(optarg, "%hhx:%hhx",
+					      &opts.txpad_content,
+					      &opts.rxpad_content);
+
+			if (elements == 1)
+				opts.flags |= CAN_ISOTP_TX_PADDING;
+			else if (elements == 2)
+				opts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);
+			else if (sscanf(optarg, ":%hhx", &opts.rxpad_content) == 1)
+				opts.flags |= CAN_ISOTP_RX_PADDING;
+			else {
+				printf("incorrect padding values '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(0);
+			}
+			break;
+		}
+
+		case 'P':
+			if (optarg[0] == 'l')
+				opts.flags |= CAN_ISOTP_CHK_PAD_LEN;
+			else if (optarg[0] == 'c')
+				opts.flags |= CAN_ISOTP_CHK_PAD_DATA;
+			else if (optarg[0] == 'a')
+				opts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);
+			else {
+				printf("unknown padding check option '%c'.\n", optarg[0]);
+				print_usage(basename(argv[0]));
+				exit(0);
+			}
+			break;
+
+		case 'b':
+			fcopts.bs = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'm':
+			fcopts.stmin = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'w':
+			fcopts.wftmax = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 't':
+			opts.frame_txtime = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'L':
+			if (sscanf(optarg, "%hhu:%hhu:%hhu",
+				   &llopts.mtu,
+				   &llopts.tx_dl,
+				   &llopts.tx_flags) != 3) {
+				printf("unknown link layer options '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(0);
+			}
+			break;
+
+		case 'v':
+			verbose = 1;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(0);
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			exit(1);
+			break;
+		}
+	}
+
+	if ((argc - optind != 1) || (local_port == 0) ||
+	    (caddr.can_addr.tp.tx_id == NO_CAN_ID) ||
+	    (caddr.can_addr.tp.rx_id == NO_CAN_ID)) {
+		print_usage(basename(argv[0]));
+		exit(1);
+	}
+  
+	sigemptyset(&sigset);
+	signalaction.sa_handler = &childdied;
+	signalaction.sa_mask = sigset;
+	signalaction.sa_flags = 0;
+	sigaction(SIGCHLD, &signalaction, NULL);  /* signal for dying child */
+
+	if((sl = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
+		perror("inetsocket");
+		exit(1);
+	}
+
+	saddr.sin_family = AF_INET;
+	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
+	saddr.sin_port = htons(local_port);
+
+	while(bind(sl,(struct sockaddr*)&saddr, sizeof(saddr)) < 0) {
+		struct timespec f = {
+			.tv_nsec = 100 * 1000 * 1000,
+		};
+
+		printf(".");
+		fflush(NULL);
+		nanosleep(&f, NULL);
+	}
+
+	if (listen(sl, 3) != 0) {
+		perror("listen");
+		exit(1);
+	}
+
+	while (1) { 
+		sa = accept(sl,(struct sockaddr *)&clientaddr, &sin_size);
+		if (sa > 0 ){
+			if (!fork())
+				break;
+			close(sa);
+		}
+		else {
+			if (errno != EINTR) {
+				/*
+				 * If the cause for the error was NOT the
+				 * signal from a dying child => give an error
+				 */
+				perror("accept");
+				exit(1);
+			}
+		}
+	}
+
+	if ((sc = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {
+		perror("socket");
+		exit(1);
+	}
+
+	setsockopt(sc, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));
+	setsockopt(sc, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fcopts, sizeof(fcopts));
+
+	if (llopts.tx_dl) {
+		if (setsockopt(sc, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {
+			perror("link layer sockopt");
+			exit(1);
+		}
+	}
+
+	caddr.can_family = AF_CAN;
+	caddr.can_ifindex = if_nametoindex(argv[optind]);
+	if (!caddr.can_ifindex) {
+		perror("if_nametoindex");
+		exit(1);
+	}
+
+	if (bind(sc, (struct sockaddr *)&caddr, caddrlen) < 0) {
+		perror("bind");
+		exit(1);
+	}
+
+	while (1) {
+
+		FD_ZERO(&readfds);
+		FD_SET(sc, &readfds);
+		FD_SET(sa, &readfds);
+
+		select((sc > sa)?sc+1:sa+1, &readfds, NULL, NULL, NULL);
+
+		if (FD_ISSET(sc, &readfds)) {
+
+
+			nbytes = read(sc, &msg, MAX_PDU_LENGTH + 1);
+
+			if (nbytes < 1 || nbytes > MAX_PDU_LENGTH) {
+				perror("read from isotp socket");
+				exit(1);
+			}
+
+			rxmsg[0] = '<';
+
+			for ( i = 0; i < nbytes; i++)
+				sprintf(rxmsg + 1 + 2*i, "%02X", msg[i]);
+
+			/* finalize string for sending */
+			strcat(rxmsg, ">\n");
+
+			if (verbose)
+				printf("CAN>TCP %s", rxmsg);
+
+			send(sa, rxmsg, strlen(rxmsg), 0);
+		}
+
+
+		if (FD_ISSET(sa, &readfds)) {
+
+			if (read(sa, txmsg+idx, 1) < 1) {
+				perror("read from tcp/ip socket");
+				exit(1);
+			}
+
+			if (!idx) {
+				if (txmsg[0] == '<')
+					idx = 1;
+
+				continue;
+			}
+
+			/* max len is 4095*2 + '<' + '>' = 8192. The buffer index starts with 0 */
+			if (idx > MAX_PDU_LENGTH * 2 + 1) {
+				idx = 0;
+				continue;
+			}
+
+			if (txmsg[idx] != '>') {
+				idx++;
+				continue;
+			}
+
+			txmsg[idx+1] = 0;
+			idx = 0;
+
+			/* must be an even number of bytes and at least one data byte <XX> */
+			if (strlen(txmsg) < 4 || strlen(txmsg) % 2)
+				continue;
+
+			if (verbose)
+				printf("TCP>CAN %s\n", txmsg);
+
+			nbytes = (strlen(txmsg)-2)/2;
+			if (b64hex(txmsg+1, msg, nbytes) == 0)
+				send(sc, msg, nbytes, 0);
+		}
+	}
+
+	close(sc);
+	close(sa);
+
+	return 0;
+}
diff --git a/canutils/isotpsniffer.c b/canutils/isotpsniffer.c
new file mode 100644
index 0000000000..2b6de40743
--- /dev/null
+++ b/canutils/isotpsniffer.c
@@ -0,0 +1,402 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotpsniffer.c - dump ISO15765-2 datagrams using PF_CAN isotp protocol 
+ *
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <ctype.h>
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include "terminal.h"
+#include <linux/can.h>
+#include <linux/can/isotp.h>
+#include <linux/sockios.h>
+
+#define NO_CAN_ID 0xFFFFFFFFU
+
+#define FORMAT_HEX 1
+#define FORMAT_ASCII 2
+#define FORMAT_DEFAULT (FORMAT_ASCII | FORMAT_HEX)
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -s <can_id>  (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>  (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -x <addr>    (extended addressing mode)\n");
+	fprintf(stderr, "         -X <addr>    (extended addressing mode - rx addr)\n");
+	fprintf(stderr, "         -c           (color mode)\n");
+	fprintf(stderr, "         -t <type>    (timestamp: (a)bsolute/(d)elta/(z)ero/(A)bsolute w date)\n");
+	fprintf(stderr, "         -f <format>  (1 = HEX, 2 = ASCII, 3 = HEX & ASCII - default: %d)\n", FORMAT_DEFAULT);
+	fprintf(stderr, "         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\n");
+	fprintf(stderr, "         -h <len>    (head: print only first <len> bytes)\n");
+	fprintf(stderr, "\nCAN IDs and addresses are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "\n");
+}
+
+void printbuf(unsigned char *buffer, int nbytes, int color, int timestamp,
+	      int format, struct timeval *tv, struct timeval *last_tv,
+	      canid_t src, int socket, char *candevice, int head)
+{
+	int i;
+
+	if (color == 1)
+		printf("%s", FGRED);
+
+	if (color == 2)
+		printf("%s", FGBLUE);
+
+	if (timestamp) {
+		ioctl(socket, SIOCGSTAMP, tv);
+
+		switch (timestamp) {
+
+		case 'a': /* absolute with timestamp */
+			printf("(%lu.%06lu) ", tv->tv_sec, tv->tv_usec);
+			break;
+
+		case 'A': /* absolute with date */
+		{
+			struct tm tm;
+			char timestring[25];
+
+			tm = *localtime(&tv->tv_sec);
+			strftime(timestring, 24, "%Y-%m-%d %H:%M:%S", &tm);
+			printf("(%s.%06lu) ", timestring, tv->tv_usec);
+		}
+		break;
+
+		case 'd': /* delta */
+		case 'z': /* starting with zero */
+		{
+			struct timeval diff;
+
+			if (last_tv->tv_sec == 0)   /* first init */
+				*last_tv = *tv;
+			diff.tv_sec  = tv->tv_sec  - last_tv->tv_sec;
+			diff.tv_usec = tv->tv_usec - last_tv->tv_usec;
+			if (diff.tv_usec < 0)
+				diff.tv_sec--, diff.tv_usec += 1000000;
+			if (diff.tv_sec < 0)
+				diff.tv_sec = diff.tv_usec = 0;
+			printf("(%lu.%06lu) ", diff.tv_sec, diff.tv_usec);
+
+			if (timestamp == 'd')
+				*last_tv = *tv; /* update for delta calculation */
+		}
+		break;
+
+		default: /* no timestamp output */
+			break;
+		}
+	}
+
+	/* the source socket gets pdu data from the destination id */
+	printf(" %s  %03X  [%d]  ", candevice, src & CAN_EFF_MASK, nbytes);
+	if (format & FORMAT_HEX) {
+		for (i=0; i<nbytes; i++) {
+			printf("%02X ", buffer[i]);
+			if (head && i+1 >= head) {
+				printf("... ");
+				break;
+			}
+		}
+		if (format & FORMAT_ASCII)
+			printf(" - ");
+	}
+	if (format & FORMAT_ASCII) {
+		printf("'");
+		for (i=0; i<nbytes; i++) {
+			if (isprint(buffer[i]))
+				printf("%c", buffer[i]);
+			else
+				printf(".");
+			if (head && i+1 >= head)
+				break;
+		}
+		printf("'");
+		if (head && i+1 >= head)
+			printf(" ... ");
+	}
+
+	if (color)
+		printf("%s", ATTRESET);
+
+	printf("\n");
+	fflush(stdout);
+}
+
+int main(int argc, char **argv)
+{
+	fd_set rdfs;
+	int s = -1, t = -1;
+	struct sockaddr_can addr;
+	char if_name[IFNAMSIZ];
+	static struct can_isotp_options opts;
+	static struct can_isotp_ll_options llopts;
+	int r = 0;
+	int opt, quit = 0;
+	int color = 0;
+	int head = 0;
+	int timestamp = 0;
+	int format = FORMAT_DEFAULT;
+	canid_t src = NO_CAN_ID;
+	canid_t dst = NO_CAN_ID;
+	extern int optind, opterr, optopt;
+	static struct timeval tv, last_tv;
+
+	unsigned char buffer[4096];
+	int nbytes;
+
+	while ((opt = getopt(argc, argv, "s:d:x:X:h:ct:f:L:?")) != -1) {
+		switch (opt) {
+		case 's':
+			src = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				src |= CAN_EFF_FLAG;
+			break;
+
+		case 'd':
+			dst = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				dst |= CAN_EFF_FLAG;
+			break;
+
+		case 'x':
+			opts.flags |= CAN_ISOTP_EXTEND_ADDR;
+			opts.ext_address = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'X':
+			opts.flags |= CAN_ISOTP_RX_EXT_ADDR;
+			opts.rx_ext_address = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'f':
+			format = (atoi(optarg) & (FORMAT_ASCII | FORMAT_HEX));
+			break;
+
+		case 'L':
+			if (sscanf(optarg, "%hhu:%hhu:%hhu",
+						&llopts.mtu,
+						&llopts.tx_dl,
+						&llopts.tx_flags) != 3) {
+				printf("unknown link layer options '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(1);
+			}
+			break;
+
+		case 'h':
+			head = atoi(optarg);
+			break;
+
+		case 'c':
+			color = 1;
+			break;
+
+		case 't':
+			timestamp = optarg[0];
+			if ((timestamp != 'a') && (timestamp != 'A') &&
+			    (timestamp != 'd') && (timestamp != 'z')) {
+				printf("%s: unknown timestamp mode '%c' - ignored\n",
+				       basename(argv[0]), optarg[0]);
+				timestamp = 0;
+			}
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			goto out;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			goto out;
+		}
+	}
+
+	if ((argc - optind) != 1 || src == NO_CAN_ID || dst == NO_CAN_ID) {
+		print_usage(basename(argv[0]));
+		r = 1;
+		goto out;
+	}
+  
+	if ((opts.flags & CAN_ISOTP_RX_EXT_ADDR) && (!(opts.flags & CAN_ISOTP_EXTEND_ADDR))) {
+		print_usage(basename(argv[0]));
+		r = 1;
+		goto out;
+	}
+
+	if ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {
+		perror("socket");
+		r = 1;
+		goto out;
+	}
+
+	if ((t = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {
+		perror("socket");
+		r = 1;
+		goto out;
+	}
+
+	opts.flags |= CAN_ISOTP_LISTEN_MODE;
+
+	strncpy(if_name, argv[optind], IFNAMSIZ - 1);
+	if_name[IFNAMSIZ - 1] = '\0';
+
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = if_nametoindex(if_name);
+	if (!addr.can_ifindex) {
+		perror("if_nametoindex");
+		r = 1;
+		goto out;
+	}
+
+	setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));
+
+	addr.can_addr.tp.tx_id = src;
+	addr.can_addr.tp.rx_id = dst;
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		r = 1;
+		goto out;
+	}
+
+	if (opts.flags & CAN_ISOTP_RX_EXT_ADDR) {
+		/* flip extended address info due to separate rx ext addr */
+		__u8 tmpext;
+
+		tmpext = opts.ext_address;
+		opts.ext_address = opts.rx_ext_address;
+		opts.rx_ext_address = tmpext;
+	}
+
+	if ((setsockopt(t, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts))) < 0) {
+		perror("setsockopt");
+		r = 1;
+		goto out;
+	}
+
+	if ((llopts.mtu) && (setsockopt(t, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts))) < 0) {
+		perror("setsockopt");
+		r = 1;
+		goto out;
+	}
+
+	addr.can_addr.tp.tx_id = dst;
+	addr.can_addr.tp.rx_id = src;
+
+	if (bind(t, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		r = 1;
+		goto out;
+	}
+
+	while (!quit) {
+
+		FD_ZERO(&rdfs);
+		FD_SET(s, &rdfs);
+		FD_SET(t, &rdfs);
+		FD_SET(0, &rdfs);
+
+		if ((nbytes = select(t+1, &rdfs, NULL, NULL, NULL)) < 0) {
+			perror("select");
+			continue;
+		}
+
+		if (FD_ISSET(0, &rdfs)) {
+			getchar();
+			quit = 1;
+			printf("quit due to keyboard input.\n");
+		}
+
+		if (FD_ISSET(s, &rdfs)) {
+			nbytes = read(s, buffer, 4096);
+			if (nbytes < 0) {
+				perror("read socket s");
+				r = 1;
+				goto out;
+			}
+			if (nbytes > 4095) {
+				r = 1;
+				goto out;
+			}
+			printbuf(buffer, nbytes, color?2:0, timestamp, format,
+				 &tv, &last_tv, dst, s, if_name, head);
+		}
+
+		if (FD_ISSET(t, &rdfs)) {
+			nbytes = read(t, buffer, 4096);
+			if (nbytes < 0) {
+				perror("read socket t");
+				r = 1;
+				goto out;
+			}
+			if (nbytes > 4095) {
+				r = 1;
+				goto out;
+			}
+			printbuf(buffer, nbytes, color?1:0, timestamp, format,
+				 &tv, &last_tv, src, t, if_name, head);
+		}
+	}
+
+out:
+	if (s != -1)
+		close(s);
+	if (t != -1)
+		close(t);
+
+	return r;
+}
diff --git a/canutils/isotptun.c b/canutils/isotptun.c
new file mode 100644
index 0000000000..ee473fdf1c
--- /dev/null
+++ b/canutils/isotptun.c
@@ -0,0 +1,407 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * isotptun.c - IP over CAN ISO-TP (ISO15765-2) tunnel / proof-of-concept
+ *
+ * This program creates a Linux tunnel netdevice 'ctunX' and transfers the
+ * ethernet frames inside ISO15765-2 (unreliable) datagrams on CAN.
+ *
+ * Use e.g. "ifconfig ctun0 123.123.123.1 pointopoint 123.123.123.2 up"
+ * to create a point-to-point IP connection on CAN.
+ *
+ * Copyright (c) 2008 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <libgen.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/isotp.h>
+#include <linux/if_tun.h>
+
+/* Change this to whatever your daemon is called */
+#define DAEMON_NAME "isotptun"
+
+#define NO_CAN_ID 0xFFFFFFFFU
+#define DEFAULT_NAME "ctun%d"
+
+/* stay on 4095 bytes for the max. PDU length which is still much more than the standard ethernet MTU */
+#define MAX_PDU_LENGTH 4095
+#define BUF_LEN (MAX_PDU_LENGTH + 1)
+
+static volatile int running = 1;
+
+static void fake_syslog(int priority, const char *format, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "[%d] ", priority);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+typedef void (*syslog_t)(int priority, const char *format, ...);
+static syslog_t syslogger = syslog;
+
+void perror_syslog(const char *s)
+{
+	const char *colon = s ? ": " : "";
+	syslogger(LOG_ERR, "%s%s%s", s, colon, strerror(errno));
+}
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - IP over CAN ISO-TP (ISO15765-2) tunnel / proof-of-concept.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options] <CAN interface>\n\n", prg);
+	fprintf(stderr, "This program creates a Linux tunnel netdevice 'ctunX' and transfers the\n");
+	fprintf(stderr, "ethernet frames inside ISO15765-2 (unreliable) datagrams on CAN.\n\n");
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -s <can_id>   (source can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -d <can_id>   (destination can_id. Use 8 digits for extended IDs)\n");
+	fprintf(stderr, "         -n <name>     (name of created IP netdevice. Default: '%s')\n", DEFAULT_NAME);
+	fprintf(stderr, "         -x <addr>[:<rxaddr>]  (extended addressing / opt. separate rxaddr)\n");
+	fprintf(stderr, "         -L <mtu>:<tx_dl>:<tx_flags>  (link layer options for CAN FD)\n");
+	fprintf(stderr, "         -p [tx]:[rx]  (set and enable tx/rx padding bytes)\n");
+	fprintf(stderr, "         -P <mode>     (check rx padding for (l)ength (c)ontent (a)ll)\n");
+	fprintf(stderr, "         -t <time ns>  (transmit time in nanosecs)\n");
+	fprintf(stderr, "         -b <bs>       (blocksize. 0 = off)\n");
+	fprintf(stderr, "         -m <val>      (STmin in ms/ns. See spec.)\n");
+	fprintf(stderr, "         -w <num>      (max. wait frame transmissions.)\n");
+	fprintf(stderr, "         -D            (daemonize to background when tun device created)\n");
+	fprintf(stderr, "         -h            (half duplex mode.)\n");
+	fprintf(stderr, "         -v            (verbose mode. Print symbols for tunneled msgs.)\n");
+	fprintf(stderr, "\nCAN IDs and addresses are given and expected in hexadecimal values.\n");
+	fprintf(stderr, "Use e.g. 'ifconfig ctun0 123.123.123.1 pointopoint 123.123.123.2 up'\n");
+	fprintf(stderr, "to create a point-to-point IP connection on CAN.\n");
+	fprintf(stderr, "\n");
+}
+
+void sigterm(int signo)
+{
+	running = 0;
+}
+
+int main(int argc, char **argv)
+{
+	fd_set rdfs;
+	int s, t;
+	struct sockaddr_can addr;
+	struct ifreq ifr;
+	static struct can_isotp_options opts;
+	static struct can_isotp_fc_options fcopts;
+	static struct can_isotp_ll_options llopts;
+	int opt, ret;
+	extern int optind, opterr, optopt;
+	static int verbose;
+	unsigned char buffer[BUF_LEN];
+	static char name[sizeof(ifr.ifr_name)] = DEFAULT_NAME;
+	int nbytes;
+	int run_as_daemon = 0;
+
+	addr.can_addr.tp.tx_id = addr.can_addr.tp.rx_id = NO_CAN_ID;
+
+	while ((opt = getopt(argc, argv, "s:d:n:x:p:P:t:b:m:whL:vD?")) != -1) {
+		switch (opt) {
+		case 's':
+			addr.can_addr.tp.tx_id = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				addr.can_addr.tp.tx_id |= CAN_EFF_FLAG;
+			break;
+
+		case 'd':
+			addr.can_addr.tp.rx_id = strtoul(optarg, NULL, 16);
+			if (strlen(optarg) > 7)
+				addr.can_addr.tp.rx_id |= CAN_EFF_FLAG;
+			break;
+
+		case 'n':
+			if (strlen(optarg) > sizeof(name) - 1) {
+				print_usage(basename(argv[0]));
+				exit(EXIT_FAILURE);
+			}
+			/* ensure string termination */
+			memset(name, 0, sizeof(name));
+			strncpy(name, optarg, sizeof(name) - 1);
+			break;
+
+		case 'x':
+		{
+			int elements = sscanf(optarg, "%hhx:%hhx",
+					      &opts.ext_address,
+					      &opts.rx_ext_address);
+
+			if (elements == 1)
+				opts.flags |= CAN_ISOTP_EXTEND_ADDR;
+			else if (elements == 2)
+				opts.flags |= (CAN_ISOTP_EXTEND_ADDR | CAN_ISOTP_RX_EXT_ADDR);
+			else {
+				fprintf(stderr, "incorrect extended addr values '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(EXIT_FAILURE);
+			}
+			break;
+		}
+
+		case 'p':
+		{
+			int elements = sscanf(optarg, "%hhx:%hhx",
+					      &opts.txpad_content,
+					      &opts.rxpad_content);
+
+			if (elements == 1)
+				opts.flags |= CAN_ISOTP_TX_PADDING;
+			else if (elements == 2)
+				opts.flags |= (CAN_ISOTP_TX_PADDING | CAN_ISOTP_RX_PADDING);
+			else if (sscanf(optarg, ":%hhx", &opts.rxpad_content) == 1)
+				opts.flags |= CAN_ISOTP_RX_PADDING;
+			else {
+				fprintf(stderr, "incorrect padding values '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(EXIT_FAILURE);
+			}
+			break;
+		}
+
+		case 'P':
+			if (optarg[0] == 'l')
+				opts.flags |= CAN_ISOTP_CHK_PAD_LEN;
+			else if (optarg[0] == 'c')
+				opts.flags |= CAN_ISOTP_CHK_PAD_DATA;
+			else if (optarg[0] == 'a')
+				opts.flags |= (CAN_ISOTP_CHK_PAD_LEN | CAN_ISOTP_CHK_PAD_DATA);
+			else {
+				fprintf(stderr, "unknown padding check option '%c'.\n", optarg[0]);
+				print_usage(basename(argv[0]));
+				exit(EXIT_FAILURE);
+			}
+			break;
+
+		case 't':
+			opts.frame_txtime = strtoul(optarg, NULL, 10);
+			break;
+
+		case 'b':
+			fcopts.bs = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'm':
+			fcopts.stmin = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'w':
+			fcopts.wftmax = strtoul(optarg, NULL, 16) & 0xFF;
+			break;
+
+		case 'h':
+			opts.flags |= CAN_ISOTP_HALF_DUPLEX;
+			break;
+
+		case 'L':
+			if (sscanf(optarg, "%hhu:%hhu:%hhu",
+				   &llopts.mtu,
+				   &llopts.tx_dl,
+				   &llopts.tx_flags) != 3) {
+				fprintf(stderr, "unknown link layer options '%s'.\n", optarg);
+				print_usage(basename(argv[0]));
+				exit(EXIT_FAILURE);
+			}
+			break;
+
+		case 'v':
+			verbose = 1;
+			break;
+
+		case 'D':
+			run_as_daemon = 1;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			exit(EXIT_SUCCESS);
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			exit(EXIT_FAILURE);
+			break;
+		}
+	}
+
+	if ((argc - optind != 1) ||
+	    (addr.can_addr.tp.tx_id == NO_CAN_ID) ||
+	    (addr.can_addr.tp.rx_id == NO_CAN_ID)) {
+		print_usage(basename(argv[0]));
+		exit(EXIT_FAILURE);
+	}
+  
+	if (!run_as_daemon)
+		syslogger = fake_syslog;
+
+	/* Initialize the logging interface */
+	openlog(DAEMON_NAME, LOG_PID, LOG_LOCAL5);
+
+	if ((s = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP)) < 0) {
+		perror_syslog("socket");
+		exit(EXIT_FAILURE);
+	}
+
+	setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_OPTS, &opts, sizeof(opts));
+	setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_RECV_FC, &fcopts, sizeof(fcopts));
+
+	if (llopts.tx_dl) {
+		if (setsockopt(s, SOL_CAN_ISOTP, CAN_ISOTP_LL_OPTS, &llopts, sizeof(llopts)) < 0) {
+			perror_syslog("link layer sockopt");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = if_nametoindex(argv[optind]);
+	if (!addr.can_ifindex) {
+		perror_syslog("if_nametoindex");
+		close(s);
+		exit(EXIT_FAILURE);
+	}
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror_syslog("bind");
+		close(s);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((t = open("/dev/net/tun", O_RDWR)) < 0) {
+		perror_syslog("open tunfd");
+		close(s);
+		close(t);
+		exit(EXIT_FAILURE);
+	}
+
+	memset(&ifr, 0, sizeof(ifr));
+	ifr.ifr_flags = IFF_TUN | IFF_NO_PI;
+	/* string termination is ensured at commandline option handling */
+	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
+
+	if (ioctl(t, TUNSETIFF, (void *) &ifr) < 0) {
+		perror_syslog("ioctl tunfd");
+		close(s);
+		close(t);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Now the tun device exists. We can daemonize to let the
+	 * parent continue and use the network interface. */
+	if (run_as_daemon) {
+		if (daemon(0, 0)) {
+			syslogger(LOG_ERR, "failed to daemonize");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	signal(SIGTERM, sigterm);
+	signal(SIGHUP, sigterm);
+	signal(SIGINT, sigterm);
+
+	while (running) {
+
+		FD_ZERO(&rdfs);
+		FD_SET(s, &rdfs);
+		FD_SET(t, &rdfs);
+
+		if ((ret = select(t+1, &rdfs, NULL, NULL, NULL)) < 0) {
+			perror_syslog("select");
+			continue;
+		}
+
+		if (FD_ISSET(s, &rdfs)) {
+			nbytes = read(s, buffer, BUF_LEN);
+			if (nbytes < 0) {
+				perror_syslog("read isotp socket");
+				return -1;
+			}
+			if (nbytes > MAX_PDU_LENGTH)
+				return -1;
+			ret = write(t, buffer, nbytes);
+			if (verbose) {
+				if (ret < 0 && errno == EAGAIN)
+					printf(";");
+				else
+					printf(",");
+				fflush(stdout);
+			}
+		}
+
+		if (FD_ISSET(t, &rdfs)) {
+			nbytes = read(t, buffer, BUF_LEN);
+			if (nbytes < 0) {
+				perror_syslog("read tunfd");
+				return -1;
+			}
+			if (nbytes > MAX_PDU_LENGTH)
+				return -1;
+			ret = write(s, buffer, nbytes);
+			if (verbose) {
+				if (ret < 0 && errno == EAGAIN)
+					printf(":");
+				else
+					printf(".");
+				fflush(stdout);
+			}
+		}
+	}
+
+	close(s);
+	close(t);
+	return EXIT_SUCCESS;
+}
diff --git a/canutils/j1939acd.c b/canutils/j1939acd.c
new file mode 100644
index 0000000000..a1d7162140
--- /dev/null
+++ b/canutils/j1939acd.c
@@ -0,0 +1,653 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <errno.h>
+#include <inttypes.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <err.h>
+#include <getopt.h>
+#include <linux/can.h>
+#include <linux/can/j1939.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#include "libj1939.h"
+
+static const char help_msg[] =
+	"j1939acd: An SAE J1939 address claiming daemon" "\n"
+	"Usage: j1939acd [options] NAME [INTF]" "\n"
+	"Options:\n"
+	"  -v, --verbose		Increase verbosity" "\n"
+	"  -r, --range=RANGE	Ranges of source addresses" "\n"
+	"			e.g. 80,50-100,200-210 (defaults to 0-253)" "\n"
+	"  -c, --cache=FILE	Cache file to save/restore the source address" "\n"
+	"  -a, --address=ADDRESS	Start with Source Address ADDRESS" "\n"
+	"  -p, --prefix=STR	Prefix to use when logging" "\n"
+	"\n"
+	"NAME is the 64bit nodename" "\n"
+	"\n"
+	"Examples:" "\n"
+	"j1939acd -r 100,80-120 -c /tmp/1122334455667788.jacd 1122334455667788" "\n"
+	"j1939acd -r 100,80-120 -c /tmp/1122334455667788.jacd 1122334455667788 vcan0" "\n"
+	;
+
+#ifdef _GNU_SOURCE
+static struct option long_opts[] = {
+	{ "help", no_argument, NULL, '?', },
+	{ "verbose", no_argument, NULL, 'v', },
+	{ "range", required_argument, NULL, 'r', },
+	{ "cache", required_argument, NULL, 'c', },
+	{ "address", required_argument, NULL, 'a', },
+	{ "prefix", required_argument, NULL, 'p', },
+	{ },
+};
+#else
+#define getopt_long(argc, argv, optstring, longopts, longindex) \
+	getopt((argc), (argv), (optstring))
+#endif
+static const char optstring[] = "vr:c:a:p:?";
+
+/* byte swap functions */
+static inline int host_is_little_endian(void)
+{
+	static const uint16_t endian_test = 1;
+	return *(const uint8_t *)&endian_test;
+}
+
+static __attribute__((unused)) void bswap(void *vptr, int size)
+{
+	uint8_t *p0, *pe;
+	uint8_t tmp;
+
+	p0 = vptr;
+	pe = &p0[size-1];
+	for (; p0 < pe; ++p0, --pe) {
+		tmp = *p0;
+		*p0 = *pe;
+		*pe = tmp;
+	}
+}
+
+/* rate-limiting for errors */
+static inline int must_warn(int ret)
+{
+	if (ret >= 0)
+		return 0;
+	switch (errno) {
+	case EINTR:
+	case ENOBUFS:
+		return 0;
+	}
+	return 1;
+}
+
+/* global variables */
+static char default_range[] = "0x80-0xfd";
+static const char default_intf[] = "can0";
+
+static struct {
+	int verbose;
+	const char *cachefile;
+
+	const char *intf;
+	char *ranges;
+	uint64_t name;
+	uint8_t current_sa;
+	uint8_t last_sa;
+	int sig_term;
+	int sig_alrm;
+	int sig_usr1;
+	int state;
+		#define STATE_INITIAL 0
+		#define STATE_REQ_SENT 1
+		#define STATE_REQ_PENDING 2 /* wait 1250 msec for first claim */
+		#define STATE_OPERATIONAL 3
+} s = {
+	.intf = default_intf,
+	.ranges = default_range,
+	.current_sa = J1939_IDLE_ADDR,
+	.last_sa = J1939_NO_ADDR,
+};
+
+struct {
+	uint64_t name;
+	int flags;
+		#define F_USE	0x01
+		#define F_SEEN	0x02
+} addr[J1939_IDLE_ADDR /* =254 */];
+
+/* lookup by name */
+static int lookup_name(uint64_t name)
+{
+	int j;
+
+	for (j = 0; j < J1939_IDLE_ADDR; ++j) {
+		if (addr[j].name == name)
+			return j;
+	}
+	return J1939_IDLE_ADDR;
+
+}
+
+/* parse address range */
+static int parse_range(char *str)
+{
+	char *tok, *endp;
+	int a0, ae;
+	int j, cnt;
+
+	cnt = 0;
+	for (tok = strtok(str, ",;"); tok; tok = strtok(NULL, ",;")) {
+		a0 = ae = strtoul(tok, &endp, 0);
+		if (endp <= tok)
+			err(1, "parsing range '%s'", tok);
+		if (*endp == '-') {
+			tok = endp+1;
+			ae = strtoul(tok, &endp, 0);
+			if (endp <= tok)
+				err(1, "parsing addr '%s'", tok);
+			if (ae < a0)
+				ae = a0;
+		}
+		for (j = a0; j <= ae; ++j, ++cnt) {
+			if (j == J1939_IDLE_ADDR)
+				break;
+			addr[j].flags |= F_USE;
+		}
+	}
+	return cnt;
+}
+
+/* j1939 socket */
+static const struct j1939_filter filt[] = {
+	{
+		.pgn = J1939_PGN_ADDRESS_CLAIMED,
+		.pgn_mask = J1939_PGN_PDU1_MAX,
+	}, {
+		.pgn = J1939_PGN_REQUEST,
+		.pgn_mask = J1939_PGN_PDU1_MAX,
+	}, {
+		.pgn = J1939_PGN_ADDRESS_COMMANDED,
+		.pgn_mask = J1939_PGN_MAX,
+	},
+};
+
+static int open_socket(const char *device, uint64_t name)
+{
+	int ret, sock;
+	int value;
+	struct sockaddr_can saddr = {
+		.can_family = AF_CAN,
+		.can_addr.j1939 = {
+			.name = name,
+			.addr = J1939_IDLE_ADDR,
+			.pgn = J1939_NO_PGN,
+		},
+		.can_ifindex = if_nametoindex(device),
+	};
+
+	if (s.verbose)
+		fprintf(stderr, "- socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n");
+	sock = ret = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+	if (ret < 0)
+		err(1, "socket(j1939)");
+
+	if (s.verbose)
+		fprintf(stderr, "- setsockopt(, SOL_CAN_J1939, SO_J1939_FILTER, <filter>, %zd);\n", sizeof(filt));
+	ret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER,
+			&filt, sizeof(filt));
+	if (ret < 0)
+		err(1, "setsockopt filter");
+
+	value = 1;
+	if (s.verbose)
+		fprintf(stderr, "- setsockopt(, SOL_SOCKET, SO_BROADCAST, %d, %zd);\n", value, sizeof(value));
+	ret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST,
+			&value, sizeof(value));
+	if (ret < 0)
+		err(1, "setsockopt set broadcast");
+
+	if (s.verbose)
+		fprintf(stderr, "- bind(, %s, %zi);\n", libj1939_addr2str(&saddr), sizeof(saddr));
+	ret = bind(sock, (void *)&saddr, sizeof(saddr));
+	if (ret < 0)
+		err(1, "bind()");
+	return sock;
+}
+
+/* real IO function */
+static int repeat_address(int sock, uint64_t name)
+{
+	int ret;
+	uint8_t dat[8];
+	static const struct sockaddr_can saddr = {
+		.can_family = AF_CAN,
+		.can_addr.j1939 = {
+			.pgn = J1939_PGN_ADDRESS_CLAIMED,
+			.addr = J1939_NO_ADDR,
+		},
+	};
+
+	memcpy(dat, &name, 8);
+	if (!host_is_little_endian())
+		bswap(dat, 8);
+	if (s.verbose)
+		fprintf(stderr, "- send(, %" PRId64 ", 8, 0);\n", name);
+	ret = sendto(sock, dat, sizeof(dat), 0, (const struct sockaddr *)&saddr,
+		     sizeof(saddr));
+	if (must_warn(ret))
+		fprintf(stderr, "send address claim for 0x%02x\n", s.last_sa);
+	return ret;
+}
+static int claim_address(int sock, uint64_t name, int sa)
+{
+	int ret;
+	struct sockaddr_can saddr = {
+		.can_family = AF_CAN,
+		.can_addr.j1939 = {
+			.name = name,
+			.addr = sa,
+			.pgn = J1939_NO_PGN,
+		},
+		.can_ifindex = if_nametoindex(s.intf),
+	};
+
+	if (s.verbose)
+		fprintf(stderr, "- bind(, %s, %zi);\n", libj1939_addr2str(&saddr), sizeof(saddr));
+	ret = bind(sock, (void *)&saddr, sizeof(saddr));
+	if (ret < 0)
+		err(1, "rebind with sa 0x%02x", sa);
+	s.last_sa = sa;
+	return repeat_address(sock, name);
+}
+
+static int request_addresses(int sock)
+{
+	static const uint8_t dat[3] = { 0, 0xee, 0, };
+	int ret;
+	static const struct sockaddr_can saddr = {
+		.can_family = AF_CAN,
+		.can_addr.j1939.pgn = J1939_PGN_REQUEST,
+		.can_addr.j1939.addr = J1939_NO_ADDR,
+	};
+
+	if (s.verbose)
+		fprintf(stderr, "- sendto(, { 0, 0xee, 0, }, %zi, 0, %s, %zi);\n", sizeof(dat), libj1939_addr2str(&saddr), sizeof(saddr));
+	ret = sendto(sock, dat, sizeof(dat), 0, (void *)&saddr, sizeof(saddr));
+	if (must_warn(ret))
+		fprintf(stdout, "send request for address claims");
+	return ret;
+}
+
+/* real policy */
+static int choose_new_sa(uint64_t name, int sa)
+{
+	int j, cnt;
+
+	/* test current entry */
+	if ((sa < J1939_IDLE_ADDR) && (addr[sa].flags & F_USE)) {
+		j = sa;
+		if (!addr[j].name || (addr[j].name == name) || (addr[j].name > name))
+			return j;
+	}
+	/* take first empty spot */
+	for (j = 0; j < J1939_IDLE_ADDR; ++j) {
+		if (!(addr[j].flags & F_USE))
+			continue;
+		if (!addr[j].name || (addr[j].name == name))
+			return j;
+	}
+
+	/*
+	 * no empty spot found
+	 * take next (relative to @sa) spot that we can
+	 * successfully contest
+	 */
+	j = sa + 1;
+	for (cnt = 0; cnt < J1939_IDLE_ADDR; ++j, ++cnt) {
+		if (j >= J1939_IDLE_ADDR)
+			j = 0;
+		if (!(addr[j].flags & F_USE))
+			continue;
+		if (name < addr[j].name)
+			return j;
+	}
+	return J1939_IDLE_ADDR;
+}
+
+/* signa handling */
+static void sighandler(int sig, siginfo_t *info, void *vp)
+{
+	switch (sig) {
+	case SIGINT:
+	case SIGTERM:
+		s.sig_term = 1;
+		break;
+	case SIGALRM:
+		s.sig_alrm = 1;
+		break;
+	case SIGUSR1:
+		s.sig_usr1 = 1;
+		break;
+	}
+}
+
+static void install_signal(int sig)
+{
+	int ret;
+	struct sigaction sigact = {
+		.sa_sigaction = sighandler,
+		.sa_flags = SA_SIGINFO,
+	};
+
+	sigfillset(&sigact.sa_mask);
+	ret = sigaction(sig, &sigact, NULL);
+	if (ret < 0)
+		err(1, "sigaction for signal %i", sig);
+}
+
+static void schedule_itimer(int msec)
+{
+	int ret;
+	struct itimerval val = { 0 };
+
+	val.it_value.tv_sec = msec / 1000;
+	val.it_value.tv_usec = (msec % 1000) * 1000;
+
+	s.sig_alrm = 0;
+	do {
+		ret = setitimer(ITIMER_REAL, &val, NULL);
+	} while ((ret < 0) && (errno == EINTR));
+	if (ret < 0)
+		err(1, "setitimer %i msec", msec);
+}
+
+/* dump status */
+static inline int addr_status_mine(int sa)
+{
+	if (sa == s.current_sa)
+		return '*';
+	if (addr[sa].flags & F_USE)
+		return '+';
+	return '-';
+}
+
+static void dump_status(void)
+{
+	int j;
+
+	for (j = 0; j < J1939_IDLE_ADDR; ++j) {
+		if (!addr[j].flags && !addr[j].name)
+			continue;
+		fprintf(stdout, "%02x: %c", j, addr_status_mine(j));
+		if (addr[j].name)
+			fprintf(stdout, " %016llx", (long long)addr[j].name);
+		else
+			fprintf(stdout, " -");
+		fprintf(stdout, "\n");
+	}
+	fflush(stdout);
+}
+
+/* cache file */
+static void save_cache(void)
+{
+	FILE *fp;
+	time_t t;
+
+	if (!s.cachefile)
+		return;
+	fp = fopen(s.cachefile, "w");
+	if (!fp)
+		err(1, "fopen %s, w", s.cachefile);
+
+	time(&t);
+	fprintf(fp, "# saved on %s\n", ctime(&t));
+	fprintf(fp, "\n");
+	fprintf(fp, "0x%02x\n", s.current_sa);
+	fclose(fp);
+}
+
+static void restore_cache(void)
+{
+	FILE *fp;
+	int ret;
+	char *endp;
+	char *line = 0;
+	size_t sz = 0;
+
+	if (!s.cachefile)
+		return;
+	fp = fopen(s.cachefile, "r");
+	if (!fp) {
+		if (ENOENT == errno)
+			return;
+		err(1, "fopen %s, r", s.cachefile);
+	}
+	while (!feof(fp)) {
+		ret = getline(&line, &sz, fp);
+		if (ret <= 0)
+			continue;
+		if (line[0] == '#')
+			continue;
+		ret = strtoul(line, &endp, 0);
+		if ((endp > line) && (ret >= 0) && (ret <= J1939_IDLE_ADDR)) {
+			s.current_sa = ret;
+			break;
+		}
+	}
+	fclose(fp);
+	if (line)
+		free(line);
+}
+
+/* main */
+int main(int argc, char *argv[])
+{
+	int ret, sock, sock_rx, pgn, sa, opt;
+	socklen_t slen;
+	uint8_t dat[9];
+	struct sockaddr_can saddr;
+	uint64_t cmd_name;
+
+#ifdef _GNU_SOURCE
+	program_invocation_name = program_invocation_short_name;
+#endif
+	/* argument parsing */
+	while ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)
+		switch (opt) {
+		case 'v':
+			++s.verbose;
+			break;
+		case 'c':
+			s.cachefile = optarg;
+			break;
+		case 'r':
+			s.ranges = optarg;
+			break;
+		case 'a':
+			s.current_sa = strtoul(optarg, 0, 0);
+			break;
+		case 'p':
+#ifdef _GNU_SOURCE
+			if (asprintf(&program_invocation_name, "%s.%s",
+				     program_invocation_short_name, optarg) < 0)
+				err(1, "asprintf(program invocation name)");
+#else
+			err(0, "compile with -D_GNU_SOURCE to use -p");
+#endif
+			break;
+		default:
+			fputs(help_msg, stderr);
+			exit(1);
+			break;
+		}
+
+	if (argv[optind])
+		s.name = strtoull(argv[optind++], 0, 16);
+	if (argv[optind])
+		s.intf = argv[optind++];
+
+	/* args done */
+
+	restore_cache();
+
+	ret = parse_range(s.ranges);
+	if (!ret)
+		err(1, "no addresses in range");
+
+	if ((s.current_sa < J1939_IDLE_ADDR) && !(addr[s.current_sa].flags & F_USE)) {
+		if (s.verbose)
+			fprintf(stderr, "- forget saved address 0x%02x\n", s.current_sa);
+		s.current_sa = J1939_IDLE_ADDR;
+	}
+
+	if (s.verbose)
+		fprintf(stderr, "- ready for %s:%016llx\n", s.intf, (long long)s.name);
+	if (!s.intf || !s.name)
+		err(1, "bad arguments");
+	ret = sock = open_socket(s.intf, s.name);
+	sock_rx = open_socket(s.intf, s.name);
+
+	install_signal(SIGTERM);
+	install_signal(SIGINT);
+	install_signal(SIGALRM);
+	install_signal(SIGUSR1);
+	install_signal(SIGUSR2);
+
+	while (!s.sig_term) {
+		if (s.sig_usr1) {
+			s.sig_usr1 = 0;
+			dump_status();
+		}
+		switch (s.state) {
+		case STATE_INITIAL:
+			ret = request_addresses(sock);
+			if (ret < 0)
+				err(1, "could not sent initial request");
+			s.state = STATE_REQ_SENT;
+			break;
+		case STATE_REQ_PENDING:
+			if (!s.sig_alrm)
+				break;
+			s.sig_alrm = 0;
+			/* claim addr */
+			sa = choose_new_sa(s.name, s.current_sa);
+			if (sa == J1939_IDLE_ADDR)
+				err(1, "no free address to use");
+			ret = claim_address(sock, s.name, sa);
+			if (ret < 0)
+				schedule_itimer(50);
+			s.state = STATE_OPERATIONAL;
+			break;
+		case STATE_OPERATIONAL:
+			if (s.sig_alrm) {
+				s.sig_alrm = 0;
+				ret = repeat_address(sock, s.name);
+				if (ret < 0)
+					schedule_itimer(50);
+			}
+			break;
+		}
+
+		slen = sizeof(saddr);
+		ret = recvfrom(sock_rx, dat, sizeof(dat), 0, (void *)&saddr, &slen);
+		if (ret < 0) {
+			if (EINTR == errno)
+				continue;
+			err(1, "recvfrom()");
+		}
+		switch (saddr.can_addr.j1939.pgn) {
+		case J1939_PGN_REQUEST:
+			if (ret < 3)
+				break;
+			pgn = dat[0] + (dat[1] << 8) + ((dat[2] & 0x03) << 16);
+			if (pgn != J1939_PGN_ADDRESS_CLAIMED)
+				/* not interested */
+				break;
+			if (s.state == STATE_REQ_SENT) {
+				if (s.verbose)
+					fprintf(stderr, "- request sent, pending for 1250 ms\n");
+				schedule_itimer(1250);
+				s.state = STATE_REQ_PENDING;
+			} else if (s.state == STATE_OPERATIONAL) {
+				ret = claim_address(sock, s.name, s.current_sa);
+				if (ret < 0)
+					schedule_itimer(50);
+			}
+			break;
+		case J1939_PGN_ADDRESS_CLAIMED:
+			if (saddr.can_addr.j1939.addr >= J1939_IDLE_ADDR) {
+				sa = lookup_name(saddr.can_addr.j1939.name);
+				if (sa < J1939_IDLE_ADDR)
+					addr[sa].name = 0;
+				break;
+			}
+			sa = lookup_name(saddr.can_addr.j1939.name);
+			if ((sa != saddr.can_addr.j1939.addr) && (sa < J1939_IDLE_ADDR))
+				/* update cache */
+				addr[sa].name = 0;
+
+			/* shortcut */
+			sa = saddr.can_addr.j1939.addr;
+			addr[sa].name = saddr.can_addr.j1939.name;
+			addr[sa].flags |= F_SEEN;
+
+			if (s.name == saddr.can_addr.j1939.name) {
+				/* ourselves, disable itimer */
+				s.current_sa = sa;
+				if (s.verbose)
+					fprintf(stderr, "- claimed 0x%02x\n", sa);
+			} else if (sa == s.current_sa) {
+				if (s.verbose)
+					fprintf(stderr, "- address collision for 0x%02x\n", sa);
+				if (s.name > saddr.can_addr.j1939.name) {
+					sa = choose_new_sa(s.name, sa);
+					if (sa == J1939_IDLE_ADDR) {
+						fprintf(stdout, "no address left");
+						/* put J1939_IDLE_ADDR in cache file */
+						s.current_sa = sa;
+						goto done;
+					}
+				}
+				ret = claim_address(sock, s.name, sa);
+				if (ret < 0)
+					schedule_itimer(50);
+			}
+			break;
+		case J1939_PGN_ADDRESS_COMMANDED:
+			if (!host_is_little_endian())
+				bswap(dat, 8);
+			memcpy(&cmd_name, dat, 8);
+			if (cmd_name == s.name) {
+				ret = claim_address(sock, s.name, dat[8]);
+				if (ret < 0)
+					schedule_itimer(50);
+			}
+			break;
+		}
+	}
+done:
+	if (s.verbose)
+		fprintf(stderr, "- shutdown\n");
+	claim_address(sock, s.name, J1939_IDLE_ADDR);
+	save_cache();
+	return 0;
+}
+
diff --git a/canutils/j1939cat.c b/canutils/j1939cat.c
new file mode 100644
index 0000000000..34a8c03b51
--- /dev/null
+++ b/canutils/j1939cat.c
@@ -0,0 +1,790 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018 Pengutronix, Oleksij Rempel <o.rempel@pengutronix.de>
+ */
+
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <net/if.h>
+#include <poll.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <linux/errqueue.h>
+#include <linux/net_tstamp.h>
+#include <linux/netlink.h>
+#include <linux/socket.h>
+
+#include "libj1939.h"
+
+#define J1939_MAX_ETP_PACKET_SIZE (7 * 0x00ffffff)
+#define JCAT_BUF_SIZE (1000 * 1024)
+
+/*
+ * min()/max()/clamp() macros that also do
+ * strict type-checking.. See the
+ * "unnecessary" pointer comparison.
+ */
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+
+
+struct j1939cat_stats {
+	int err;
+	uint32_t tskey;
+	uint32_t send;
+	uint32_t total;
+	uint32_t pgn;
+	uint8_t sa;
+	uint8_t da;
+	uint64_t src_name;
+	uint64_t dst_name;
+};
+
+struct j1939cat_priv {
+	int sock;
+	int infile;
+	int outfile;
+	size_t max_transfer;
+	unsigned long repeat;
+	unsigned long round;
+	int todo_prio;
+
+	bool valid_peername;
+	bool todo_recv;
+	bool todo_filesize;
+	bool todo_connect;
+	int todo_broadcast;
+
+	unsigned long polltimeout;
+
+	struct sockaddr_can sockname;
+	struct sockaddr_can peername;
+
+	struct sock_extended_err *serr;
+	struct scm_timestamping *tss;
+	struct j1939cat_stats stats;
+	int32_t last_dpo;
+};
+
+static const char help_msg[] =
+	"j1939cat: netcat-like tool for j1939\n"
+	"Usage: j1939cat [options] FROM TO\n"
+	" FROM / TO	- or [IFACE][:[SA][,[PGN][,NAME]]]\n"
+	"Options:\n"
+	" -i <infile>	(default stdin)\n"
+	" -s <size>	Set maximal transfer size. Default: 117440505 byte\n"
+	" -r		Receive data\n"
+	" -P <timeout>  poll timeout in milliseconds before sending data.\n"
+	"		With this option send() will be used with MSG_DONTWAIT flag.\n"
+	" -R <count>	Set send repeat count. Default: 1\n"
+	" -B		Allow to send and receive broadcast packets.\n"
+	"\n"
+	"Example:\n"
+	"j1939cat -i some_file_to_send  can0:0x80 :0x90,0x12300\n"
+	"j1939cat can0:0x90 -r > /tmp/some_file_to_receive\n"
+	"\n"
+	;
+
+static const char optstring[] = "?hi:vs:rp:P:R:B";
+
+
+static void j1939cat_init_sockaddr_can(struct sockaddr_can *sac)
+{
+	sac->can_family = AF_CAN;
+	sac->can_addr.j1939.addr = J1939_NO_ADDR;
+	sac->can_addr.j1939.name = J1939_NO_NAME;
+	sac->can_addr.j1939.pgn = J1939_NO_PGN;
+}
+
+static ssize_t j1939cat_send_one(struct j1939cat_priv *priv, int out_fd,
+			     const void *buf, size_t buf_size)
+{
+	ssize_t num_sent;
+	int flags = 0;
+
+	if (priv->polltimeout)
+		flags |= MSG_DONTWAIT;
+
+	if (priv->valid_peername && !priv->todo_connect)
+		num_sent = sendto(out_fd, buf, buf_size, flags,
+				  (struct sockaddr *)&priv->peername,
+				  sizeof(priv->peername));
+	else
+		num_sent = send(out_fd, buf, buf_size, flags);
+
+	if (num_sent == -1) {
+		warn("%s: transfer error: %i", __func__, -errno);
+		return -errno;
+	}
+
+	if (num_sent == 0) /* Should never happen */ {
+		warn("%s: transferred 0 bytes", __func__);
+		return -EINVAL;
+	}
+
+	if (num_sent > (ssize_t)buf_size) /* Should never happen */ {
+		warn("%s: send more then read", __func__);
+		return -EINVAL;
+	}
+
+	return num_sent;
+}
+
+static void j1939cat_print_timestamp(struct j1939cat_priv *priv, const char *name,
+			      struct timespec *cur)
+{
+	struct j1939cat_stats *stats = &priv->stats;
+
+	if (!(cur->tv_sec | cur->tv_nsec))
+		return;
+
+	fprintf(stderr, "  %s: %lu s %lu us (seq=%03u, send=%07u)",
+			name, cur->tv_sec, cur->tv_nsec / 1000,
+			stats->tskey, stats->send);
+
+	fprintf(stderr, "\n");
+}
+
+static const char *j1939cat_tstype_to_str(int tstype)
+{
+	switch (tstype) {
+	case SCM_TSTAMP_SCHED:
+		return "TX ENQ";
+	case SCM_TSTAMP_SND:
+		return "TX SND";
+	case SCM_TSTAMP_ACK:
+		return "TX ACK";
+	default:
+		return "   unk";
+	}
+}
+
+/* Check the stats of SCM_TIMESTAMPING_OPT_STATS */
+static void j1939cat_scm_opt_stats(struct j1939cat_priv *priv, void *buf, int len)
+{
+	struct j1939cat_stats *stats = &priv->stats;
+	int offset = 0;
+
+	while (offset < len) {
+		struct nlattr *nla = (struct nlattr *) ((char *)buf + offset);
+
+		switch (nla->nla_type) {
+		case J1939_NLA_BYTES_ACKED:
+			stats->send = *(uint32_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		case J1939_NLA_TOTAL_SIZE:
+			stats->total = *(uint32_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		case J1939_NLA_PGN:
+			stats->pgn = *(uint32_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		case J1939_NLA_DEST_ADDR:
+			stats->da = *(uint8_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		case J1939_NLA_SRC_ADDR:
+			stats->sa = *(uint8_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		case J1939_NLA_DEST_NAME:
+			stats->dst_name = *(uint64_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		case J1939_NLA_SRC_NAME:
+			stats->src_name = *(uint64_t *)((char *)nla + NLA_HDRLEN);
+			break;
+		default:
+			warnx("not supported J1939_NLA field\n");
+		}
+
+		offset += NLA_ALIGN(nla->nla_len);
+	}
+}
+
+static int j1939cat_extract_serr(struct j1939cat_priv *priv)
+{
+	struct j1939cat_stats *stats = &priv->stats;
+	struct sock_extended_err *serr = priv->serr;
+	struct scm_timestamping *tss = priv->tss;
+
+	switch (serr->ee_origin) {
+	case SO_EE_ORIGIN_TIMESTAMPING:
+		/*
+		 * We expect here following patterns:
+		 *   serr->ee_info == SCM_TSTAMP_ACK
+		 *     Activated with SOF_TIMESTAMPING_TX_ACK
+		 * or
+		 *   serr->ee_info == SCM_TSTAMP_SCHED
+		 *     Activated with SOF_TIMESTAMPING_SCHED
+		 * and
+		 *   serr->ee_data == tskey
+		 *     session message counter which is activate
+		 *     with SOF_TIMESTAMPING_OPT_ID
+		 * the serr->ee_errno should be ENOMSG
+		 */
+		if (serr->ee_errno != ENOMSG)
+			warnx("serr: expected ENOMSG, got: %i",
+			      serr->ee_errno);
+		stats->tskey = serr->ee_data;
+
+		j1939cat_print_timestamp(priv, j1939cat_tstype_to_str(serr->ee_info),
+				     &tss->ts[0]);
+
+		if (serr->ee_info == SCM_TSTAMP_SCHED)
+			return -EINTR;
+		return 0;
+	case SO_EE_ORIGIN_LOCAL:
+		/*
+		 * The serr->ee_origin == SO_EE_ORIGIN_LOCAL is
+		 * currently used to notify about locally
+		 * detected protocol/stack errors.
+		 * Following patterns are expected:
+		 *   serr->ee_info == J1939_EE_INFO_TX_ABORT
+		 *     is used to notify about session TX
+		 *     abort.
+		 *   serr->ee_data == tskey
+		 *     session message counter which is activate
+		 *     with SOF_TIMESTAMPING_OPT_ID
+		 *   serr->ee_errno == actual error reason
+		 *     error reason is converted from J1939
+		 *     abort to linux error name space.
+		 */
+		switch (serr->ee_info) {
+		case J1939_EE_INFO_TX_ABORT:
+			j1939cat_print_timestamp(priv, "TX ABT", &tss->ts[0]);
+			warnx("serr: tx error: %i, %s", serr->ee_errno,
+			      strerror(serr->ee_errno));
+			return serr->ee_errno;
+		case J1939_EE_INFO_RX_RTS:
+			stats->tskey = serr->ee_data;
+			j1939cat_print_timestamp(priv, "RX RTS", &tss->ts[0]);
+			fprintf(stderr, "  total size: %u, pgn=0x%05x, sa=0x%02x, da=0x%02x src_name=0x%08" PRIx64 ", dst_name=0x%08" PRIx64 ")\n",
+				stats->total, stats->pgn,  stats->sa, stats->da,
+				stats->src_name, stats->dst_name);
+			priv->last_dpo = -1;
+			return 0;
+		case J1939_EE_INFO_RX_DPO:
+			stats->tskey = serr->ee_data;
+			j1939cat_print_timestamp(priv, "RX DPO", &tss->ts[0]);
+			if (stats->send <= (uint32_t)priv->last_dpo && priv->last_dpo != -1)
+				warnx("same dpo? current: %i, last: %i",
+				      stats->send, priv->last_dpo);
+			priv->last_dpo = stats->send;
+			return 0;
+		case J1939_EE_INFO_RX_ABORT:
+			j1939cat_print_timestamp(priv, "RX ABT", &tss->ts[0]);
+			warnx("serr: rx error: %i, %s", serr->ee_errno,
+			      strerror(serr->ee_errno));
+			return serr->ee_errno;
+		default:
+			warnx("serr: unknown ee_info: %i", serr->ee_info);
+			return -ENOTSUP;
+		}
+
+		break;
+	default:
+		warnx("serr: wrong origin: %u", serr->ee_origin);
+	}
+
+	return 0;
+}
+
+static int j1939cat_parse_cm(struct j1939cat_priv *priv, struct cmsghdr *cm)
+{
+	const size_t hdr_len = CMSG_ALIGN(sizeof(struct cmsghdr));
+
+	if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_TIMESTAMPING) {
+		priv->tss = (void *)CMSG_DATA(cm);
+	} else if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_TIMESTAMPING_OPT_STATS) {
+		void *jstats = (void *)CMSG_DATA(cm);
+
+		/* Activated with SOF_TIMESTAMPING_OPT_STATS */
+		j1939cat_scm_opt_stats(priv, jstats, cm->cmsg_len - hdr_len);
+	} else if (cm->cmsg_level == SOL_CAN_J1939 &&
+		   cm->cmsg_type == SCM_J1939_ERRQUEUE) {
+		priv->serr = (void *)CMSG_DATA(cm);
+	} else
+		warnx("serr: not supported type: %d.%d",
+		      cm->cmsg_level, cm->cmsg_type);
+
+	return 0;
+}
+
+static int j1939cat_recv_err(struct j1939cat_priv *priv)
+{
+	char control[200];
+	struct cmsghdr *cm;
+	int ret;
+	struct msghdr msg = {
+		.msg_control = control,
+		.msg_controllen = sizeof(control),
+	};
+
+	ret = recvmsg(priv->sock, &msg, MSG_ERRQUEUE);
+	if (ret == -1)
+		err(EXIT_FAILURE, "recvmsg error notification: %i", errno);
+	if (msg.msg_flags & MSG_CTRUNC)
+		err(EXIT_FAILURE, "recvmsg error notification: truncated");
+
+	priv->serr = NULL;
+	priv->tss = NULL;
+
+	for (cm = CMSG_FIRSTHDR(&msg); cm && cm->cmsg_len;
+	     cm = CMSG_NXTHDR(&msg, cm)) {
+		j1939cat_parse_cm(priv, cm);
+		if (priv->serr && priv->tss)
+			return j1939cat_extract_serr(priv);
+	}
+
+	return 0;
+}
+
+static int j1939cat_send_loop(struct j1939cat_priv *priv, int out_fd, char *buf,
+			  size_t buf_size)
+{
+	struct j1939cat_stats *stats = &priv->stats;
+	ssize_t count;
+	char *tmp_buf = buf;
+	unsigned int events = POLLOUT | POLLERR;
+	bool tx_done = false;
+
+	count = buf_size;
+
+	while (!tx_done) {
+		ssize_t num_sent = 0;
+
+		if (priv->polltimeout) {
+			struct pollfd fds = {
+				.fd = priv->sock,
+				.events = events,
+			};
+			int ret;
+
+			ret = poll(&fds, 1, priv->polltimeout);
+			if (ret == -1) {
+				if (errno == -EINTR)
+					continue;
+				else
+					return -errno;
+			}
+			if (!ret)
+				return -ETIME;
+			if (!(fds.revents & events)) {
+				warn("%s: something else is wrong %x %x", __func__, fds.revents, events);
+				return -EIO;
+			}
+
+			if (fds.revents & POLLERR) {
+				ret = j1939cat_recv_err(priv);
+				if (ret == -EINTR)
+					continue;
+				if (ret)
+					return ret;
+				if ((priv->repeat - 1) == stats->tskey)
+					tx_done = true;
+			}
+
+			if (fds.revents & POLLOUT) {
+				num_sent = j1939cat_send_one(priv, out_fd, tmp_buf, count);
+				if (num_sent < 0)
+					return num_sent;
+			}
+		} else {
+			num_sent = j1939cat_send_one(priv, out_fd, tmp_buf, count);
+			if (num_sent < 0)
+				return num_sent;
+		}
+
+		count -= num_sent;
+		tmp_buf += num_sent;
+		if (buf + buf_size < tmp_buf + count) {
+			warn("%s: send buffer is bigger than the read buffer",
+			     __func__);
+			return -EINVAL;
+		}
+		if (!count) {
+			if (priv->repeat == priv->round)
+				events = POLLERR;
+			else
+				tx_done = true;
+		}
+	}
+	return 0;
+}
+
+static int j1939cat_sendfile(struct j1939cat_priv *priv, int out_fd, int in_fd,
+			 off_t *offset, size_t count)
+{
+	int ret = EXIT_SUCCESS;
+	off_t orig = 0;
+	char *buf;
+	ssize_t num_read;
+	size_t to_read, buf_size;
+
+	buf_size = min(priv->max_transfer, count);
+	buf = malloc(buf_size);
+	if (!buf) {
+		warn("can't allocate buf");
+		ret = EXIT_FAILURE;
+		goto do_nofree;
+	}
+
+	if (offset) {
+
+		/* Save current file offset and set offset to value in '*offset' */
+
+		orig = lseek(in_fd, 0, SEEK_CUR);
+		if (orig == -1) {
+			ret = EXIT_FAILURE;
+			goto do_free;
+		}
+		if (lseek(in_fd, *offset, SEEK_SET) == -1) {
+			ret = EXIT_FAILURE;
+			goto do_free;
+		}
+	}
+
+	while (count > 0) {
+		to_read = min(buf_size, count);
+
+		num_read = read(in_fd, buf, to_read);
+		if (num_read == -1) {
+			ret = EXIT_FAILURE;
+			goto do_free;
+		}
+		if (num_read == 0)
+			break; /* EOF */
+
+		ret = j1939cat_send_loop(priv, out_fd, buf, num_read);
+		if (ret)
+			goto do_free;
+
+		count -= num_read;
+	}
+
+	if (offset) {
+		/* Return updated file offset in '*offset', and reset the file offset
+		   to the value it had when we were called. */
+
+		*offset = lseek(in_fd, 0, SEEK_CUR);
+		if (*offset == -1) {
+			ret = EXIT_FAILURE;
+			goto do_free;
+		}
+
+		if (lseek(in_fd, orig, SEEK_SET) == -1) {
+			ret = EXIT_FAILURE;
+			goto do_free;
+		}
+	}
+
+do_free:
+	free(buf);
+do_nofree:
+	return ret;
+}
+
+static size_t j1939cat_get_file_size(int fd)
+{
+	off_t offset;
+
+	offset = lseek(fd, 0, SEEK_END);
+	if (offset == -1)
+		err(1, "%s lseek()\n", __func__);
+
+	if (lseek(fd, 0, SEEK_SET) == -1)
+		err(1, "%s lseek() start\n", __func__);
+
+	return offset;
+}
+
+static int j1939cat_send(struct j1939cat_priv *priv)
+{
+	unsigned int size = 0;
+	unsigned int i;
+	int ret;
+
+	if (priv->todo_filesize)
+		size = j1939cat_get_file_size(priv->infile);
+
+	if (!size)
+		return EXIT_FAILURE;
+
+	for (i = 0; i < priv->repeat; i++) {
+		priv->round++;
+		ret = j1939cat_sendfile(priv, priv->sock, priv->infile, NULL, size);
+		if (ret)
+			break;
+
+		if (lseek(priv->infile, 0, SEEK_SET) == -1)
+			err(1, "%s lseek() start\n", __func__);
+	}
+
+	return ret;
+}
+
+static int j1939cat_recv_one(struct j1939cat_priv *priv, uint8_t *buf, size_t buf_size)
+{
+	int ret;
+
+	ret = recv(priv->sock, buf, buf_size, 0);
+	if (ret < 0) {
+		warn("recvf()");
+		return EXIT_FAILURE;
+	}
+
+	ret = write(priv->outfile, buf, ret);
+	if (ret < 0) {
+		warn("write stdout()");
+		return EXIT_FAILURE;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int j1939cat_recv(struct j1939cat_priv *priv)
+{
+	unsigned int events = POLLIN | POLLERR;
+	int ret = EXIT_SUCCESS;
+	size_t buf_size;
+	uint8_t *buf;
+
+	buf_size = priv->max_transfer;
+	buf = malloc(buf_size);
+	if (!buf) {
+		warn("can't allocate rx buf");
+		return EXIT_FAILURE;;
+	}
+
+	priv->last_dpo = -1;
+
+	while (priv->todo_recv) {
+		if (priv->polltimeout) {
+			struct pollfd fds = {
+				.fd = priv->sock,
+				.events = events,
+			};
+			int ret;
+
+			ret = poll(&fds, 1, priv->polltimeout);
+			if (ret == -1) {
+				if (errno == -EINTR)
+					continue;
+				else
+					return -errno;
+			}
+			if (!ret)
+				continue;
+			if (!(fds.revents & events)) {
+				warn("%s: something else is wrong %x %x", __func__, fds.revents, events);
+				return -EIO;
+			}
+
+			if (fds.revents & POLLERR) {
+				ret = j1939cat_recv_err(priv);
+				if (ret == -EINTR)
+					continue;
+				if (ret)
+					return ret;
+			}
+
+			if (fds.revents & POLLIN) {
+				ret = j1939cat_recv_one(priv, buf, buf_size);
+				if (ret < 0)
+					break;
+			}
+		} else {
+			ret = j1939cat_recv_one(priv, buf, buf_size);
+			if (ret)
+				break;
+		}
+	}
+
+	free(buf);
+	return ret;
+}
+
+static int j1939cat_sock_prepare(struct j1939cat_priv *priv)
+{
+	unsigned int sock_opt;
+	int value;
+	int ret;
+
+	/* open socket */
+	priv->sock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+	if (priv->sock < 0) {
+		warn("socket(j1939)");
+		return EXIT_FAILURE;
+	}
+
+	if (priv->todo_prio >= 0) {
+		ret = setsockopt(priv->sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO,
+				&priv->todo_prio, sizeof(priv->todo_prio));
+		if (ret < 0) {
+			warn("set priority %i", priv->todo_prio);
+			return EXIT_FAILURE;
+		}
+	}
+
+	value = 1;
+	ret = setsockopt(priv->sock, SOL_CAN_J1939, SO_J1939_ERRQUEUE, &value,
+			 sizeof(value));
+	if (ret < 0) {
+		warn("set recverr");
+		return EXIT_FAILURE;
+	}
+
+	sock_opt = SOF_TIMESTAMPING_SOFTWARE |
+		   SOF_TIMESTAMPING_OPT_CMSG |
+		   SOF_TIMESTAMPING_TX_ACK |
+		   SOF_TIMESTAMPING_TX_SCHED |
+		   SOF_TIMESTAMPING_OPT_STATS | SOF_TIMESTAMPING_OPT_TSONLY |
+		   SOF_TIMESTAMPING_OPT_ID | SOF_TIMESTAMPING_RX_SOFTWARE;
+
+	if (setsockopt(priv->sock, SOL_SOCKET, SO_TIMESTAMPING,
+		       (char *) &sock_opt, sizeof(sock_opt)))
+		err(1, "setsockopt timestamping");
+
+	if (priv->todo_broadcast) {
+		ret = setsockopt(priv->sock, SOL_SOCKET, SO_BROADCAST,
+				 &priv->todo_broadcast,
+				 sizeof(priv->todo_broadcast));
+		if (ret < 0) {
+			warn("setsockopt: filed to set broadcast");
+			return EXIT_FAILURE;
+		}
+	}
+
+	ret = bind(priv->sock, (void *)&priv->sockname, sizeof(priv->sockname));
+	if (ret < 0) {
+		warn("bind()");
+		return EXIT_FAILURE;
+	}
+
+	if (!priv->todo_connect)
+		return EXIT_SUCCESS;
+
+	if (!priv->valid_peername) {
+		warn("no peername supplied");
+		return EXIT_FAILURE;
+	}
+	ret = connect(priv->sock, (void *)&priv->peername,
+		      sizeof(priv->peername));
+	if (ret < 0) {
+		warn("connect()");
+		return EXIT_FAILURE;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int j1939cat_parse_args(struct j1939cat_priv *priv, int argc, char *argv[])
+{
+	int opt;
+
+	/* argument parsing */
+	while ((opt = getopt(argc, argv, optstring)) != -1)
+		switch (opt) {
+		case 'i':
+			priv->infile = open(optarg, O_RDONLY);
+			if (priv->infile == -1)
+				err(EXIT_FAILURE, "can't open input file");
+			priv->todo_filesize = 1;
+			break;
+		case 's':
+			priv->max_transfer = strtoul(optarg, NULL, 0);
+			if (priv->max_transfer > J1939_MAX_ETP_PACKET_SIZE)
+				err(EXIT_FAILURE,
+				    "used value (%zu) is bigger then allowed maximal size: %u.\n",
+				    priv->max_transfer,
+				    J1939_MAX_ETP_PACKET_SIZE);
+			break;
+		case 'r':
+			priv->todo_recv = 1;
+			break;
+		case 'p':
+			priv->todo_prio = strtoul(optarg, NULL, 0);
+			break;
+		case 'P':
+			priv->polltimeout = strtoul(optarg, NULL, 0);
+			break;
+		case 'c':
+			priv->todo_connect = 1;
+			break;
+		case 'R':
+			priv->repeat = strtoul(optarg, NULL, 0);
+			if (priv->repeat < 1)
+				err(EXIT_FAILURE,
+				    "send/repeat count can't be less then 1\n");
+			break;
+		case 'B':
+			priv->todo_broadcast = 1;
+			break;
+		case 'h': /*fallthrough*/
+		default:
+			fputs(help_msg, stderr);
+			return EXIT_FAILURE;
+		}
+
+	if (argv[optind]) {
+		if (strcmp("-", argv[optind]) != 0)
+			libj1939_parse_canaddr(argv[optind], &priv->sockname);
+		optind++;
+	}
+
+	if (argv[optind]) {
+		if (strcmp("-", argv[optind]) != 0) {
+			libj1939_parse_canaddr(argv[optind], &priv->peername);
+			priv->valid_peername = 1;
+		}
+		optind++;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+int main(int argc, char *argv[])
+{
+	struct j1939cat_priv *priv;
+	int ret = 0;
+
+	priv = calloc(1, sizeof(*priv));
+	if (!priv)
+		err(EXIT_FAILURE, "can't allocate priv");
+
+	priv->todo_prio = -1;
+	priv->infile = STDIN_FILENO;
+	priv->outfile = STDOUT_FILENO;
+	priv->max_transfer = J1939_MAX_ETP_PACKET_SIZE;
+	priv->polltimeout = 100000;
+	priv->repeat = 1;
+
+	j1939cat_init_sockaddr_can(&priv->sockname);
+	j1939cat_init_sockaddr_can(&priv->peername);
+
+	ret = j1939cat_parse_args(priv, argc, argv);
+	if (ret)
+		return ret;
+
+	ret = j1939cat_sock_prepare(priv);
+	if (ret)
+		return ret;
+
+	if (priv->todo_recv)
+		ret = j1939cat_recv(priv);
+	else
+		ret = j1939cat_send(priv);
+
+	close(priv->infile);
+	close(priv->outfile);
+	close(priv->sock);
+
+	return ret;
+}
diff --git a/canutils/j1939spy.c b/canutils/j1939spy.c
new file mode 100644
index 0000000000..e49ed14f74
--- /dev/null
+++ b/canutils/j1939spy.c
@@ -0,0 +1,305 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <err.h>
+#include <getopt.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#include "libj1939.h"
+
+/*
+ * getopt
+ */
+static const char help_msg[] =
+	"j1939spy: An SAE J1939 spy utility" "\n"
+	"Usage: j1939spy [OPTION...] [[IFACE:][NAME|SA][,PGN]]" "\n"
+	"Options:\n"
+	"  -v, --verbose		Increase verbosity" "\n"
+	"  -P, --promisc		Run in promiscuous mode" "\n"
+	"			(= receive traffic not for this ECU)" "\n"
+	"  -b, --block=SIZE	Use a receive buffer of SIZE (default 1024)" "\n"
+	"  -t, --time[=a|d|z|A]	Show time: (a)bsolute, (d)elta, (z)ero, (A)bsolute w date" "\n"
+	;
+
+#ifdef _GNU_SOURCE
+static struct option long_opts[] = {
+	{ "help", no_argument, NULL, '?', },
+	{ "verbose", no_argument, NULL, 'v', },
+
+	{ "promisc", no_argument, NULL, 'P', },
+	{ "block", required_argument, NULL, 'b', },
+	{ "time", optional_argument, NULL, 't', },
+	{ },
+};
+#else
+#define getopt_long(argc, argv, optstring, longopts, longindex) \
+	getopt((argc), (argv), (optstring))
+#endif
+static const char optstring[] = "vPb:t::?";
+
+/*
+ * static variables
+ */
+static struct {
+	int verbose;
+	struct sockaddr_can addr;
+	int promisc;
+	int time;
+	int pkt_len;
+} s = {
+	.pkt_len = 1024,
+	.addr.can_addr.j1939 = {
+		.name = J1939_NO_NAME,
+		.addr = J1939_NO_ADDR,
+		.pgn = J1939_NO_PGN,
+	},
+};
+
+/*
+ * useful buffers
+ */
+static const int ival_1 = 1;
+
+static char ctrlmsg[
+	  CMSG_SPACE(sizeof(struct timeval))
+	+ CMSG_SPACE(sizeof(uint8_t)) /* dest addr */
+	+ CMSG_SPACE(sizeof(uint64_t)) /* dest name */
+	+ CMSG_SPACE(sizeof(uint8_t)) /* priority */
+	];
+static struct iovec iov;
+static struct msghdr msg;
+static struct cmsghdr *cmsg;
+static uint8_t *buf;
+
+/*
+ * program
+ */
+int main(int argc, char **argv)
+{
+	int ret, sock, opt;
+	unsigned int j, len;
+	struct timeval tref, tdut, ttmp;
+	struct sockaddr_can src;
+	struct j1939_filter filt;
+	int filter = 0;
+	uint8_t priority, dst_addr;
+	uint64_t dst_name;
+	long recvflags;
+
+	/* argument parsing */
+	while ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)
+		switch (opt) {
+		case 'v':
+			++s.verbose;
+			break;
+		case 'b':
+			s.pkt_len = strtoul(optarg, 0, 0);
+			break;
+		case 'P':
+			++s.promisc;
+			break;
+		case 't':
+			if (optarg) {
+				if (!strchr("adzA", optarg[0]))
+					err(1, "unknown time option '%c'",
+					    optarg[0]);
+				s.time = optarg[0];
+			} else {
+				s.time = 'z';
+			}
+			break;
+		default:
+			fputs(help_msg, stderr);
+			exit(1);
+			break;
+		}
+
+	if (argv[optind]) {
+		optarg = argv[optind];
+		ret = libj1939_str2addr(optarg, 0, &s.addr);
+		if (ret < 0) {
+			err(0, "bad URI %s", optarg);
+			return 1;
+		}
+	}
+
+	buf = malloc(s.pkt_len);
+	if (!buf)
+		err(1, "malloc %u", s.pkt_len);
+
+	/* setup socket */
+	sock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+	if (sock < 0)
+		err(1, "socket(can, dgram, j1939)");
+
+	memset(&filt, 0, sizeof(filt));
+	if (s.addr.can_addr.j1939.name) {
+		filt.name = s.addr.can_addr.j1939.name;
+		filt.name_mask = ~0ULL;
+		++filter;
+	}
+	if (s.addr.can_addr.j1939.addr < 0xff) {
+		filt.addr = s.addr.can_addr.j1939.addr;
+		filt.addr_mask = ~0;
+		++filter;
+	}
+	if (s.addr.can_addr.j1939.pgn <= J1939_PGN_MAX) {
+		filt.pgn = s.addr.can_addr.j1939.pgn;
+		filt.pgn_mask = ~0;
+		++filter;
+	}
+	if (filter) {
+		ret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_FILTER, &filt, sizeof(filt));
+		if (ret < 0)
+			err(1, "setsockopt filter");
+	}
+
+	if (s.promisc) {
+		ret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_PROMISC, &ival_1, sizeof(ival_1));
+		if (ret < 0)
+			err(1, "setsockopt promisc");
+	}
+
+	if (s.time) {
+		ret = setsockopt(sock, SOL_SOCKET, SO_TIMESTAMP, &ival_1, sizeof(ival_1));
+		if (ret < 0)
+			err(1, "setsockopt timestamp");
+	}
+	ret = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &s.pkt_len, sizeof(s.pkt_len));
+		if (ret < 0)
+			err(1, "setsockopt rcvbuf %u", s.pkt_len);
+
+	/* bind(): to default, only ifindex is used. */
+	memset(&src, 0, sizeof(src));
+	src.can_ifindex = s.addr.can_ifindex;
+	src.can_family = AF_CAN;
+	src.can_addr.j1939.name = J1939_NO_NAME;
+	src.can_addr.j1939.addr = J1939_NO_ADDR;
+	src.can_addr.j1939.pgn = J1939_NO_PGN;
+	ret = bind(sock, (void *)&src, sizeof(src));
+	if (ret < 0)
+		err(1, "bind(%s)", argv[1]);
+
+	/* these settings are static and can be held out of the hot path */
+	iov.iov_base = &buf[0];
+	msg.msg_name = &src;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = &ctrlmsg;
+
+	memset(&tref, 0, sizeof(tref));
+	if (s.verbose)
+		err(0, "listening");
+	while (1) {
+		/* these settings may be modified by recvmsg() */
+		iov.iov_len = s.pkt_len;
+		msg.msg_namelen = sizeof(src);
+		msg.msg_controllen = sizeof(ctrlmsg);
+		msg.msg_flags = 0;
+
+		ret = recvmsg(sock, &msg, 0);
+		//ret = recvfrom(buf, s.pkt_len, 0, (void *)&addr, &len);
+		if (ret < 0) {
+			switch (errno) {
+			case ENETDOWN:
+				err(0, "ifindex %i", s.addr.can_ifindex);
+				continue;
+			case EINTR:
+				continue;
+			default:
+				err(1, "recvmsg(ifindex %i)", s.addr.can_ifindex);
+				break;
+			}
+		}
+		len = ret;
+		recvflags = 0;
+		dst_addr = 0;
+		priority = 0;
+		for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+			switch (cmsg->cmsg_level) {
+			case SOL_SOCKET:
+				if (cmsg->cmsg_type == SCM_TIMESTAMP) {
+					memcpy(&tdut, CMSG_DATA(cmsg), sizeof(tdut));
+					recvflags |= 1 << cmsg->cmsg_type;
+				}
+				break;
+			case SOL_CAN_J1939:
+				recvflags |= 1 << cmsg->cmsg_type;
+				if (cmsg->cmsg_type == SCM_J1939_DEST_ADDR)
+					dst_addr = *CMSG_DATA(cmsg);
+				else if (cmsg->cmsg_type == SCM_J1939_DEST_NAME)
+					memcpy(&dst_name, CMSG_DATA(cmsg), cmsg->cmsg_len - CMSG_LEN(0));
+				else if (cmsg->cmsg_type == SCM_J1939_PRIO)
+					priority = *CMSG_DATA(cmsg);
+				break;
+			}
+
+		}
+		if (recvflags & (1 << SCM_TIMESTAMP)) {
+			if ('z' == s.time) {
+				if (!tref.tv_sec)
+					tref = tdut;
+				timersub(&tdut, &tref, &ttmp);
+				tdut = ttmp;
+				goto abs_time;
+			} else if ('d' == s.time) {
+				timersub(&tdut, &tref, &ttmp);
+				tref = tdut;
+				tdut = ttmp;
+				goto abs_time;
+			} else if ('a' == s.time) {
+				abs_time:
+				printf("(%lu.%04lu)", tdut.tv_sec, tdut.tv_usec / 100);
+			} else if ('A' == s.time) {
+				struct tm tm;
+				tm = *localtime(&tdut.tv_sec);
+				printf("(%04u%02u%02uT%02u%02u%02u.%04lu)",
+					tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+					tm.tm_hour, tm.tm_min, tm.tm_sec,
+					tdut.tv_usec/100);
+			}
+		}
+		printf(" %s ", libj1939_addr2str(&src));
+		if (recvflags & (1 << SCM_J1939_DEST_NAME))
+			printf("%016llx ", (unsigned long long)dst_name);
+		else if (recvflags & (1 << SCM_J1939_DEST_ADDR))
+			printf("%02x ", dst_addr);
+		else
+			printf("- ");
+		printf("!%u ", priority);
+
+		printf("[%i%s]", len, (msg.msg_flags & MSG_TRUNC) ? "..." : "");
+		for (j = 0; j < len; ) {
+			unsigned int end = j + 4;
+			if (end > len)
+				end = len;
+			printf(" ");
+			for (; j < end; ++j)
+				printf("%02x", buf[j]);
+		}
+		printf("\n");
+	}
+
+	free(buf);
+	return 0;
+}
+
diff --git a/canutils/j1939sr.c b/canutils/j1939sr.c
new file mode 100644
index 0000000000..cdf6da5744
--- /dev/null
+++ b/canutils/j1939sr.c
@@ -0,0 +1,222 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <err.h>
+#include <getopt.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "libj1939.h"
+
+/*
+ * getopt
+ */
+static const char help_msg[] =
+	"j1939sr: An SAE J1939 send/recv utility" "\n"
+	"Usage: j1939sr [OPTION...] SOURCE [DEST]" "\n"
+	"Options:\n"
+	"  -v, --verbose		Increase verbosity" "\n"
+	"  -p, --priority=VAL	J1939 priority (0..7, default 6)" "\n"
+	"  -S, --serialize	Strictly serialize outgoing packets" "\n"
+	"  -s, --size		Packet size, default autodetected" "\n"
+	"\n"
+	"  SOURCE	[IFACE:][NAME|SA][,PGN]" "\n"
+	"  DEST			[NAME|SA]" "\n"
+	;
+
+#ifdef _GNU_SOURCE
+static struct option long_opts[] = {
+	{ "help", no_argument, NULL, '?', },
+	{ "verbose", no_argument, NULL, 'v', },
+
+	{ "priority", required_argument, NULL, 'p', },
+	{ "size", required_argument, NULL, 's', },
+	{ "serialize", no_argument, NULL, 'S', },
+	{ },
+};
+#else
+#define getopt_long(argc, argv, optstring, longopts, longindex) \
+	getopt((argc), (argv), (optstring))
+#endif
+static const char optstring[] = "vp:s:S?";
+
+/*
+ * static variables: configurations
+ */
+static struct {
+	int verbose;
+	int sendflags; /* flags for sendto() */
+	int pkt_len;
+	int priority;
+	int defined;
+	#define DEF_SRC		1
+	#define DEF_DST		2
+	#define DEF_PRIO	4
+	struct sockaddr_can src, dst;
+} s = {
+	.priority = 6,
+	.src.can_addr.j1939 = {
+		.name = J1939_NO_NAME,
+		.addr = J1939_NO_ADDR,
+		.pgn = J1939_NO_PGN,
+	},
+	.dst.can_addr.j1939 = {
+		.name = J1939_NO_NAME,
+		.addr = J1939_NO_ADDR,
+		.pgn = J1939_NO_PGN,
+	},
+};
+
+int main(int argc, char **argv)
+{
+
+	int ret, sock, opt;
+	unsigned int len;
+	struct pollfd pfd[2];
+	uint8_t *buf;
+
+#ifdef _GNU_SOURCE
+	program_invocation_name = program_invocation_short_name;
+#endif
+	/* argument parsing */
+	while ((opt = getopt_long(argc, argv, optstring, long_opts, NULL)) != -1)
+		switch (opt) {
+		case 'v':
+			++s.verbose;
+			break;
+		case 's':
+			s.pkt_len = strtoul(optarg, 0, 0);
+			if (!s.pkt_len)
+				err(1, "packet size of %s", optarg);
+			break;
+		case 'p':
+			s.priority = strtoul(optarg, 0, 0);
+			s.defined |= DEF_PRIO;
+			break;
+		case 'S':
+			s.sendflags |= MSG_SYN;
+			break;
+		default:
+			fputs(help_msg, stderr);
+			exit(1);
+			break;
+		}
+
+	if (argv[optind]) {
+		optarg = argv[optind++];
+		ret = libj1939_str2addr(optarg, 0, &s.src);
+		if (ret < 0)
+			err(1, "bad address spec [%s]", optarg);
+		s.defined |= DEF_SRC;
+	}
+	if (argv[optind]) {
+		optarg = argv[optind++];
+		ret = libj1939_str2addr(optarg, 0, &s.dst);
+		if (ret < 0)
+			err(1, "bad address spec [%s]", optarg);
+		s.defined |= DEF_DST;
+	}
+
+	if (!s.pkt_len) {
+		struct stat st;
+
+		if (fstat(STDIN_FILENO, &st) < 0)
+			err(1, "stat stdin, could not determine buffer size");
+		s.pkt_len = st.st_size ?: 1024;
+	}
+
+	/* prepare */
+	buf = malloc(s.pkt_len);
+	if (!buf)
+		err(1, "malloc %u", s.pkt_len);
+
+	sock = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+	if (sock < 0)
+		err(1, "socket(can, dgram, j1939)");
+
+	if (s.defined & DEF_PRIO) {
+		ret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO, &s.priority, sizeof(s.priority));
+		if (ret < 0)
+			err(1, "setsockopt priority");
+	}
+	if (s.defined & DEF_SRC) {
+		s.src.can_family = AF_CAN;
+		ret = bind(sock, (void *)&s.src, sizeof(s.src));
+		if (ret < 0)
+			err(1, "bind(%s), %i", libj1939_addr2str(&s.src), -errno);
+	}
+
+	if (s.defined & DEF_DST) {
+		s.dst.can_family = AF_CAN;
+		ret = connect(sock, (void *)&s.dst, sizeof(s.dst));
+		if (ret < 0)
+			err(1, "connect(%s), %i", libj1939_addr2str(&s.dst), -errno);
+	}
+
+	pfd[0].fd = STDIN_FILENO;
+	pfd[0].events = POLLIN;
+	pfd[1].fd = sock;
+	pfd[1].events = POLLIN;
+
+	/* run */
+	while (1) {
+		ret = poll(pfd, sizeof(pfd)/sizeof(pfd[0]), -1);
+		if (ret < 0) {
+			if (errno == EINTR)
+				continue;
+			err(1, "poll()");
+		}
+		if (pfd[0].revents) {
+			ret = read(pfd[0].fd, buf, s.pkt_len);
+			if (ret < 0)
+				err(1, "read(stdin)");
+			if (!ret)
+				break;
+			len = ret;
+			do {
+				ret = send(pfd[1].fd, buf, len, s.sendflags);
+				if (ret < 0 && errno != ENOBUFS)
+					err(1, "write(%s)", libj1939_addr2str(&s.src));
+			} while (ret < 0);
+		}
+		if (pfd[1].revents) {
+			ret = read(pfd[1].fd, buf, s.pkt_len);
+			if (ret < 0) {
+				ret = errno;
+				err(0, "read(%s)", libj1939_addr2str(&s.dst));
+				switch (ret) {
+				case EHOSTDOWN:
+					break;
+				default:
+					exit(1);
+				}
+			} else {
+				if (write(STDOUT_FILENO, buf, ret) < 0)
+					err(1, "write(stdout)");
+			}
+		}
+	}
+
+	free(buf);
+	return 0;
+}
+
diff --git a/canutils/lib.c b/canutils/lib.c
new file mode 100644
index 0000000000..3c1a0d9491
--- /dev/null
+++ b/canutils/lib.c
@@ -0,0 +1,687 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * lib.c - library for command line tools
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <linux/can.h>
+#include <linux/can/error.h>
+#include <sys/socket.h> /* for sa_family_t */
+
+#include "lib.h"
+
+#define CANID_DELIM '#'
+#define CC_DLC_DELIM '_'
+#define DATA_SEPERATOR '.'
+
+const char hex_asc_upper[] = "0123456789ABCDEF";
+
+#define hex_asc_upper_lo(x)	hex_asc_upper[((x) & 0x0F)]
+#define hex_asc_upper_hi(x)	hex_asc_upper[((x) & 0xF0) >> 4]
+
+static inline void put_hex_byte(char *buf, __u8 byte)
+{
+	buf[0] = hex_asc_upper_hi(byte);
+	buf[1] = hex_asc_upper_lo(byte);
+}
+
+static inline void _put_id(char *buf, int end_offset, canid_t id)
+{
+	/* build 3 (SFF) or 8 (EFF) digit CAN identifier */
+	while (end_offset >= 0) {
+		buf[end_offset--] = hex_asc_upper_lo(id);
+		id >>= 4;
+	}
+}
+
+#define put_sff_id(buf, id) _put_id(buf, 2, id)
+#define put_eff_id(buf, id) _put_id(buf, 7, id)
+
+/* CAN DLC to real data length conversion helpers */
+
+static const unsigned char dlc2len[] = {0, 1, 2, 3, 4, 5, 6, 7,
+					8, 12, 16, 20, 24, 32, 48, 64};
+
+/* get data length from raw data length code (DLC) */
+unsigned char can_fd_dlc2len(unsigned char dlc)
+{
+	return dlc2len[dlc & 0x0F];
+}
+
+static const unsigned char len2dlc[] = {0, 1, 2, 3, 4, 5, 6, 7, 8,		/* 0 - 8 */
+					9, 9, 9, 9,				/* 9 - 12 */
+					10, 10, 10, 10,				/* 13 - 16 */
+					11, 11, 11, 11,				/* 17 - 20 */
+					12, 12, 12, 12,				/* 21 - 24 */
+					13, 13, 13, 13, 13, 13, 13, 13,		/* 25 - 32 */
+					14, 14, 14, 14, 14, 14, 14, 14,		/* 33 - 40 */
+					14, 14, 14, 14, 14, 14, 14, 14,		/* 41 - 48 */
+					15, 15, 15, 15, 15, 15, 15, 15,		/* 49 - 56 */
+					15, 15, 15, 15, 15, 15, 15, 15};	/* 57 - 64 */
+
+/* map the sanitized data length to an appropriate data length code */
+unsigned char can_fd_len2dlc(unsigned char len)
+{
+	if (len > 64)
+		return 0xF;
+
+	return len2dlc[len];
+}
+
+unsigned char asc2nibble(char c) {
+
+	if ((c >= '0') && (c <= '9'))
+		return c - '0';
+
+	if ((c >= 'A') && (c <= 'F'))
+		return c - 'A' + 10;
+
+	if ((c >= 'a') && (c <= 'f'))
+		return c - 'a' + 10;
+
+	return 16; /* error */
+}
+
+int hexstring2data(char *arg, unsigned char *data, int maxdlen) {
+
+	int len = strlen(arg);
+	int i;
+	unsigned char tmp;
+
+	if (!len || len%2 || len > maxdlen*2)
+		return 1;
+
+	memset(data, 0, maxdlen);
+
+	for (i=0; i < len/2; i++) {
+
+		tmp = asc2nibble(*(arg+(2*i)));
+		if (tmp > 0x0F)
+			return 1;
+
+		data[i] = (tmp << 4);
+
+		tmp = asc2nibble(*(arg+(2*i)+1));
+		if (tmp > 0x0F)
+			return 1;
+
+		data[i] |= tmp;
+	}
+
+	return 0;
+}
+
+int parse_canframe(char *cs, struct canfd_frame *cf) {
+	/* documentation see lib.h */
+
+	int i, idx, dlen, len;
+	int maxdlen = CAN_MAX_DLEN;
+	int ret = CAN_MTU;
+	canid_t tmp;
+
+	len = strlen(cs);
+	//printf("'%s' len %d\n", cs, len);
+
+	memset(cf, 0, sizeof(*cf)); /* init CAN FD frame, e.g. LEN = 0 */
+
+	if (len < 4)
+		return 0;
+
+	if (cs[3] == CANID_DELIM) { /* 3 digits */
+
+		idx = 4;
+		for (i=0; i<3; i++){
+			if ((tmp = asc2nibble(cs[i])) > 0x0F)
+				return 0;
+			cf->can_id |= (tmp << (2-i)*4);
+		}
+
+	} else if (cs[8] == CANID_DELIM) { /* 8 digits */
+
+		idx = 9;
+		for (i=0; i<8; i++){
+			if ((tmp = asc2nibble(cs[i])) > 0x0F)
+				return 0;
+			cf->can_id |= (tmp << (7-i)*4);
+		}
+		if (!(cf->can_id & CAN_ERR_FLAG)) /* 8 digits but no errorframe?  */
+			cf->can_id |= CAN_EFF_FLAG;   /* then it is an extended frame */
+
+	} else
+		return 0;
+
+	if((cs[idx] == 'R') || (cs[idx] == 'r')){ /* RTR frame */
+		cf->can_id |= CAN_RTR_FLAG;
+
+		/* check for optional DLC value for CAN 2.0B frames */
+		if(cs[++idx] && (tmp = asc2nibble(cs[idx++])) <= CAN_MAX_DLEN) {
+			cf->len = tmp;
+
+			/* check for optional raw DLC value for CAN 2.0B frames */
+			if ((tmp == CAN_MAX_DLEN) && (cs[idx++] == CC_DLC_DELIM)) {
+				tmp = asc2nibble(cs[idx]);
+				if ((tmp > CAN_MAX_DLEN) && (tmp <= CAN_MAX_RAW_DLC)) {
+					struct can_frame *ccf = (struct can_frame *)cf;
+
+					ccf->len8_dlc = tmp;
+				}
+			}
+		}
+		return ret;
+	}
+
+	if (cs[idx] == CANID_DELIM) { /* CAN FD frame escape char '##' */
+
+		maxdlen = CANFD_MAX_DLEN;
+		ret = CANFD_MTU;
+
+		/* CAN FD frame <canid>##<flags><data>* */
+		if ((tmp = asc2nibble(cs[idx+1])) > 0x0F)
+			return 0;
+
+		cf->flags = tmp;
+		idx += 2;
+	}
+
+	for (i=0, dlen=0; i < maxdlen; i++){
+
+		if(cs[idx] == DATA_SEPERATOR) /* skip (optional) separator */
+			idx++;
+
+		if(idx >= len) /* end of string => end of data */
+			break;
+
+		if ((tmp = asc2nibble(cs[idx++])) > 0x0F)
+			return 0;
+		cf->data[i] = (tmp << 4);
+		if ((tmp = asc2nibble(cs[idx++])) > 0x0F)
+			return 0;
+		cf->data[i] |= tmp;
+		dlen++;
+	}
+	cf->len = dlen;
+
+	/* check for extra DLC when having a Classic CAN with 8 bytes payload */
+	if ((maxdlen == CAN_MAX_DLEN) && (dlen == CAN_MAX_DLEN) && (cs[idx++] == CC_DLC_DELIM)) {
+		unsigned char dlc = asc2nibble(cs[idx]);
+
+		if ((dlc > CAN_MAX_DLEN) && (dlc <= CAN_MAX_RAW_DLC)) {
+			struct can_frame *ccf = (struct can_frame *)cf;
+
+			ccf->len8_dlc = dlc;
+		}
+	}
+
+	return ret;
+}
+
+void fprint_canframe(FILE *stream , struct canfd_frame *cf, char *eol, int sep, int maxdlen) {
+	/* documentation see lib.h */
+
+	char buf[CL_CFSZ]; /* max length */
+
+	sprint_canframe(buf, cf, sep, maxdlen);
+	fprintf(stream, "%s", buf);
+	if (eol)
+		fprintf(stream, "%s", eol);
+}
+
+void sprint_canframe(char *buf , struct canfd_frame *cf, int sep, int maxdlen) {
+	/* documentation see lib.h */
+
+	int i,offset;
+	int len = (cf->len > maxdlen) ? maxdlen : cf->len;
+
+	if (cf->can_id & CAN_ERR_FLAG) {
+		put_eff_id(buf, cf->can_id & (CAN_ERR_MASK|CAN_ERR_FLAG));
+		buf[8] = '#';
+		offset = 9;
+	} else if (cf->can_id & CAN_EFF_FLAG) {
+		put_eff_id(buf, cf->can_id & CAN_EFF_MASK);
+		buf[8] = '#';
+		offset = 9;
+	} else {
+		put_sff_id(buf, cf->can_id & CAN_SFF_MASK);
+		buf[3] = '#';
+		offset = 4;
+	}
+
+	/* standard CAN frames may have RTR enabled. There are no ERR frames with RTR */
+	if (maxdlen == CAN_MAX_DLEN && cf->can_id & CAN_RTR_FLAG) {
+		buf[offset++] = 'R';
+		/* print a given CAN 2.0B DLC if it's not zero */
+		if (cf->len && cf->len <= CAN_MAX_DLEN) {
+			buf[offset++] = hex_asc_upper_lo(cf->len);
+
+			/* check for optional raw DLC value for CAN 2.0B frames */
+			if (cf->len == CAN_MAX_DLEN) {
+				struct can_frame *ccf = (struct can_frame *)cf;
+
+				if ((ccf->len8_dlc > CAN_MAX_DLEN) && (ccf->len8_dlc <= CAN_MAX_RAW_DLC)) {
+					buf[offset++] = CC_DLC_DELIM;
+					buf[offset++] = hex_asc_upper_lo(ccf->len8_dlc);
+				}
+			}
+		}
+
+		buf[offset] = 0;
+		return;
+	}
+
+	if (maxdlen == CANFD_MAX_DLEN) {
+		/* add CAN FD specific escape char and flags */
+		buf[offset++] = '#';
+		buf[offset++] = hex_asc_upper_lo(cf->flags);
+		if (sep && len)
+			buf[offset++] = '.';
+	}
+
+	for (i = 0; i < len; i++) {
+		put_hex_byte(buf + offset, cf->data[i]);
+		offset += 2;
+		if (sep && (i+1 < len))
+			buf[offset++] = '.';
+	}
+
+	/* check for extra DLC when having a Classic CAN with 8 bytes payload */
+	if ((maxdlen == CAN_MAX_DLEN) && (len == CAN_MAX_DLEN)) {
+		struct can_frame *ccf = (struct can_frame *)cf;
+		unsigned char dlc = ccf->len8_dlc;
+
+		if ((dlc > CAN_MAX_DLEN) && (dlc <= CAN_MAX_RAW_DLC)) {
+			buf[offset++] = CC_DLC_DELIM;
+			buf[offset++] = hex_asc_upper_lo(dlc);
+		}
+	}
+
+	buf[offset] = 0;
+}
+
+void fprint_long_canframe(FILE *stream , struct canfd_frame *cf, char *eol, int view, int maxdlen) {
+	/* documentation see lib.h */
+
+	char buf[CL_LONGCFSZ];
+
+	sprint_long_canframe(buf, cf, view, maxdlen);
+	fprintf(stream, "%s", buf);
+	if ((view & CANLIB_VIEW_ERROR) && (cf->can_id & CAN_ERR_FLAG)) {
+		snprintf_can_error_frame(buf, sizeof(buf), cf, "\n\t");
+		fprintf(stream, "\n\t%s", buf);
+	}
+	if (eol)
+		fprintf(stream, "%s", eol);
+}
+
+void sprint_long_canframe(char *buf , struct canfd_frame *cf, int view, int maxdlen) {
+	/* documentation see lib.h */
+
+	int i, j, dlen, offset;
+	int len = (cf->len > maxdlen)? maxdlen : cf->len;
+
+	/* initialize space for CAN-ID and length information */
+	memset(buf, ' ', 15);
+
+	if (cf->can_id & CAN_ERR_FLAG) {
+		put_eff_id(buf, cf->can_id & (CAN_ERR_MASK|CAN_ERR_FLAG));
+		offset = 10;
+	} else if (cf->can_id & CAN_EFF_FLAG) {
+		put_eff_id(buf, cf->can_id & CAN_EFF_MASK);
+		offset = 10;
+	} else {
+		if (view & CANLIB_VIEW_INDENT_SFF) {
+			put_sff_id(buf + 5, cf->can_id & CAN_SFF_MASK);
+			offset = 10;
+		} else {
+			put_sff_id(buf, cf->can_id & CAN_SFF_MASK);
+			offset = 5;
+		}
+	}
+
+	/* The len value is sanitized by maxdlen (see above) */
+	if (maxdlen == CAN_MAX_DLEN) {
+		if (view & CANLIB_VIEW_LEN8_DLC) {
+			struct can_frame *ccf = (struct can_frame *)cf;
+			unsigned char dlc = ccf->len8_dlc;
+
+			/* fall back to len if we don't have a valid DLC > 8 */
+			if (!((len == CAN_MAX_DLEN) && (dlc > CAN_MAX_DLEN) &&
+			      (dlc <= CAN_MAX_RAW_DLC)))
+				dlc = len;
+
+			buf[offset + 1] = '{';
+			buf[offset + 2] = hex_asc_upper[dlc];
+			buf[offset + 3] = '}';
+		} else {
+			buf[offset + 1] = '[';
+			buf[offset + 2] = len + '0';
+			buf[offset + 3] = ']';
+		}
+
+		/* standard CAN frames may have RTR enabled */
+		if (cf->can_id & CAN_RTR_FLAG) {
+			sprintf(buf+offset+5, " remote request");
+			return;
+		}
+	} else {
+		buf[offset] = '[';
+		buf[offset + 1] = (len/10) + '0';
+		buf[offset + 2] = (len%10) + '0';
+		buf[offset + 3] = ']';
+	}
+	offset += 5;
+
+	if (view & CANLIB_VIEW_BINARY) {
+		dlen = 9; /* _10101010 */
+		if (view & CANLIB_VIEW_SWAP) {
+			for (i = len - 1; i >= 0; i--) {
+				buf[offset++] = (i == len-1)?' ':SWAP_DELIMITER;
+				for (j = 7; j >= 0; j--)
+					buf[offset++] = (1<<j & cf->data[i])?'1':'0';
+			}
+		} else {
+			for (i = 0; i < len; i++) {
+				buf[offset++] = ' ';
+				for (j = 7; j >= 0; j--)
+					buf[offset++] = (1<<j & cf->data[i])?'1':'0';
+			}
+		}
+	} else {
+		dlen = 3; /* _AA */
+		if (view & CANLIB_VIEW_SWAP) {
+			for (i = len - 1; i >= 0; i--) {
+				if (i == len-1)
+					buf[offset++] = ' ';
+				else
+					buf[offset++] = SWAP_DELIMITER;
+
+				put_hex_byte(buf + offset, cf->data[i]);
+				offset += 2;
+			}
+		} else {
+			for (i = 0; i < len; i++) {
+				buf[offset++] = ' ';
+				put_hex_byte(buf + offset, cf->data[i]);
+				offset += 2;
+			}
+		}
+	}
+
+	buf[offset] = 0; /* terminate string */
+
+	/*
+	 * The ASCII & ERRORFRAME output is put at a fixed len behind the data.
+	 * For now we support ASCII output only for payload length up to 8 bytes.
+	 * Does it make sense to write 64 ASCII byte behind 64 ASCII HEX data on the console?
+	 */
+	if (len > CAN_MAX_DLEN)
+		return;
+
+	if (cf->can_id & CAN_ERR_FLAG)
+		sprintf(buf+offset, "%*s", dlen*(8-len)+13, "ERRORFRAME");
+	else if (view & CANLIB_VIEW_ASCII) {
+		j = dlen*(8-len)+4;
+		if (view & CANLIB_VIEW_SWAP) {
+			sprintf(buf+offset, "%*s", j, "`");
+			offset += j;
+			for (i = len - 1; i >= 0; i--)
+				if ((cf->data[i] > 0x1F) && (cf->data[i] < 0x7F))
+					buf[offset++] = cf->data[i];
+				else
+					buf[offset++] = '.';
+
+			sprintf(buf+offset, "`");
+		} else {
+			sprintf(buf+offset, "%*s", j, "'");
+			offset += j;
+			for (i = 0; i < len; i++)
+				if ((cf->data[i] > 0x1F) && (cf->data[i] < 0x7F))
+					buf[offset++] = cf->data[i];
+				else
+					buf[offset++] = '.';
+
+			sprintf(buf+offset, "'");
+		}
+	}
+}
+
+static const char *error_classes[] = {
+	"tx-timeout",
+	"lost-arbitration",
+	"controller-problem",
+	"protocol-violation",
+	"transceiver-status",
+	"no-acknowledgement-on-tx",
+	"bus-off",
+	"bus-error",
+	"restarted-after-bus-off",
+};
+
+static const char *controller_problems[] = {
+	"rx-overflow",
+	"tx-overflow",
+	"rx-error-warning",
+	"tx-error-warning",
+	"rx-error-passive",
+	"tx-error-passive",
+	"back-to-error-active",
+};
+
+static const char *protocol_violation_types[] = {
+	"single-bit-error",
+	"frame-format-error",
+	"bit-stuffing-error",
+	"tx-dominant-bit-error",
+	"tx-recessive-bit-error",
+	"bus-overload",
+	"active-error",
+	"error-on-tx",
+};
+
+static const char *protocol_violation_locations[] = {
+	"unspecified",
+	"unspecified",
+	"id.28-to-id.21",
+	"start-of-frame",
+	"bit-srtr",
+	"bit-ide",
+	"id.20-to-id.18",
+	"id.17-to-id.13",
+	"crc-sequence",
+	"reserved-bit-0",
+	"data-field",
+	"data-length-code",
+	"bit-rtr",
+	"reserved-bit-1",
+	"id.4-to-id.0",
+	"id.12-to-id.5",
+	"unspecified",
+	"active-error-flag",
+	"intermission",
+	"tolerate-dominant-bits",
+	"unspecified",
+	"unspecified",
+	"passive-error-flag",
+	"error-delimiter",
+	"crc-delimiter",
+	"acknowledge-slot",
+	"end-of-frame",
+	"acknowledge-delimiter",
+	"overload-flag",
+	"unspecified",
+	"unspecified",
+	"unspecified",
+};
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+#endif
+
+static int snprintf_error_data(char *buf, size_t len, uint8_t err,
+			       const char **arr, int arr_len)
+{
+	int i, n = 0, count = 0;
+
+	if (!err || len <= 0)
+		return 0;
+
+	for (i = 0; i < arr_len; i++) {
+		if (err & (1 << i)) {
+			int tmp_n = 0;
+			if (count){
+				/* Fix for potential buffer overflow https://lgtm.com/rules/1505913226124/ */
+				tmp_n = snprintf(buf + n, len - n, ",");
+				if (tmp_n < 0 || (size_t)tmp_n >= len - n){
+					return n;
+				}
+				n += tmp_n;
+			}
+			tmp_n = snprintf(buf + n, len - n, "%s", arr[i]);
+			if (tmp_n < 0 || (size_t)tmp_n >= len - n){
+				return n;
+			}
+			n += tmp_n;
+		}
+	}
+
+	return n;
+}
+
+static int snprintf_error_lostarb(char *buf, size_t len, const struct canfd_frame *cf)
+{
+	if (len <= 0)
+		return 0;
+	return snprintf(buf, len, "{at bit %d}", cf->data[0]);
+}
+
+static int snprintf_error_ctrl(char *buf, size_t len, const struct canfd_frame *cf)
+{
+	int n = 0;
+
+	if (len <= 0)
+		return 0;
+
+	n += snprintf(buf + n, len - n, "{");
+	n += snprintf_error_data(buf + n, len - n, cf->data[1],
+				controller_problems,
+				ARRAY_SIZE(controller_problems));
+	n += snprintf(buf + n, len - n, "}");
+
+	return n;
+}
+
+static int snprintf_error_prot(char *buf, size_t len, const struct canfd_frame *cf)
+{
+	int n = 0;
+
+	if (len <= 0)
+		return 0;
+
+	n += snprintf(buf + n, len - n, "{{");
+	n += snprintf_error_data(buf + n, len - n, cf->data[2],
+				protocol_violation_types,
+				ARRAY_SIZE(protocol_violation_types));
+	n += snprintf(buf + n, len - n, "}{");
+	if (cf->data[3] > 0 &&
+	    cf->data[3] < ARRAY_SIZE(protocol_violation_locations))
+		n += snprintf(buf + n, len - n, "%s",
+			      protocol_violation_locations[cf->data[3]]);
+	n += snprintf(buf + n, len - n, "}}");
+
+	return n;
+}
+
+void snprintf_can_error_frame(char *buf, size_t len, const struct canfd_frame *cf,
+                  const char* sep)
+{
+	canid_t class, mask;
+	int i, n = 0, classes = 0;
+	char *defsep = ",";
+
+	if (!(cf->can_id & CAN_ERR_FLAG))
+		return;
+
+	class = cf->can_id & CAN_EFF_MASK;
+	if (class > (1 << ARRAY_SIZE(error_classes))) {
+		fprintf(stderr, "Error class %#x is invalid\n", class);
+		return;
+	}
+
+	if (!sep)
+		sep = defsep;
+
+	for (i = 0; i < (int)ARRAY_SIZE(error_classes); i++) {
+		mask = 1 << i;
+		if (class & mask) {
+			int tmp_n = 0;
+			if (classes){
+				/* Fix for potential buffer overflow https://lgtm.com/rules/1505913226124/ */
+				tmp_n = snprintf(buf + n, len - n, "%s", sep);
+				if (tmp_n < 0 || (size_t)tmp_n >= len - n){
+					return;
+				}
+				n += tmp_n;
+			}
+			tmp_n = snprintf(buf + n, len - n, "%s", error_classes[i]);
+			if (tmp_n < 0 || (size_t)tmp_n >= len - n){
+				return;
+			}
+			n += tmp_n;
+			if (mask == CAN_ERR_LOSTARB)
+				n += snprintf_error_lostarb(buf + n, len - n,
+							   cf);
+			if (mask == CAN_ERR_CRTL)
+				n += snprintf_error_ctrl(buf + n, len - n, cf);
+			if (mask == CAN_ERR_PROT)
+				n += snprintf_error_prot(buf + n, len - n, cf);
+			classes++;
+		}
+	}
+
+	if (cf->data[6] || cf->data[7]) {
+		n += snprintf(buf + n, len - n, "%s", sep);
+		n += snprintf(buf + n, len - n, "error-counter-tx-rx{{%d}{%d}}",
+			      cf->data[6], cf->data[7]);
+	}
+}
diff --git a/canutils/lib.h b/canutils/lib.h
new file mode 100644
index 0000000000..a4d3ce5c83
--- /dev/null
+++ b/canutils/lib.h
@@ -0,0 +1,224 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * lib.h - library include for command line tools
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#ifndef CAN_UTILS_LIB_H
+#define CAN_UTILS_LIB_H
+
+#include <stdio.h>
+
+/* buffer sizes for CAN frame string representations */
+
+#define CL_ID (sizeof("12345678##1"))
+#define CL_DATA sizeof(".AA")
+#define CL_BINDATA sizeof(".10101010")
+
+ /* CAN FD ASCII hex short representation with DATA_SEPERATORs */
+#define CL_CFSZ (2*CL_ID + 64*CL_DATA)
+
+/* CAN FD ASCII hex long representation with binary output */
+#define CL_LONGCFSZ (2*CL_ID + sizeof("   [255]  ") + (64*CL_BINDATA))
+
+/* CAN DLC to real data length conversion helpers especially for CAN FD */
+
+/* get data length from raw data length code (DLC) */
+unsigned char can_fd_dlc2len(unsigned char dlc);
+
+/* map the sanitized data length to an appropriate data length code */
+unsigned char can_fd_len2dlc(unsigned char len);
+
+unsigned char asc2nibble(char c);
+/*
+ * Returns the decimal value of a given ASCII hex character.
+ *
+ * While 0..9, a..f, A..F are valid ASCII hex characters.
+ * On invalid characters the value 16 is returned for error handling.
+ */
+
+int hexstring2data(char *arg, unsigned char *data, int maxdlen);
+/*
+ * Converts a given ASCII hex string to a (binary) byte string.
+ *
+ * A valid ASCII hex string consists of an even number of up to 16 chars.
+ * Leading zeros '00' in the ASCII hex string are interpreted.
+ *
+ * Examples:
+ *
+ * "1234"   => data[0] = 0x12, data[1] = 0x34
+ * "001234" => data[0] = 0x00, data[1] = 0x12, data[2] = 0x34
+ *
+ * Return values:
+ * 0 = success
+ * 1 = error (in length or the given characters are no ASCII hex characters)
+ *
+ * Remark: The not written data[] elements are initialized with zero.
+ *
+ */
+
+int parse_canframe(char *cs, struct canfd_frame *cf);
+/*
+ * Transfers a valid ASCII string describing a CAN frame into struct canfd_frame.
+ *
+ * CAN 2.0 frames (aka Classical CAN)
+ * - string layout <can_id>#{R{len}|data}{_len8_dlc}
+ * - {data} has 0 to 8 hex-values that can (optionally) be separated by '.'
+ * - {len} can take values from 0 to 8 and can be omitted if zero
+ * - {_len8_dlc} can take hex values from '_9' to '_F' when len is CAN_MAX_DLEN
+ * - return value on successful parsing: CAN_MTU
+ *
+ * CAN FD frames
+ * - string layout <can_id>##<flags>{data}
+ * - <flags> a single ASCII Hex value (0 .. F) which defines canfd_frame.flags
+ * - {data} has 0 to 64 hex-values that can (optionally) be separated by '.'
+ * - return value on successful parsing: CANFD_MTU
+ *
+ * Return value on detected problems: 0
+ *
+ * <can_id> can have 3 (standard frame format) or 8 (extended frame format)
+ * hexadecimal chars
+ *
+ *
+ * Examples:
+ *
+ * 123# -> standard CAN-Id = 0x123, len = 0
+ * 12345678# -> extended CAN-Id = 0x12345678, len = 0
+ * 123#R -> standard CAN-Id = 0x123, len = 0, RTR-frame
+ * 123#R0 -> standard CAN-Id = 0x123, len = 0, RTR-frame
+ * 123#R7 -> standard CAN-Id = 0x123, len = 7, RTR-frame
+ * 123#R8_9 -> standard CAN-Id = 0x123, len = 8, dlc = 9, RTR-frame
+ * 7A1#r -> standard CAN-Id = 0x7A1, len = 0, RTR-frame
+ *
+ * 123#00 -> standard CAN-Id = 0x123, len = 1, data[0] = 0x00
+ * 123#1122334455667788 -> standard CAN-Id = 0x123, len = 8
+ * 123#1122334455667788_E -> standard CAN-Id = 0x123, len = 8, dlc = 14
+ * 123#11.22.33.44.55.66.77.88 -> standard CAN-Id = 0x123, len = 8
+ * 123#11.2233.44556677.88 -> standard CAN-Id = 0x123, len = 8
+ * 32345678#112233 -> error frame with CAN_ERR_FLAG (0x2000000) set
+ *
+ * 123##0112233 -> CAN FD frame standard CAN-Id = 0x123, flags = 0, len = 3
+ * 123##1112233 -> CAN FD frame, flags = CANFD_BRS, len = 3
+ * 123##2112233 -> CAN FD frame, flags = CANFD_ESI, len = 3
+ * 123##3 -> CAN FD frame, flags = (CANFD_ESI | CANFD_BRS), len = 0
+ *     ^^
+ *     CAN FD extension to handle the canfd_frame.flags content
+ *
+ * Simple facts on this compact ASCII CAN frame representation:
+ *
+ * - 3 digits: standard frame format
+ * - 8 digits: extendend frame format OR error frame
+ * - 8 digits with CAN_ERR_FLAG (0x2000000) set: error frame
+ * - an error frame is never a RTR frame
+ * - CAN FD frames do not have a RTR bit
+ */
+
+void fprint_canframe(FILE *stream , struct canfd_frame *cf, char *eol, int sep, int maxdlen);
+void sprint_canframe(char *buf , struct canfd_frame *cf, int sep, int maxdlen);
+/*
+ * Creates a CAN frame hexadecimal output in compact format.
+ * The CAN data[] is separated by '.' when sep != 0.
+ *
+ * The type of the CAN frame (CAN 2.0 / CAN FD) is specified by maxdlen:
+ * maxdlen = 8 -> CAN2.0 frame (aka Classical CAN)
+ * maxdlen = 64 -> CAN FD frame
+ *
+ * 12345678#112233 -> extended CAN-Id = 0x12345678, len = 3, data, sep = 0
+ * 123#1122334455667788_E -> standard CAN-Id = 0x123, len = 8, dlc = 14, data, sep = 0
+ * 12345678#R -> extended CAN-Id = 0x12345678, RTR, len = 0
+ * 12345678#R5 -> extended CAN-Id = 0x12345678, RTR, len = 5
+ * 123#11.22.33.44.55.66.77.88 -> standard CAN-Id = 0x123, dlc = 8, sep = 1
+ * 32345678#112233 -> error frame with CAN_ERR_FLAG (0x2000000) set
+ * 123##0112233 -> CAN FD frame standard CAN-Id = 0x123, flags = 0, len = 3
+ * 123##2112233 -> CAN FD frame, flags = CANFD_ESI, len = 3
+ *
+ * Examples:
+ *
+ * fprint_canframe(stdout, &frame, "\n", 0); // with eol to STDOUT
+ * fprint_canframe(stderr, &frame, NULL, 0); // no eol to STDERR
+ *
+ */
+
+#define CANLIB_VIEW_ASCII	0x1
+#define CANLIB_VIEW_BINARY	0x2
+#define CANLIB_VIEW_SWAP	0x4
+#define CANLIB_VIEW_ERROR	0x8
+#define CANLIB_VIEW_INDENT_SFF	0x10
+#define CANLIB_VIEW_LEN8_DLC	0x20
+
+#define SWAP_DELIMITER '`'
+
+void fprint_long_canframe(FILE *stream , struct canfd_frame *cf, char *eol, int view, int maxdlen);
+void sprint_long_canframe(char *buf , struct canfd_frame *cf, int view, int maxdlen);
+/*
+ * Creates a CAN frame hexadecimal output in user readable format.
+ *
+ * The type of the CAN frame (CAN 2.0 / CAN FD) is specified by maxdlen:
+ * maxdlen = 8 -> CAN2.0 frame (aka Classical CAN)
+ * maxdlen = 64 -> CAN FD frame
+ *
+ * 12345678   [3]  11 22 33 -> extended CAN-Id = 0x12345678, len = 3, data
+ * 12345678   [0]  remote request -> extended CAN-Id = 0x12345678, RTR
+ * 14B0DC51   [8]  4A 94 E8 2A EC 58 55 62   'J..*.XUb' -> (with ASCII output)
+ * 321   {B}  11 22 33 44 55 66 77 88 -> Classical CAN with raw '{DLC}' value B
+ * 20001111   [7]  C6 23 7B 32 69 98 3C      ERRORFRAME -> (CAN_ERR_FLAG set)
+ * 12345678  [03]  11 22 33 -> CAN FD with extended CAN-Id = 0x12345678, len = 3
+ *
+ * 123   [3]  11 22 33         -> CANLIB_VIEW_INDENT_SFF == 0
+ *      123   [3]  11 22 33    -> CANLIB_VIEW_INDENT_SFF == set
+ *
+ * Examples:
+ *
+ * // CAN FD frame with eol to STDOUT
+ * fprint_long_canframe(stdout, &frame, "\n", 0, CANFD_MAX_DLEN);
+ *
+ * // Classical CAN 2.0 frame without eol to STDERR
+ * fprint_long_canframe(stderr, &frame, NULL, 0, CAN_MAX_DLEN);
+ *
+ */
+
+void snprintf_can_error_frame(char *buf, size_t len, const struct canfd_frame *cf,
+                  const char *sep);
+/*
+ * Creates a CAN error frame output in user readable format.
+ */
+
+#endif
diff --git a/canutils/libj1939.c b/canutils/libj1939.c
new file mode 100644
index 0000000000..506b525282
--- /dev/null
+++ b/canutils/libj1939.c
@@ -0,0 +1,197 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <err.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include <net/if.h>
+
+#include "libj1939.h"
+
+/* static data */
+static struct if_nameindex *saved;
+
+__attribute__((destructor))
+static void libj1939_cleanup(void)
+{
+	if (saved)
+		if_freenameindex(saved);
+	saved = 0;
+}
+
+static inline void fetch_names(void)
+{
+	if (!saved) {
+		saved = if_nameindex();
+		if (!saved)
+			err(1, "if_nameindex()");
+	}
+}
+
+/* retrieve name */
+static const char *libj1939_ifnam(int ifindex)
+{
+	const struct if_nameindex *lp, *cached = saved;
+
+	fetch_names();
+
+	for (lp = saved; lp->if_index; ++lp) {
+		if (lp->if_index == (unsigned int)ifindex)
+			return lp->if_name;
+	}
+	if (cached) {
+		/*
+		 * the list was not recent
+		 * iterate twice, but force a refresh now
+		 * recursion stops since the 'saved' pointer is cleaned
+		 */
+		libj1939_cleanup();
+		return libj1939_ifnam(ifindex);
+	}
+	return NULL;
+}
+
+/* retrieve index */
+static int libj1939_ifindex(const char *str)
+{
+	const struct if_nameindex *lp, *cached = saved;
+	char *endp;
+	int ret;
+
+	ret = strtol(str, &endp, 0);
+	if (!*endp)
+		/* did some good parse */
+		return ret;
+
+	fetch_names();
+	for (lp = saved; lp->if_index; ++lp) {
+		if (!strcmp(lp->if_name, str))
+			return lp->if_index;
+	}
+	if (cached) {
+		libj1939_cleanup();
+		return libj1939_ifindex(str);
+	}
+	return 0;
+}
+
+void libj1939_parse_canaddr(char *spec, struct sockaddr_can *paddr)
+{
+	char *str;
+
+	str = strsep(&spec, ":");
+	if (strlen(str))
+		paddr->can_ifindex = if_nametoindex(str);
+
+	str = strsep(&spec, ",");
+	if (str && strlen(str))
+		paddr->can_addr.j1939.addr = strtoul(str, NULL, 0);
+
+	str = strsep(&spec, ",");
+	if (str && strlen(str))
+		paddr->can_addr.j1939.pgn = strtoul(str, NULL, 0);
+
+	str = strsep(&spec, ",");
+	if (str && strlen(str))
+		paddr->can_addr.j1939.name = strtoull(str, NULL, 0);
+}
+
+int libj1939_str2addr(const char *str, char **endp, struct sockaddr_can *can)
+{
+	char *p;
+	const char *pstr;
+	uint64_t tmp64;
+	unsigned long tmp;
+
+	if (!endp)
+		endp = &p;
+	memset(can, 0, sizeof(*can));
+	can->can_family = AF_CAN;
+	can->can_addr.j1939.name = J1939_NO_NAME;
+	can->can_addr.j1939.addr = J1939_NO_ADDR;
+	can->can_addr.j1939.pgn = J1939_NO_PGN;
+
+	pstr = strchr(str, ':');
+	if (pstr) {
+		char tmp[IFNAMSIZ];
+		if ((pstr - str) >= IFNAMSIZ)
+			return -1;
+		strncpy(tmp, str, pstr - str);
+		tmp[pstr - str] = 0;
+		can->can_ifindex = libj1939_ifindex(tmp);
+	} else {
+		can->can_ifindex = libj1939_ifindex(str);
+		if (can->can_ifindex) {
+			if (endp)
+				*endp = (char *)&str[strlen(str)];
+			return 0;
+		}
+	}
+	if (pstr)
+		++pstr;
+	else
+		pstr = str;
+
+
+	tmp64 = strtoull(pstr, endp, 16);
+	if (*endp <= pstr)
+		return 0;
+	if ((*endp - pstr) == 2)
+		can->can_addr.j1939.addr = tmp64;
+	else
+		can->can_addr.j1939.name = tmp64;
+	if (!**endp)
+		return 0;
+
+	str = *endp + 1;
+	tmp = strtoul(str, endp, 16);
+	if (*endp > str)
+		can->can_addr.j1939.pgn = tmp;
+	return 0;
+}
+
+const char *libj1939_addr2str(const struct sockaddr_can *can)
+{
+	char *str;
+	static char buf[128];
+
+	str = buf;
+	if (can->can_ifindex) {
+		const char *ifname;
+		ifname = libj1939_ifnam(can->can_ifindex);
+		if (!ifname)
+			str += sprintf(str, "#%i:", can->can_ifindex);
+		else
+			str += sprintf(str, "%s:", ifname);
+	}
+	if (can->can_addr.j1939.name) {
+		str += sprintf(str, "%016llx", (unsigned long long)can->can_addr.j1939.name);
+		if (can->can_addr.j1939.pgn == J1939_PGN_ADDRESS_CLAIMED)
+			str += sprintf(str, ".%02x", can->can_addr.j1939.addr);
+	} else if (can->can_addr.j1939.addr <= 0xfe)
+		str += sprintf(str, "%02x", can->can_addr.j1939.addr);
+	else
+		str += sprintf(str, "-");
+	if (can->can_addr.j1939.pgn <= J1939_PGN_MAX)
+		str += sprintf(str, ",%05x", can->can_addr.j1939.pgn);
+
+	return buf;
+}
+
diff --git a/canutils/libj1939.h b/canutils/libj1939.h
new file mode 100644
index 0000000000..b6832cfe92
--- /dev/null
+++ b/canutils/libj1939.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/* needed on some 64 bit platforms to get consistent 64-bit types */
+#define __SANE_USERSPACE_TYPES__
+
+#include <sys/socket.h>
+#include <linux/can.h>
+#include <linux/can/j1939.h>
+
+#ifndef J1939_LIB_H
+#define J1939_LIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void libj1939_parse_canaddr(char *spec, struct sockaddr_can *paddr);
+extern int libj1939_str2addr(const char *str, char **endp, struct sockaddr_can *can);
+extern const char *libj1939_addr2str(const struct sockaddr_can *can);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/canutils/log2asc.c b/canutils/log2asc.c
new file mode 100644
index 0000000000..a1cf364d63
--- /dev/null
+++ b/canutils/log2asc.c
@@ -0,0 +1,327 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * log2asc.c - convert compact CAN frame logfile to ASC logfile
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <libgen.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <linux/can.h>
+#include <net/if.h>
+#include <sys/time.h>
+
+#include "lib.h"
+
+#define BUFSZ 400 /* for one line in the logfile */
+
+extern int optind, opterr, optopt;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - convert compact CAN frame logfile to ASC logfile.\n", prg);
+	fprintf(stderr, "Usage: %s <options> [can-interfaces]\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -I <infile>   (default stdin)\n");
+	fprintf(stderr, "         -O <outfile>  (default stdout)\n");
+	fprintf(stderr, "         -4  (reduce decimal place to 4 digits)\n");
+	fprintf(stderr, "         -n  (set newline to cr/lf - default lf)\n");
+	fprintf(stderr, "         -f  (use CANFD format also for Classic CAN)\n");
+	fprintf(stderr, "         -r  (suppress dlc for RTR frames - pre v8.5 tools)\n");
+}
+
+void can_asc(struct canfd_frame *cfd, int devno, int nortrdlc, char *extra_info, FILE *outfile)
+{
+	int i;
+	char id[10];
+	char *dir = "Rx";
+	int dlc;
+	struct can_frame *cf = (struct can_frame *)cfd; /* for len8_dlc */
+
+	fprintf(outfile, "%-2d ", devno); /* channel number left aligned */
+
+	if (cf->can_id & CAN_ERR_FLAG)
+		fprintf(outfile, "ErrorFrame");
+	else {
+		sprintf(id, "%X%c", cf->can_id & CAN_EFF_MASK,
+			(cf->can_id & CAN_EFF_FLAG)?'x':' ');
+
+		/* check for extra info */
+		if (strlen(extra_info) > 0) {
+			/* only the first char is defined so far */
+			if (extra_info[0] == 'T')
+				dir = "Tx";
+		}
+
+		fprintf(outfile, "%-15s %s   ", id, dir);
+
+		if (cf->len == CAN_MAX_DLC &&
+		    cf->len8_dlc > CAN_MAX_DLC &&
+		    cf->len8_dlc <= CAN_MAX_RAW_DLC)
+			dlc = cf->len8_dlc;
+		else
+			dlc = cf->len;
+
+		if (cf->can_id & CAN_RTR_FLAG) {
+			if (nortrdlc)
+				fprintf(outfile, "r"); /* RTR frame */
+			else
+				fprintf(outfile, "r %X", dlc); /* RTR frame */
+		} else {
+			fprintf(outfile, "d %X", dlc); /* data frame */
+
+			for (i = 0; i < cf->len; i++) {
+				fprintf(outfile, " %02X", cf->data[i]);
+			}
+		}
+	}
+}
+
+void canfd_asc(struct canfd_frame *cf, int devno, int mtu, char *extra_info, FILE *outfile)
+{
+	int i;
+	char id[10];
+	char *dir = "Rx";
+	unsigned int flags = 0;
+	unsigned int dlen = cf->len;
+	unsigned int dlc = can_fd_len2dlc(dlen);
+
+	/* relevant flags in Flags field */
+#define ASC_F_RTR 0x00000010
+#define ASC_F_FDF 0x00001000
+#define ASC_F_BRS 0x00002000
+#define ASC_F_ESI 0x00004000
+
+	/* check for extra info */
+	if (strlen(extra_info) > 0) {
+		/* only the first char is defined so far */
+		if (extra_info[0] == 'T')
+			dir = "Tx";
+	}
+
+	fprintf(outfile, "CANFD %3d %s ", devno, dir); /* 3 column channel number right aligned */
+
+	sprintf(id, "%X%c", cf->can_id & CAN_EFF_MASK,
+		(cf->can_id & CAN_EFF_FLAG)?'x':' ');
+	fprintf(outfile, "%11s                                  ", id);
+	fprintf(outfile, "%c ", (cf->flags & CANFD_BRS)?'1':'0');
+	fprintf(outfile, "%c ", (cf->flags & CANFD_ESI)?'1':'0');
+
+	/* check for extra DLC when having a Classic CAN with 8 bytes payload */
+	if ((mtu == CAN_MTU) && (dlen == CAN_MAX_DLEN)) {
+		struct can_frame *ccf = (struct can_frame *)cf;
+
+		if ((ccf->len8_dlc > CAN_MAX_DLEN) && (ccf->len8_dlc <= CAN_MAX_RAW_DLC))
+			dlc = ccf->len8_dlc;
+	}
+
+	fprintf(outfile, "%x ", dlc);
+
+	if (mtu == CAN_MTU) {
+		if (cf->can_id & CAN_RTR_FLAG) {
+			/* no data length but dlc for RTR frames */
+			dlen = 0;
+			flags = ASC_F_RTR;
+		}
+	} else {
+		flags = ASC_F_FDF;
+		if (cf->flags & CANFD_BRS)
+			flags |= ASC_F_BRS;
+		if (cf->flags & CANFD_ESI)
+			flags |= ASC_F_ESI;
+	}
+
+	fprintf(outfile, "%2d", dlen);
+
+	for (i = 0; i < (int)dlen; i++) {
+		fprintf(outfile, " %02X", cf->data[i]);
+	}
+
+	fprintf(outfile, " %8d %4d %8X 0 0 0 0 0", 130000, 130, flags);
+}
+
+int main(int argc, char **argv)
+{
+	static char buf[BUFSZ], device[BUFSZ], ascframe[BUFSZ], extra_info[BUFSZ];
+
+	struct canfd_frame cf;
+	static struct timeval tv, start_tv;
+	FILE *infile = stdin;
+	FILE *outfile = stdout;
+	static int maxdev, devno, i, crlf, fdfmt, nortrdlc, d4, opt, mtu;
+
+	while ((opt = getopt(argc, argv, "I:O:4nfr?")) != -1) {
+		switch (opt) {
+		case 'I':
+			infile = fopen(optarg, "r");
+			if (!infile) {
+				perror("infile");
+				return 1;
+			}
+			break;
+
+		case 'O':
+			outfile = fopen(optarg, "w");
+			if (!outfile) {
+				perror("outfile");
+				return 1;
+			}
+			break;
+
+		case 'n':
+			crlf = 1;
+			break;
+
+		case 'f':
+			fdfmt = 1;
+			break;
+
+		case 'r':
+			nortrdlc = 1;
+			break;
+
+		case '4':
+			d4 = 1;
+			break;
+
+		case '?':
+			print_usage(basename(argv[0]));
+			return 0;
+			break;
+
+		default:
+			fprintf(stderr, "Unknown option %c\n", opt);
+			print_usage(basename(argv[0]));
+			return 1;
+			break;
+		}
+	}
+
+	maxdev = argc - optind; /* find real number of CAN devices */
+
+	if (!maxdev) {
+		fprintf(stderr, "no CAN interfaces defined!\n");
+		print_usage(basename(argv[0]));
+		return 1;
+	}
+	
+	//printf("Found %d CAN devices!\n", maxdev);
+
+	while (fgets(buf, BUFSZ-1, infile)) {
+
+		if (strlen(buf) >= BUFSZ-2) {
+			fprintf(stderr, "line too long for input buffer\n");
+			return 1;
+		}
+
+		/* check for a comment line */
+		if (buf[0] != '(')
+			continue;
+
+		if (sscanf(buf, "(%lu.%lu) %s %s %s", &tv.tv_sec, &tv.tv_usec,
+			   device, ascframe, extra_info) != 5) {
+
+			/* do not evaluate the extra info */
+			extra_info[0] = 0;
+
+			if (sscanf(buf, "(%lu.%lu) %s %s", &tv.tv_sec, &tv.tv_usec,
+				   device, ascframe) != 4) {
+				fprintf(stderr, "incorrect line format in logfile\n");
+				return 1;
+			}
+		}
+
+		if (!start_tv.tv_sec) { /* print banner */
+			start_tv = tv;
+			fprintf(outfile, "date %s", ctime(&start_tv.tv_sec));
+			fprintf(outfile, "base hex  timestamps absolute%s",
+				(crlf)?"\r\n":"\n");
+			fprintf(outfile, "no internal events logged%s",
+				(crlf)?"\r\n":"\n");
+		}
+
+		for (i=0, devno=0; i<maxdev; i++) {
+			if (!strcmp(device, argv[optind+i])) {
+				devno = i+1; /* start with channel '1' */
+				break;
+			}
+		}
+
+		if (devno) { /* only convert for selected CAN devices */
+			mtu = parse_canframe(ascframe, &cf);
+			if ((mtu != CAN_MTU) && (mtu != CANFD_MTU))
+				return 1;
+
+			/* we don't support error message frames in CAN FD */
+			if ((mtu == CANFD_MTU) && (cf.can_id & CAN_ERR_FLAG))
+				continue;
+
+			tv.tv_sec  = tv.tv_sec - start_tv.tv_sec;
+			tv.tv_usec = tv.tv_usec - start_tv.tv_usec;
+			if (tv.tv_usec < 0)
+				tv.tv_sec--, tv.tv_usec += 1000000;
+			if (tv.tv_sec < 0)
+				tv.tv_sec = tv.tv_usec = 0;
+
+			if (d4)
+				fprintf(outfile, "%4lu.%04lu ", tv.tv_sec, tv.tv_usec/100);
+			else
+				fprintf(outfile, "%4lu.%06lu ", tv.tv_sec, tv.tv_usec);
+
+			if ((mtu == CAN_MTU) && (fdfmt == 0))
+				can_asc(&cf, devno, nortrdlc, extra_info, outfile);
+			else
+				canfd_asc(&cf, devno, mtu, extra_info, outfile);
+
+			if (crlf)
+				fprintf(outfile, "\r");
+			fprintf(outfile, "\n");
+		}
+	}
+	fflush(outfile);
+	fclose(outfile);
+	fclose(infile);
+
+	return 0;
+}
diff --git a/canutils/log2long.c b/canutils/log2long.c
new file mode 100644
index 0000000000..25814e2853
--- /dev/null
+++ b/canutils/log2long.c
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * log2long.c - convert compact CAN frame representation into user readable
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <stdio.h>
+
+#include <linux/can.h>
+#include <net/if.h>
+
+#include "lib.h"
+
+#define COMMENTSZ 200
+#define BUFSZ (sizeof("(1345212884.318850)") + IFNAMSIZ + 4 + CL_CFSZ + COMMENTSZ) /* for one line in the logfile */
+
+int main(void)
+{
+	char buf[BUFSZ], timestamp[BUFSZ], device[BUFSZ], ascframe[BUFSZ];
+	struct canfd_frame cf;
+	int mtu, maxdlen;
+
+	while (fgets(buf, BUFSZ-1, stdin)) {
+		if (sscanf(buf, "%s %s %s", timestamp, device, ascframe) != 3)
+			return 1;
+
+		mtu = parse_canframe(ascframe, &cf);
+		if (mtu == CAN_MTU)
+			maxdlen = CAN_MAX_DLEN;
+		else if (mtu == CANFD_MTU)
+			maxdlen = CANFD_MAX_DLEN;
+		else {
+			fprintf(stderr, "read: incomplete CAN frame\n");
+			return 1;
+		}
+
+		sprint_long_canframe(ascframe, &cf,
+				     (CANLIB_VIEW_INDENT_SFF | CANLIB_VIEW_ASCII),
+				     maxdlen); /* with ASCII output */
+
+		printf("%s  %s  %s\n", timestamp, device, ascframe);
+	}
+
+	return 0;
+}
diff --git a/canutils/mcp251xfd/99-devcoredump.rules b/canutils/mcp251xfd/99-devcoredump.rules
new file mode 100644
index 0000000000..01bb6ce4a3
--- /dev/null
+++ b/canutils/mcp251xfd/99-devcoredump.rules
@@ -0,0 +1 @@
+ACTION=="add", SUBSYSTEM=="devcoredump", RUN+="/usr/sbin/devcoredump"
diff --git a/canutils/mcp251xfd/devcoredump b/canutils/mcp251xfd/devcoredump
new file mode 100644
index 0000000000..edf829e820
--- /dev/null
+++ b/canutils/mcp251xfd/devcoredump
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+set -e
+
+timestamp=$(date +%+4Y%m%d-%H%M%S)
+filename=/var/log/devcoredump-${timestamp}.dump
+
+cat /sys/${DEVPATH}/data > ${filename}
+echo 1 > /sys/${DEVPATH}/data
+
+echo "devcoredump ${DEVPATH}" | logger
diff --git a/canutils/mcp251xfd/mcp251xfd-dev-coredump.c b/canutils/mcp251xfd/mcp251xfd-dev-coredump.c
new file mode 100644
index 0000000000..5874d24095
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd-dev-coredump.c
@@ -0,0 +1,257 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Microchip MCP251xFD Family CAN controller debug tool
+//
+// Copyright (c) 2020, 2021 Pengutronix,
+//               Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include <endian.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <linux/kernel.h>
+
+#include "mcp251xfd.h"
+#include "mcp251xfd-dump-userspace.h"
+
+#define pr_err(fmt, args...)    fprintf(stderr, fmt, ##args)
+#define pr_no(fmt, args...)     while (0) { fprintf(stdout, fmt, ##args); }
+
+#ifdef DEBUG
+#define pr_debug(fmt, args...) pr_err(fmt, ##args)
+#else
+#define pr_debug(fmt, args...) pr_no(fmt, ##args)
+#endif
+
+
+struct mcp251xfd_dump_iter {
+	const void *start;
+	const struct mcp251xfd_dump_object_header *hdr;
+	const void *object_start;
+	const void *object_end;
+};
+
+static __attribute__((__unused__)) const char *
+get_object_type_str(enum mcp251xfd_dump_object_type object_type)
+{
+	switch (object_type) {
+	case MCP251XFD_DUMP_OBJECT_TYPE_REG:
+		return "reg";
+	case MCP251XFD_DUMP_OBJECT_TYPE_TEF:
+		return "tef";
+	case MCP251XFD_DUMP_OBJECT_TYPE_RX:
+		return "rx";
+	case MCP251XFD_DUMP_OBJECT_TYPE_TX:
+		return "tx";
+	case MCP251XFD_DUMP_OBJECT_TYPE_END:
+		return "end";
+	default:
+		return "<unknown>";
+	}
+}
+
+static __attribute__((__unused__)) const char *
+get_ring_key_str(enum mcp251xfd_dump_object_ring_key key)
+{
+	switch (key) {
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_HEAD:
+		return "head";
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_TAIL:
+		return "tail";
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_BASE:
+		return "base";
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_NR:
+		return "nr";
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_FIFO_NR:
+		return "fifo-nr";
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_NUM:
+		return "obj-num";
+	case MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_SIZE:
+		return "obj-size";
+	default:
+		return "<unknown>";
+	}
+}
+
+static int
+do_dev_coredump_read_reg(const struct mcp251xfd_priv *priv,
+			 const struct mcp251xfd_dump_iter *iter,
+			 struct mcp251xfd_mem *mem)
+{
+	const struct mcp251xfd_dump_object_reg *object;
+
+	for (object = iter->object_start;
+	     (void *)(object + 1) <= iter->object_end;
+	     object++) {
+		uint32_t reg, val;
+
+		reg = le32toh(object->reg);
+		val = le32toh(object->val);
+
+		pr_debug("%s: object=0x%04zx reg=0x%04x - val=0x%08x\n",
+			 __func__,
+			 (void *)object - iter->start,
+			 reg, val);
+
+		if (reg > ARRAY_SIZE(mem->buf))
+			return -EINVAL;
+
+		*(uint32_t *)(mem->buf + reg) = val;
+	}
+
+	return 0;
+}
+
+static int
+do_dev_coredump_read_ring(const struct mcp251xfd_priv *priv,
+			  const struct mcp251xfd_dump_iter *iter,
+			  struct mcp251xfd_ring *ring)
+{
+	const struct mcp251xfd_dump_object_reg *object;
+
+	for (object = iter->object_start;
+	     (void *)(object + 1) <= iter->object_end;
+	     object++) {
+		enum mcp251xfd_dump_object_ring_key key;
+		uint32_t val;
+
+		key = le32toh(object->reg);
+		val = le32toh(object->val);
+
+		pr_debug("%s: reg=0x%04zx key=0x%02x: %8s - val=0x%08x\n",
+			 __func__,
+			 (void *)object - iter->start,
+			 key, get_ring_key_str(key), val);
+
+		switch (key) {
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_HEAD:
+			ring->head = val;
+			break;
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_TAIL:
+			ring->tail = val;
+			break;
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_BASE:
+			ring->base = val;
+			break;
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_NR:
+			ring->nr = val;
+			break;
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_FIFO_NR:
+			ring->fifo_nr = val;
+			break;
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_NUM:
+			ring->obj_num = val;
+			break;
+		case MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_SIZE:
+			ring->obj_size = val;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int
+do_dev_coredump_read(struct mcp251xfd_priv *priv,
+		     struct mcp251xfd_mem *mem,
+		     const void *dump, size_t dump_len)
+{
+	struct mcp251xfd_dump_iter iter[] = {
+		{
+			.start = dump,
+			.hdr = dump,
+		},
+	};
+
+	while ((void *)(iter->hdr + 1) <= iter->start + dump_len &&
+	       le32toh(iter->hdr->magic) == MCP251XFD_DUMP_MAGIC) {
+		const struct mcp251xfd_dump_object_header *hdr = iter->hdr;
+		enum mcp251xfd_dump_object_type object_type;
+		size_t object_offset, object_len;
+		int err;
+
+		object_type = le32toh(hdr->type);
+		object_offset = le32toh(hdr->offset);
+		object_len = le32toh(hdr->len);
+
+		if (object_offset + object_len > dump_len)
+			return -EFAULT;
+
+		iter->object_start = iter->start + object_offset;
+		iter->object_end = iter->object_start + object_len;
+
+		pr_debug("%s: hdr=0x%04zx type=0x%08x: %8s - offset=0x%04zx len=0x%04zx end=0x%04zx\n",
+			 __func__,
+			 (void *)iter->hdr - iter->start,
+			 object_type, get_object_type_str(object_type),
+			 object_offset, object_len, object_offset + object_len);
+
+		switch (object_type) {
+		case MCP251XFD_DUMP_OBJECT_TYPE_REG:
+			err = do_dev_coredump_read_reg(priv, iter, mem);
+			break;
+		case MCP251XFD_DUMP_OBJECT_TYPE_TEF:
+			err = do_dev_coredump_read_ring(priv, iter, priv->tef);
+			break;
+		case MCP251XFD_DUMP_OBJECT_TYPE_RX:
+			err = do_dev_coredump_read_ring(priv, iter, priv->rx);
+			break;
+		case MCP251XFD_DUMP_OBJECT_TYPE_TX:
+			err = do_dev_coredump_read_ring(priv, iter, priv->tx);
+			break;
+		case MCP251XFD_DUMP_OBJECT_TYPE_END:
+			return 0;
+		default:
+			return -EINVAL;
+		}
+
+		if (err)
+			return err;
+
+		iter->hdr++;
+	}
+
+	return -EINVAL;
+}
+
+int mcp251xfd_dev_coredump_read(struct mcp251xfd_priv *priv,
+				struct mcp251xfd_mem *mem,
+				const char *dump_path)
+{
+	struct stat statbuf;
+	size_t dump_len;
+	void *dump;
+	int fd, err;
+
+	fd = open(dump_path, O_RDONLY);
+	if (fd < 0)
+		return -errno;
+
+	err = fstat(fd, &statbuf);
+	if (err < 0) {
+		err = -errno;
+		goto out_close;
+	}
+	dump_len = statbuf.st_size;
+
+	dump = mmap(NULL, dump_len, PROT_READ, MAP_SHARED, fd, 0x0);
+	if (dump == MAP_FAILED) {
+		err = -errno;
+		goto out_close;
+	}
+
+	err = do_dev_coredump_read(priv, mem, dump, dump_len);
+
+	munmap(dump, dump_len);
+ out_close:
+	close(fd);
+	return err;
+}
diff --git a/canutils/mcp251xfd/mcp251xfd-dump-userspace.h b/canutils/mcp251xfd/mcp251xfd-dump-userspace.h
new file mode 100644
index 0000000000..890821ee81
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd-dump-userspace.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Microchip MCP251xFD Family CAN controller debug tool
+ *
+ * Copyright (c) 2019, 2020 Pengutronix,
+ *               Marc Kleine-Budde <kernel@pengutronix.de>
+ */
+
+#ifndef _MCP251XFD_DUMP_USERSPACE_H
+#define _MCP251XFD_DUMP_USERSPACE_H
+
+#include "mcp251xfd.h"
+#include "mcp251xfd-dump.h"
+
+#define MCP251XFD_TX_FIFO 1
+#define MCP251XFD_RX_FIFO(x) (MCP251XFD_TX_FIFO + 1 + (x))
+
+struct mcp251xfd_mem {
+	char buf[0x1000];
+};
+
+struct mcp251xfd_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u16 base;
+	u8 nr;
+	u8 fifo_nr;
+	u8 obj_num;
+	u8 obj_size;
+};
+
+struct mcp251xfd_priv {
+	struct regmap *map;
+
+	struct mcp251xfd_ring tef[1];
+	struct mcp251xfd_ring tx[1];
+	struct mcp251xfd_ring rx[1];
+
+	u8 rx_ring_num;
+};
+
+static inline u8 mcp251xfd_get_ring_head(const struct mcp251xfd_ring *ring)
+{
+	return ring->head & (ring->obj_num - 1);
+}
+
+static inline u8 mcp251xfd_get_ring_tail(const struct mcp251xfd_ring *ring)
+{
+	return ring->tail & (ring->obj_num - 1);
+}
+
+void mcp251xfd_dump(struct mcp251xfd_priv *priv);
+int mcp251xfd_dev_coredump_read(struct mcp251xfd_priv *priv,
+				struct mcp251xfd_mem *mem,
+				const char *file_path);
+int mcp251xfd_regmap_read(struct mcp251xfd_priv *priv,
+			  struct mcp251xfd_mem *mem,
+			  const char *file_path);
+
+#endif
diff --git a/canutils/mcp251xfd/mcp251xfd-dump.c b/canutils/mcp251xfd/mcp251xfd-dump.c
new file mode 100644
index 0000000000..e84e580ff3
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd-dump.c
@@ -0,0 +1,882 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Microchip MCP251xFD Family CAN controller debug tool
+//
+// Copyright (c) 2019, 2020, 2021 Pengutronix,
+//               Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include <linux/kernel.h>
+
+#include "mcp251xfd-dump-userspace.h"
+
+struct mcp251xfd_dump_regs_fifo {
+	u32 con;
+	u32 sta;
+	u32 ua;
+};
+
+struct mcp251xfd_dump_regs_filter {
+	u32 obj;
+	u32 mask;
+};
+
+struct mcp251xfd_dump_regs {
+	u32 con;
+	u32 nbtcfg;
+	u32 dbtcfg;
+	u32 tdc;
+	u32 tbc;
+	u32 tscon;
+	u32 vec;
+	u32 intf;
+	u32 rxif;
+	u32 txif;
+	u32 rxovif;
+	u32 txatif;
+	u32 txreq;
+	u32 trec;
+	u32 bdiag0;
+	u32 bdiag1;
+	union {
+		struct {
+			u32 tefcon;
+			u32 tefsta;
+			u32 tefua;
+		};
+		struct mcp251xfd_dump_regs_fifo tef;
+	};
+	u32 reserved0;
+	union {
+		struct {
+			struct mcp251xfd_dump_regs_fifo txq;
+			struct mcp251xfd_dump_regs_fifo tx_fifo;
+			struct mcp251xfd_dump_regs_fifo rx_fifo;
+		};
+		struct mcp251xfd_dump_regs_fifo fifo[32];
+	};
+	u32 fltcon[8];
+	struct mcp251xfd_dump_regs_filter filter[32];
+};
+
+struct mcp251xfd_dump_ram {
+	u8 ram[MCP251XFD_RAM_SIZE];
+};
+
+struct mcp251xfd_dump_regs_mcp251xfd {
+	u32 osc;
+	u32 iocon;
+	u32 crc;
+	u32 ecccon;
+	u32 eccstat;
+	u32 devid;
+};
+
+#define __dump_bit(val, prefix, bit, desc)	       \
+	pr_info("%16s   %s\t\t%s\n", __stringify(bit), \
+		(val) & prefix##_##bit ? "x" : " ", desc)
+
+#define __dump_mask(val, prefix, mask, fmt, desc) \
+	pr_info("%16s = " fmt "\t\t%s\n", \
+		__stringify(mask), \
+		FIELD_GET(prefix##_##mask##_MASK, (val)), \
+		desc)
+
+static void mcp251xfd_dump_reg_con(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("CON: con(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_CON, TXBWS, "0x%02lx", "Transmit Bandwidth Sharing");
+	__dump_bit(val, MCP251XFD_REG_CON, ABAT, "Abort All Pending Transmissions");
+	__dump_mask(val, MCP251XFD_REG_CON, REQOP, "0x%02lx", "Request Operation Mode");
+	__dump_mask(val, MCP251XFD_REG_CON, OPMOD, "0x%02lx", "Operation Mode Status");
+	__dump_bit(val, MCP251XFD_REG_CON, TXQEN, "Enable Transmit Queue");
+	__dump_bit(val, MCP251XFD_REG_CON, STEF, "Store in Transmit Event FIFO");
+	__dump_bit(val, MCP251XFD_REG_CON, SERR2LOM, "Transition to Listen Only Mode on System Error");
+	__dump_bit(val, MCP251XFD_REG_CON, ESIGM, "Transmit ESI in Gateway Mode");
+	__dump_bit(val, MCP251XFD_REG_CON, RTXAT, "Restrict Retransmission Attempts");
+	__dump_bit(val, MCP251XFD_REG_CON, BRSDIS, "Bit Rate Switching Disable");
+	__dump_bit(val, MCP251XFD_REG_CON, BUSY, "CAN Module is Busy");
+	__dump_mask(val, MCP251XFD_REG_CON, WFT, "0x%02lx", "Selectable Wake-up Filter Time");
+	__dump_bit(val, MCP251XFD_REG_CON, WAKFIL, "Enable CAN Bus Line Wake-up Filter");
+	__dump_bit(val, MCP251XFD_REG_CON, PXEDIS, "Protocol Exception Event Detection Disabled");
+	__dump_bit(val, MCP251XFD_REG_CON, ISOCRCEN, "Enable ISO CRC in CAN FD Frames");
+	__dump_mask(val, MCP251XFD_REG_CON, DNCNT, "0x%02lx", "Device Net Filter Bit Number");
+}
+
+static void mcp251xfd_dump_reg_nbtcfg(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("NBTCFG: nbtcfg(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_NBTCFG, BRP, "%3lu", "Baud Rate Prescaler");
+	__dump_mask(val, MCP251XFD_REG_NBTCFG, TSEG1, "%3lu", "Time Segment 1 (Propagation Segment + Phase Segment 1)");
+	__dump_mask(val, MCP251XFD_REG_NBTCFG, TSEG2, "%3lu", "Time Segment 2 (Phase Segment 2)");
+	__dump_mask(val, MCP251XFD_REG_NBTCFG, SJW, "%3lu", "Synchronization Jump Width");
+}
+
+static void mcp251xfd_dump_reg_dbtcfg(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("DBTCFG: dbtcfg(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_DBTCFG, BRP, "%3lu", "Baud Rate Prescaler");
+	__dump_mask(val, MCP251XFD_REG_DBTCFG, TSEG1, "%3lu", "Time Segment 1 (Propagation Segment + Phase Segment 1)");
+	__dump_mask(val, MCP251XFD_REG_DBTCFG, TSEG2, "%3lu", "Time Segment 2 (Phase Segment 2)");
+	__dump_mask(val, MCP251XFD_REG_DBTCFG, SJW, "%3lu", "Synchronization Jump Width");
+}
+
+static void mcp251xfd_dump_reg_tdc(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TDC: tdc(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP251XFD_REG_TDC, EDGFLTEN, "Enable Edge Filtering during Bus Integration state");
+	__dump_bit(val, MCP251XFD_REG_TDC, SID11EN, "Enable 12-Bit SID in CAN FD Base Format Messages");
+	__dump_mask(val, MCP251XFD_REG_TDC, TDCMOD, "0x%02lx", "Transmitter Delay Compensation Mode");
+	__dump_mask(val, MCP251XFD_REG_TDC, TDCO, "0x%02lx", "Transmitter Delay Compensation Offset");
+	__dump_mask(val, MCP251XFD_REG_TDC, TDCV, "0x%02lx", "Transmitter Delay Compensation Value");
+}
+
+static void mcp251xfd_dump_reg_tbc(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TBC: tbc(0x%03x)=0x%08x\n", addr, val);
+}
+
+static void mcp251xfd_dump_reg_vec(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	u8 rx_code, tx_code, i_code;
+
+	pr_info("VEC: vec(0x%03x)=0x%08x\n", addr, val);
+
+	rx_code = FIELD_GET(MCP251XFD_REG_VEC_RXCODE_MASK, val);
+	tx_code = FIELD_GET(MCP251XFD_REG_VEC_TXCODE_MASK, val);
+	i_code = FIELD_GET(MCP251XFD_REG_VEC_ICODE_MASK, val);
+
+	pr_info("\trxcode: ");
+	if (rx_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (rx_code < 0x20)
+		pr_cont("FIFO %u", rx_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", rx_code);
+
+	pr_info("\ttxcode: ");
+	if (tx_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (tx_code < 0x20)
+		pr_cont("FIFO %u", tx_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", tx_code);
+
+	pr_info("\ticode: ");
+	if (i_code == 0x4a)
+		pr_cont("Transmit Attempt Interrupt");
+	else if (i_code == 0x49)
+		pr_cont("Transmit Event FIFO Interrupt");
+	else if (i_code == 0x48)
+		pr_cont("Invalid Message Occurred");
+	else if (i_code == 0x47)
+		pr_cont("Operation Mode Changed");
+	else if (i_code == 0x46)
+		pr_cont("TBC Overflow");
+	else if (i_code == 0x45)
+		pr_cont("RX/TX MAB Overflow/Underflow");
+	else if (i_code == 0x44)
+		pr_cont("Address Error Interrupt");
+	else if (i_code == 0x43)
+		pr_cont("Receive FIFO Overflow Interrupt");
+	else if (i_code == 0x42)
+		pr_cont("Wake-up Interrupt");
+	else if (i_code == 0x41)
+		pr_cont("Error Interrupt");
+	else if (i_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (i_code < 0x20)
+		pr_cont("FIFO %u", i_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", i_code);
+}
+
+#define __dump_int(val, bit, desc) \
+	pr_info("\t" __stringify(bit) "\t%s\t%s\t%s\t%s\n", \
+		 (val) & MCP251XFD_REG_INT_##bit##E ? "x" : "", \
+		 (val) & MCP251XFD_REG_INT_##bit##F ? "x" : "", \
+		 FIELD_GET(MCP251XFD_REG_INT_IF_MASK, val) & \
+		 FIELD_GET(MCP251XFD_REG_INT_IE_MASK, val) & \
+		 MCP251XFD_REG_INT_##bit##F ? "x" : "", \
+		 desc)
+
+static void mcp251xfd_dump_reg_intf(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("INT: intf(0x%03x)=0x%08x\n", addr, val);
+
+	pr_info("\t\tIE\tIF\tIE & IF\n");
+	__dump_int(val, IVMI, "Invalid Message Interrupt");
+	__dump_int(val, WAKI, "Bus Wake Up Interrupt");
+	__dump_int(val, CERRI, "CAN Bus Error Interrupt");
+	__dump_int(val, SERRI, "System Error Interrupt");
+	__dump_int(val, RXOVI, "Receive FIFO Overflow Interrupt");
+	__dump_int(val, TXATI, "Transmit Attempt Interrupt");
+	__dump_int(val, SPICRCI, "SPI CRC Error Interrupt");
+	__dump_int(val, ECCI, "ECC Error Interrupt");
+	__dump_int(val, TEFI, "Transmit Event FIFO Interrupt");
+	__dump_int(val, MODI, "Mode Change Interrupt");
+	__dump_int(val, TBCI, "Time Base Counter Interrupt");
+	__dump_int(val, RXI, "Receive FIFO Interrupt");
+	__dump_int(val, TXI, "Transmit FIFO Interrupt");
+}
+
+#undef __dump_int
+
+#define __create_dump_fifo_bitmask(fifo, name, description) \
+static void mcp251xfd_dump_reg_##fifo(const struct mcp251xfd_priv *priv, u32 val, u16 addr) \
+{ \
+	int i; \
+\
+	pr_info(__stringify(name) ": " __stringify(fifo) "(0x%03x)=0x%08x\n", addr, val); \
+	pr_info(description ":\n"); \
+	if (!val) { \
+		pr_info("\t\t-none-\n"); \
+		return; \
+	} \
+\
+	pr_info("\t\t"); \
+	for (i = 0; i < sizeof(val); i++) { \
+		if (val & BIT(i)) \
+			pr_cont("%d ", i); \
+	} \
+\
+	pr_cont("\n"); \
+}
+
+__create_dump_fifo_bitmask(rxif, RXIF, "Receive FIFO Interrupt Pending");
+__create_dump_fifo_bitmask(rxovif, RXOVIF, "Receive FIFO Overflow Interrupt Pending");
+__create_dump_fifo_bitmask(txif, TXIF, "Transmit FIFO Interrupt Pending");
+__create_dump_fifo_bitmask(txatif, TXATIF, "Transmit FIFO Attempt Interrupt Pending");
+__create_dump_fifo_bitmask(txreq, TXREQ, "Message Send Request");
+
+#undef __create_dump_fifo_bitmask
+
+static void mcp251xfd_dump_reg_trec(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TREC: trec(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP251XFD_REG_TREC, TXBO, "Transmitter in Bus Off State");
+	__dump_bit(val, MCP251XFD_REG_TREC, TXBP, "Transmitter in Error Passive State");
+	__dump_bit(val, MCP251XFD_REG_TREC, RXBP, "Receiver in Error Passive State");
+	__dump_bit(val, MCP251XFD_REG_TREC, TXWARN, "Transmitter in Error Warning State");
+	__dump_bit(val, MCP251XFD_REG_TREC, RXWARN, "Receiver in Error Warning State");
+	__dump_bit(val, MCP251XFD_REG_TREC, EWARN, "Transmitter or Receiver is in Error Warning State");
+
+	__dump_mask(val, MCP251XFD_REG_TREC, TEC, "%3lu", "Transmit Error Counter");
+	__dump_mask(val, MCP251XFD_REG_TREC, REC, "%3lu", "Receive Error Counter");
+}
+
+static void mcp251xfd_dump_reg_bdiag0(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("BDIAG0: bdiag0(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_BDIAG0, DTERRCNT, "%3lu", "Data Bit Rate Transmit Error Counter");
+	__dump_mask(val, MCP251XFD_REG_BDIAG0, DRERRCNT, "%3lu", "Data Bit Rate Receive Error Counter");
+	__dump_mask(val, MCP251XFD_REG_BDIAG0, NTERRCNT, "%3lu", "Nominal Bit Rate Transmit Error Counter");
+	__dump_mask(val, MCP251XFD_REG_BDIAG0, NRERRCNT, "%3lu", "Nominal Bit Rate Receive Error Counter");
+}
+
+static void mcp251xfd_dump_reg_bdiag1(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("BDIAG1: bdiag1(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, DLCMM, "DLC Mismatch");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, ESI, "ESI flag of a received CAN FD message was set");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, DCRCERR, "Data CRC Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, DSTUFERR, "Data Bit Stuffing Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, DFORMERR, "Data Format Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, DBIT1ERR, "Data BIT1 Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, DBIT0ERR, "Data BIT0 Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, TXBOERR, "Device went to bus-off (and auto-recovered)");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, NCRCERR, "CRC Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, NSTUFERR, "Bit Stuffing Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, NFORMERR, "Format Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, NACKERR, "Transmitted message was not acknowledged");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, NBIT1ERR, "Bit1 Error");
+	__dump_bit(val, MCP251XFD_REG_BDIAG1, NBIT0ERR, "Bit0 Error");
+	__dump_mask(val, MCP251XFD_REG_BDIAG1, EFMSGCNT, "%3lu", "Error Free Message Counter");
+}
+
+static void mcp251xfd_dump_reg_osc(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("OSC: osc(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP251XFD_REG_OSC, SCLKRDY, "Synchronized SCLKDIV");
+	__dump_bit(val, MCP251XFD_REG_OSC, OSCRDY, "Clock Ready");
+	__dump_bit(val, MCP251XFD_REG_OSC, PLLRDY, "PLL Ready");
+	__dump_mask(val, MCP251XFD_REG_OSC, CLKODIV, "0x%02lu", "Clock Output Divisor");
+	__dump_bit(val, MCP251XFD_REG_OSC, SCLKDIV, "System Clock Divisor");
+	__dump_bit(val, MCP251XFD_REG_OSC, LPMEN, "Low Power Mode (LPM) Enable (MCP2518FD only)");
+	__dump_bit(val, MCP251XFD_REG_OSC, OSCDIS, "Clock (Oscillator) Disable");
+	__dump_bit(val, MCP251XFD_REG_OSC, PLLEN, "PLL Enable");
+}
+
+static void mcp251xfd_dump_reg_iocon(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("IOCON: iocon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP251XFD_REG_IOCON, INTOD, "Interrupt pins Open Drain Mode (0: Push/Pull Output, 1: Open Drain Output)");
+	__dump_bit(val, MCP251XFD_REG_IOCON, SOF, "Start-Of-Frame signal (0: Clock on CLKO pin, 1: SOF signal on CLKO pin)");
+	__dump_bit(val, MCP251XFD_REG_IOCON, TXCANOD, "TXCAN Open Drain Mode (0: Push/Pull Output, 1: Open Drain Output)");
+	__dump_bit(val, MCP251XFD_REG_IOCON, PM1, "GPIO Pin Mode (0: Interrupt Pin INT1 (RXIF), 1: Pin is used as GPIO1)");
+	__dump_bit(val, MCP251XFD_REG_IOCON, PM0, "GPIO Pin Mode (0: Interrupt Pin INT0 (TXIF), 1: Pin is used as GPIO0)");
+	__dump_bit(val, MCP251XFD_REG_IOCON, GPIO1, "GPIO1 Status");
+	__dump_bit(val, MCP251XFD_REG_IOCON, GPIO0, "GPIO0 Status");
+	__dump_bit(val, MCP251XFD_REG_IOCON, LAT1, "GPIO1 Latch");
+	__dump_bit(val, MCP251XFD_REG_IOCON, LAT0, "GPIO0 Latch");
+	__dump_bit(val, MCP251XFD_REG_IOCON, XSTBYEN, "Enable Transceiver Standby Pin Control");
+	__dump_bit(val, MCP251XFD_REG_IOCON, TRIS1, "GPIO1 Data Direction (0: Output Pin, 1: Input Pin)");
+	__dump_bit(val, MCP251XFD_REG_IOCON, TRIS0, "GPIO0 Data Direction (0: Output Pin, 1: Input Pin)");
+}
+
+static void mcp251xfd_dump_reg_tefcon(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFCON: tefcon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_TEFCON, FSIZE, "%3lu", "FIFO Size");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, FRESET, "FIFO Reset");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, UINC, "Increment Tail");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, TEFTSEN, "Transmit Event FIFO Time Stamp Enable");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, TEFOVIE, "Transmit Event FIFO Overflow Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, TEFFIE, "Transmit Event FIFO Full Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, TEFHIE, "Transmit Event FIFO Half Full Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_TEFCON, TEFNEIE, "Transmit Event FIFO Not Empty Interrupt Enable");
+}
+
+static void mcp251xfd_dump_reg_tefsta(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFSTA: tefsta(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP251XFD_REG_TEFSTA, TEFOVIF, "Transmit Event FIFO Overflow Interrupt Flag");
+	__dump_bit(val, MCP251XFD_REG_TEFSTA, TEFFIF, "Transmit Event FIFO Full Interrupt Flag (0: not full)");
+	__dump_bit(val, MCP251XFD_REG_TEFSTA, TEFHIF, "Transmit Event FIFO Half Full Interrupt Flag (0: < half full)");
+	__dump_bit(val, MCP251XFD_REG_TEFSTA, TEFNEIF, "Transmit Event FIFO Not Empty Interrupt Flag (0: empty)");
+}
+
+static void mcp251xfd_dump_reg_tefua(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFUA: tefua(0x%03x)=0x%08x\n", addr, val);
+}
+
+static void mcp251xfd_dump_reg_fifocon(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOCON: fifocon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_FIFOCON, PLSIZE, "%3lu", "Payload Size");
+	__dump_mask(val, MCP251XFD_REG_FIFOCON, FSIZE, "%3lu", "FIFO Size");
+	__dump_mask(val, MCP251XFD_REG_FIFOCON, TXAT, "%3lu", "Retransmission Attempts");
+	__dump_mask(val, MCP251XFD_REG_FIFOCON, TXPRI, "%3lu", "Message Transmit Priority");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, FRESET, "FIFO Reset");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, TXREQ, "Message Send Request");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, UINC, "Increment Head/Tail");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, TXEN, "TX/RX FIFO Selection (0: RX, 1: TX)");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, RTREN, "Auto RTR Enable");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, RXTSEN, "Received Message Time Stamp Enable");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, TXATIE, "Transmit Attempts Exhausted Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, RXOVIE, "Overflow Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, TFERFFIE, "Transmit/Receive FIFO Empty/Full Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, TFHRFHIE, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Enable");
+	__dump_bit(val, MCP251XFD_REG_FIFOCON, TFNRFNIE, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Enable");
+}
+
+static void mcp251xfd_dump_reg_fifosta(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOSTA: fifosta(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP251XFD_REG_FIFOSTA, FIFOCI, "%3lu", "FIFO Message Index");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TXABT, "Message Aborted Status (0: completed successfully, 1: aborted)");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TXLARB, "Message Lost Arbitration Status");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TXERR, "Error Detected During Transmission");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TXATIF, "Transmit Attempts Exhausted Interrupt Pending");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, RXOVIF, "Receive FIFO Overflow Interrupt Flag");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TFERFFIF, "Transmit/Receive FIFO Empty/Full Interrupt Flag");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TFHRFHIF, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Flag");
+	__dump_bit(val, MCP251XFD_REG_FIFOSTA, TFNRFNIF, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Flag");
+}
+
+static void mcp251xfd_dump_reg_fifoua(const struct mcp251xfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOUA: fifoua(0x%03x)=0x%08x\n", addr, val);
+}
+
+#define __dump_call(regs, val) \
+do { \
+	mcp251xfd_dump_reg_##val(priv, (regs)->val, \
+				 (u16)(offsetof(typeof(*(regs)), val) + \
+				       (sizeof(*(regs)) == sizeof(struct mcp251xfd_dump_regs) ? \
+					0 : MCP251XFD_REG_OSC))); \
+	pr_info("\n"); \
+} while (0)
+
+#define __dump_call_fifo(reg, val) \
+do { \
+	mcp251xfd_dump_reg_##reg(priv, regs->val, (u16)offsetof(typeof(*regs), val)); \
+	pr_info("\n"); \
+} while (0)
+
+static void
+mcp251xfd_dump_regs(const struct mcp251xfd_priv *priv,
+		    const struct mcp251xfd_dump_regs *regs,
+		    const struct mcp251xfd_dump_regs_mcp251xfd *regs_mcp251xfd)
+{
+	netdev_info(priv->ndev, "-------------------- register dump --------------------\n");
+	__dump_call(regs, con);
+	__dump_call(regs, nbtcfg);
+	__dump_call(regs, dbtcfg);
+	__dump_call(regs, tdc);
+	__dump_call(regs, tbc);
+	__dump_call(regs, vec);
+	__dump_call(regs, intf);
+	__dump_call(regs, rxif);
+	__dump_call(regs, rxovif);
+	__dump_call(regs, txif);
+	__dump_call(regs, txatif);
+	__dump_call(regs, txreq);
+	__dump_call(regs, trec);
+	__dump_call(regs, bdiag0);
+	__dump_call(regs, bdiag1);
+	__dump_call(regs_mcp251xfd, osc);
+	__dump_call(regs_mcp251xfd, iocon);
+	pr_info("-------------------- TEF --------------------\n");
+	__dump_call(regs, tefcon);
+	__dump_call(regs, tefsta);
+	__dump_call(regs, tefua);
+	pr_info("-------------------- TX_FIFO --------------------\n");
+	__dump_call_fifo(fifocon, fifo[MCP251XFD_TX_FIFO].con);
+	__dump_call_fifo(fifosta, fifo[MCP251XFD_TX_FIFO].sta);
+	__dump_call_fifo(fifoua, fifo[MCP251XFD_TX_FIFO].ua);
+	pr_info(" -------------------- RX_FIFO --------------------\n");
+	__dump_call_fifo(fifocon, fifo[MCP251XFD_RX_FIFO(0)].con);
+	__dump_call_fifo(fifosta, fifo[MCP251XFD_RX_FIFO(0)].sta);
+	__dump_call_fifo(fifoua, fifo[MCP251XFD_RX_FIFO(0)].ua);
+	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
+}
+
+#undef __dump_call
+#undef __dump_call_fifo
+
+static u8 mcp251xfd_dump_get_fifo_size(const struct mcp251xfd_priv *priv, const struct mcp251xfd_dump_regs *regs, u32 fifo_con)
+{
+	u8 obj_size;
+
+	obj_size = FIELD_GET(MCP251XFD_REG_FIFOCON_PLSIZE_MASK, fifo_con);
+	switch (obj_size) {
+	case MCP251XFD_REG_FIFOCON_PLSIZE_8:
+		return 8;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_12:
+		return 12;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_16:
+		return 16;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_20:
+		return 20;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_24:
+		return 24;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_32:
+		return 32;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_48:
+		return 48;
+	case MCP251XFD_REG_FIFOCON_PLSIZE_64:
+		return 64;
+	}
+
+	return 0;
+}
+
+static u8 mcp251xfd_dump_get_fifo_obj_num(const struct mcp251xfd_priv *priv, const struct mcp251xfd_dump_regs *regs, u32 fifo_con)
+{
+	u8 obj_num;
+
+	obj_num = FIELD_GET(MCP251XFD_REG_FIFOCON_FSIZE_MASK, fifo_con);
+
+	return obj_num + 1;
+}
+
+static void mcp251xfd_dump_ram_fifo_obj_data(const struct mcp251xfd_priv *priv, const u8 *data, u8 dlc)
+{
+	int i;
+	u8 len;
+
+	len = can_dlc2len(get_canfd_dlc(dlc));
+
+	if (!len) {
+		pr_info("%16s = -none-\n", "data");
+		return;
+	}
+
+	for (i = 0; i < len; i++) {
+		if ((i % 8) == 0) {
+			if (i == 0)
+				pr_info("%16s = %02x", "data", data[i]);
+			else
+				pr_info("                   %02x", data[i]);
+		} else if ((i % 4) == 0) {
+			pr_cont("  %02x", data[i]);
+		} else if ((i % 8) == 7) {
+			pr_cont(" %02x\n", data[i]);
+		} else {
+			pr_cont(" %02x", data[i]);
+		}
+	}
+
+	if (i % 8)
+		pr_cont("\n");
+}
+
+/* TEF */
+
+static u8
+mcp251xfd_dump_get_tef_obj_num(const struct mcp251xfd_priv *priv,
+			       const struct mcp251xfd_dump_regs *regs)
+{
+	return mcp251xfd_dump_get_fifo_obj_num(priv, regs, regs->tef.con);
+}
+
+static u8
+mcp251xfd_dump_get_tef_tail(const struct mcp251xfd_priv *priv,
+			    const struct mcp251xfd_dump_regs *regs)
+{
+	return regs->tefua / sizeof(struct mcp251xfd_hw_tef_obj);
+}
+
+static u16
+mcp251xfd_dump_get_tef_obj_rel_addr(const struct mcp251xfd_priv *priv,
+				    u8 n)
+{
+	return sizeof(struct mcp251xfd_hw_tef_obj) * n;
+}
+
+static u16
+mcp251xfd_dump_get_tef_obj_addr(const struct mcp251xfd_priv *priv,
+				u8 n)
+{
+	return mcp251xfd_dump_get_tef_obj_rel_addr(priv, n) +
+		MCP251XFD_RAM_START;
+}
+
+/* TX */
+
+static u8
+mcp251xfd_dump_get_tx_obj_size(const struct mcp251xfd_priv *priv,
+			       const struct mcp251xfd_dump_regs *regs)
+{
+	return sizeof(struct mcp251xfd_hw_tx_obj_can) -
+		sizeof_field(struct mcp251xfd_hw_tx_obj_can, data) +
+		mcp251xfd_dump_get_fifo_size(priv, regs, regs->tx_fifo.con);
+}
+
+static u8
+mcp251xfd_dump_get_tx_obj_num(const struct mcp251xfd_priv *priv,
+			      const struct mcp251xfd_dump_regs *regs)
+{
+	return mcp251xfd_dump_get_fifo_obj_num(priv, regs, regs->tx_fifo.con);
+}
+
+static u16
+mcp251xfd_dump_get_tx_obj_rel_addr(const struct mcp251xfd_priv *priv,
+				   const struct mcp251xfd_dump_regs *regs,
+				   u8 n)
+{
+	return mcp251xfd_dump_get_tef_obj_rel_addr(priv, mcp251xfd_dump_get_tef_obj_num(priv, regs)) +
+		mcp251xfd_dump_get_tx_obj_size(priv, regs) * n;
+}
+
+static u16
+mcp251xfd_dump_get_tx_obj_addr(const struct mcp251xfd_priv *priv,
+			       const struct mcp251xfd_dump_regs *regs, u8 n)
+{
+	return mcp251xfd_dump_get_tx_obj_rel_addr(priv, regs, n) +
+		MCP251XFD_RAM_START;
+}
+
+static u8
+mcp251xfd_dump_get_tx_tail(const struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_dump_regs *regs)
+{
+	return (regs->fifo[MCP251XFD_TX_FIFO].ua -
+		mcp251xfd_dump_get_tx_obj_rel_addr(priv, regs, 0)) /
+		mcp251xfd_dump_get_tx_obj_size(priv, regs);
+}
+
+static u8
+mcp251xfd_dump_get_tx_head(const struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_dump_regs *regs)
+{
+	return FIELD_GET(MCP251XFD_REG_FIFOSTA_FIFOCI_MASK,
+			 regs->fifo[MCP251XFD_TX_FIFO].sta);
+}
+
+/* RX */
+
+static u8
+mcp251xfd_dump_get_rx_obj_size(const struct mcp251xfd_priv *priv,
+			       const struct mcp251xfd_dump_regs *regs)
+{
+	return sizeof(struct mcp251xfd_hw_rx_obj_can) -
+		sizeof_field(struct mcp251xfd_hw_rx_obj_can, data) +
+		mcp251xfd_dump_get_fifo_size(priv, regs, regs->rx_fifo.con);
+}
+
+static u8
+mcp251xfd_dump_get_rx_obj_num(const struct mcp251xfd_priv *priv,
+			      const struct mcp251xfd_dump_regs *regs)
+{
+	return mcp251xfd_dump_get_fifo_obj_num(priv, regs, regs->rx_fifo.con);
+}
+
+static u16
+mcp251xfd_dump_get_rx_obj_rel_addr(const struct mcp251xfd_priv *priv,
+				   const struct mcp251xfd_dump_regs *regs, u8 n)
+{
+	return mcp251xfd_dump_get_tx_obj_rel_addr(priv, regs, mcp251xfd_dump_get_tx_obj_num(priv, regs)) +
+		mcp251xfd_dump_get_rx_obj_size(priv, regs) * n;
+}
+
+static u16
+mcp251xfd_dump_get_rx_obj_addr(const struct mcp251xfd_priv *priv,
+			       const struct mcp251xfd_dump_regs *regs, u8 n)
+{
+	return mcp251xfd_dump_get_rx_obj_rel_addr(priv, regs, n) + MCP251XFD_RAM_START;
+}
+
+static u8
+mcp251xfd_dump_get_rx_tail(const struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_dump_regs *regs)
+{
+	return (regs->fifo[MCP251XFD_RX_FIFO(0)].ua -
+		mcp251xfd_dump_get_rx_obj_rel_addr(priv, regs, 0)) /
+		mcp251xfd_dump_get_rx_obj_size(priv, regs);
+}
+
+static u8
+mcp251xfd_dump_get_rx_head(const struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_dump_regs *regs)
+{
+	return FIELD_GET(MCP251XFD_REG_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP251XFD_RX_FIFO(0)].sta);
+}
+
+/* dump TEF */
+
+static void
+mcp251xfd_dump_ram_tef_obj_one(const struct mcp251xfd_priv *priv,
+			       const struct mcp251xfd_dump_regs *regs,
+			       const struct mcp251xfd_ring *tef,
+			       const struct mcp251xfd_hw_tef_obj *hw_tef_obj,
+			       u8 n)
+{
+	pr_info("TEF Object: 0x%02x (0x%03x)%s%s%s%s%s\n",
+		n, mcp251xfd_dump_get_tef_obj_addr(priv, n),
+		mcp251xfd_get_ring_head(tef) == n ? "  priv-HEAD" : "",
+		mcp251xfd_dump_get_tef_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp251xfd_get_ring_tail(tef) == n ? "  priv-TAIL" : "",
+		(mcp251xfd_dump_get_tef_tail(priv, regs) == n ?
+		 ((regs->tef.sta & MCP251XFD_REG_TEFSTA_TEFFIF) ? "  chip-FIFO-full" :
+		  !(regs->tef.sta & MCP251XFD_REG_TEFSTA_TEFNEIF) ? "  chip-FIFO-empty" : "") :
+		 ("")),
+		(mcp251xfd_get_ring_head(tef) == mcp251xfd_get_ring_tail(tef) &&
+		 mcp251xfd_get_ring_tail(tef) == n ?
+		 (priv->tef->head == priv->tef->tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_tef_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_tef_obj->flags);
+	pr_info("%16s = 0x%08x\n", "ts", hw_tef_obj->ts);
+	__dump_mask(hw_tef_obj->flags, MCP251XFD_OBJ_FLAGS, SEQ, "0x%06lx", "Sequence");
+	pr_info("\n");
+}
+
+static void
+mcp251xfd_dump_ram_tef_obj(const struct mcp251xfd_priv *priv,
+			   const struct mcp251xfd_dump_regs *regs,
+			   const struct mcp251xfd_dump_ram *ram,
+			   const struct mcp251xfd_ring *tef)
+{
+	int i;
+
+	pr_info("\nTEF Overview:\n");
+	pr_info("%16s =        0x%02x    0x%08x\n", "head (p)",
+		mcp251xfd_get_ring_head(tef),
+		tef->head);
+	pr_info("%16s = 0x%02x   0x%02x    0x%08x\n", "tail (c/p)",
+		mcp251xfd_dump_get_tef_tail(priv, regs),
+		mcp251xfd_get_ring_tail(tef),
+		tef->tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp251xfd_dump_get_tef_obj_num(priv, regs); i++) {
+		const struct mcp251xfd_hw_tef_obj *hw_tef_obj;
+		u16 hw_tef_obj_rel_addr;
+
+		hw_tef_obj_rel_addr = mcp251xfd_dump_get_tef_obj_rel_addr(priv, i);
+
+		hw_tef_obj = (const struct mcp251xfd_hw_tef_obj *)&ram->ram[hw_tef_obj_rel_addr];
+		mcp251xfd_dump_ram_tef_obj_one(priv, regs, tef, hw_tef_obj, i);
+	}
+}
+
+/* dump TX */
+
+static void
+mcp251xfd_dump_ram_tx_obj_one(const struct mcp251xfd_priv *priv,
+			      const struct mcp251xfd_dump_regs *regs,
+			      const struct mcp251xfd_ring *tx,
+			      const struct mcp251xfd_hw_tx_obj_canfd *hw_tx_obj,
+			      u8 n)
+{
+	pr_info("TX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
+		n, mcp251xfd_dump_get_tx_obj_addr(priv, regs, n),
+		mcp251xfd_dump_get_tx_head(priv, regs) == n ? "  chip-HEAD" : "",
+		mcp251xfd_get_ring_head(tx) == n ? "  priv-HEAD" : "",
+		mcp251xfd_dump_get_tx_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp251xfd_get_ring_tail(tx) == n ? "  priv-TAIL" : "",
+		mcp251xfd_dump_get_tx_tail(priv, regs) == n ?
+		(!(regs->tx_fifo.sta & MCP251XFD_REG_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-full" :
+		 (regs->tx_fifo.sta & MCP251XFD_REG_FIFOSTA_TFERFFIF) ? "  chip-FIFO-empty" : "") :
+		(""),
+		(mcp251xfd_get_ring_head(tx) == mcp251xfd_get_ring_tail(tx) &&
+		 mcp251xfd_get_ring_tail(tx) == n ?
+		 (tx->head == tx->tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_tx_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_tx_obj->flags);
+	__dump_mask(hw_tx_obj->flags, MCP251XFD_OBJ_FLAGS, SEQ_MCP2517FD, "0x%06lx", "Sequence (MCP2517)");
+	__dump_mask(hw_tx_obj->flags, MCP251XFD_OBJ_FLAGS, SEQ_MCP2518FD, "0x%06lx", "Sequence (MCP2518)");
+	mcp251xfd_dump_ram_fifo_obj_data(priv,
+					 hw_tx_obj->data,
+					 FIELD_GET(MCP251XFD_OBJ_FLAGS_DLC, hw_tx_obj->flags));
+	pr_info("\n");
+}
+
+static void
+mcp251xfd_dump_ram_tx_obj(const struct mcp251xfd_priv *priv,
+			  const struct mcp251xfd_dump_regs *regs,
+			  const struct mcp251xfd_dump_ram *ram,
+			  const struct mcp251xfd_ring *tx)
+{
+	int i;
+
+	pr_info("\nTX Overview:\n");
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)",
+		mcp251xfd_dump_get_tx_head(priv, regs),
+		mcp251xfd_get_ring_head(tx),
+		tx->head);
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)",
+		mcp251xfd_dump_get_tx_tail(priv, regs),
+		mcp251xfd_get_ring_tail(tx),
+		tx->tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp251xfd_dump_get_tx_obj_num(priv, regs); i++) {
+		const struct mcp251xfd_hw_tx_obj_canfd *hw_tx_obj;
+		u16 hw_tx_obj_rel_addr;
+
+		hw_tx_obj_rel_addr = mcp251xfd_dump_get_tx_obj_rel_addr(priv, regs, i);
+
+		hw_tx_obj = (const struct mcp251xfd_hw_tx_obj_canfd *)&ram->ram[hw_tx_obj_rel_addr];
+		mcp251xfd_dump_ram_tx_obj_one(priv, regs, tx, hw_tx_obj, i);
+	}
+}
+
+/* dump RX */
+
+static void
+mcp251xfd_dump_ram_rx_obj_one(const struct mcp251xfd_priv *priv,
+			      const struct mcp251xfd_dump_regs *regs,
+			      const struct mcp251xfd_ring *rx,
+			      const struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj,
+			      u8 n)
+{
+	pr_info("RX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
+		n, mcp251xfd_dump_get_rx_obj_addr(priv, regs, n),
+		mcp251xfd_dump_get_rx_head(priv, regs) == n ? "  chip-HEAD" : "",
+		mcp251xfd_get_ring_head(rx) == n ? "  priv-HEAD" : "",
+		mcp251xfd_dump_get_rx_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp251xfd_get_ring_tail(rx) == n ? "  priv-TAIL" : "",
+		mcp251xfd_dump_get_rx_tail(priv, regs) == n ?
+		((regs->rx_fifo.sta & MCP251XFD_REG_FIFOSTA_TFERFFIF) ? "  chip-FIFO-full" :
+		 !(regs->rx_fifo.sta & MCP251XFD_REG_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-empty" : "") :
+		(""),
+		(mcp251xfd_get_ring_head(rx) == mcp251xfd_get_ring_tail(rx) &&
+		 mcp251xfd_get_ring_tail(rx) == n ?
+		 (priv->rx->head == priv->rx->tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_rx_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_rx_obj->flags);
+	pr_info("%16s = 0x%08x\n", "ts", hw_rx_obj->ts);
+	mcp251xfd_dump_ram_fifo_obj_data(priv, hw_rx_obj->data, FIELD_GET(MCP251XFD_OBJ_FLAGS_DLC, hw_rx_obj->flags));
+	pr_info("\n");
+}
+
+static void
+mcp251xfd_dump_ram_rx_obj(const struct mcp251xfd_priv *priv,
+			  const struct mcp251xfd_dump_regs *regs,
+			  const struct mcp251xfd_dump_ram *ram,
+			  const struct mcp251xfd_ring *rx)
+{
+	int i;
+
+	pr_info("\nRX Overview:\n");
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)",
+		mcp251xfd_dump_get_rx_head(priv, regs),
+		mcp251xfd_get_ring_head(rx), rx->head);
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)",
+		mcp251xfd_dump_get_rx_tail(priv, regs),
+		mcp251xfd_get_ring_tail(rx), rx->tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp251xfd_dump_get_rx_obj_num(priv, regs); i++) {
+		const struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj;
+		u16 hw_rx_obj_rel_addr;
+
+		hw_rx_obj_rel_addr = mcp251xfd_dump_get_rx_obj_rel_addr(priv, regs, i);
+		hw_rx_obj = (const struct mcp251xfd_hw_rx_obj_canfd *)&ram->ram[hw_rx_obj_rel_addr];
+
+		mcp251xfd_dump_ram_rx_obj_one(priv, regs, rx, hw_rx_obj, i);
+	}
+}
+
+#undef __dump_mask
+#undef __dump_bit
+
+static void mcp251xfd_dump_ram(const struct mcp251xfd_priv *priv, const struct mcp251xfd_dump_regs *regs, const struct mcp251xfd_dump_ram *ram)
+{
+	netdev_info(priv->ndev, "----------------------- RAM dump ----------------------\n");
+	mcp251xfd_dump_ram_tef_obj(priv, regs, ram, priv->tef);
+	mcp251xfd_dump_ram_tx_obj(priv, regs, ram, priv->tx);
+	mcp251xfd_dump_ram_rx_obj(priv, regs, ram, priv->rx);
+	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
+}
+
+void mcp251xfd_dump(struct mcp251xfd_priv *priv)
+{
+	struct mcp251xfd_dump_regs regs;
+	struct mcp251xfd_dump_ram ram;
+	struct mcp251xfd_dump_regs_mcp251xfd regs_mcp251xfd;
+	int err;
+
+	BUILD_BUG_ON(sizeof(struct mcp251xfd_dump_regs) !=
+		     MCP251XFD_REG_FIFOUA(31) - MCP251XFD_REG_CON + 4);
+
+	err = regmap_bulk_read(priv->map, MCP251XFD_REG_CON,
+			       &regs, sizeof(regs) / sizeof(u32));
+	if (err)
+		return;
+
+	err = regmap_bulk_read(priv->map, MCP251XFD_RAM_START,
+			       &ram, sizeof(ram) / sizeof(u32));
+	if (err)
+		return;
+
+	err = regmap_bulk_read(priv->map, MCP251XFD_REG_OSC,
+			       &regs_mcp251xfd, sizeof(regs_mcp251xfd) / sizeof(u32));
+	if (err)
+		return;
+
+	mcp251xfd_dump_regs(priv, &regs, &regs_mcp251xfd);
+	mcp251xfd_dump_ram(priv, &regs, &ram);
+}
diff --git a/canutils/mcp251xfd/mcp251xfd-dump.h b/canutils/mcp251xfd/mcp251xfd-dump.h
new file mode 100644
index 0000000000..e7560b0712
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd-dump.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp251xfd - Microchip MCP251xFD Family CAN controller driver
+ *
+ * Copyright (c) 2019, 2020, 2021 Pengutronix,
+ *               Marc Kleine-Budde <kernel@pengutronix.de>
+ */
+
+#ifndef _MCP251XFD_DUMP_H
+#define _MCP251XFD_DUMP_H
+
+#define MCP251XFD_DUMP_MAGIC 0x1825434d
+
+enum mcp251xfd_dump_object_type {
+	MCP251XFD_DUMP_OBJECT_TYPE_REG,
+	MCP251XFD_DUMP_OBJECT_TYPE_TEF,
+	MCP251XFD_DUMP_OBJECT_TYPE_RX,
+	MCP251XFD_DUMP_OBJECT_TYPE_TX,
+	MCP251XFD_DUMP_OBJECT_TYPE_END = -1,
+};
+
+enum mcp251xfd_dump_object_ring_key {
+	MCP251XFD_DUMP_OBJECT_RING_KEY_HEAD,
+	MCP251XFD_DUMP_OBJECT_RING_KEY_TAIL,
+	MCP251XFD_DUMP_OBJECT_RING_KEY_BASE,
+	MCP251XFD_DUMP_OBJECT_RING_KEY_NR,
+	MCP251XFD_DUMP_OBJECT_RING_KEY_FIFO_NR,
+	MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_NUM,
+	MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_SIZE,
+	__MCP251XFD_DUMP_OBJECT_RING_KEY_MAX,
+};
+
+struct mcp251xfd_dump_object_header {
+	__le32 magic;
+	__le32 type;
+	__le32 offset;
+	__le32 len;
+};
+
+struct mcp251xfd_dump_object_reg {
+	__le32 reg;
+	__le32 val;
+};
+
+#endif
diff --git a/canutils/mcp251xfd/mcp251xfd-main.c b/canutils/mcp251xfd/mcp251xfd-main.c
new file mode 100644
index 0000000000..4acd548cbc
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd-main.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Microchip MCP251xFD Family CAN controller debug tool
+//
+// Copyright (c) 2020, 2021 Pengutronix,
+//               Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include <errno.h>
+#include <getopt.h>
+#include <libgen.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <linux/kernel.h>
+
+#include "mcp251xfd-dump-userspace.h"
+
+static void print_usage(char *prg)
+{
+	fprintf(stderr,
+		"%s - decode chip and driver state of mcp251xfd.\n"
+		"\n"
+		"Usage: %s [options] <file>\n"
+		"\n"
+		"        <file>      path to dev coredump file\n"
+		"                        ('/var/log/devcoredump-19700101-234200.dump')\n"
+		"                    path to regmap register file\n"
+                "                        ('/sys/kernel/debug/regmap/spi1.0-crc/registers')\n"
+		"                    shortcut to regmap register file\n"
+		"                        ('spi0.0')\n"
+		"\n"
+		"Options:\n"
+		"        -h, --help  this help\n"
+		"\n",
+		prg, prg);
+}
+
+int regmap_bulk_read(struct regmap *map, unsigned int reg,
+		     void *val, size_t val_count)
+{
+	memcpy(val, map->mem->buf + reg,
+	       val_count * sizeof(uint32_t));
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	struct mcp251xfd_mem mem = { };
+	struct regmap map = {
+		.mem = &mem,
+	};
+	struct mcp251xfd_priv priv = {
+		.map = &map,
+	};
+	const char *file_path;
+	int opt, err;
+
+	struct option long_options[] = {
+		{ "help", no_argument, 0, 'h' },
+		{ 0, 0, 0, 0 },
+	};
+
+	while ((opt = getopt_long(argc, argv, "ei:pq::rvh", long_options, NULL)) != -1) {
+		switch (opt) {
+		case 'h':
+			print_usage(basename(argv[0]));
+			exit(EXIT_SUCCESS);
+			break;
+
+		default:
+			print_usage(basename(argv[0]));
+			exit(EXIT_FAILURE);
+			break;
+		}
+	}
+
+	file_path = argv[optind];
+
+	if (!file_path) {
+		print_usage(basename(argv[0]));
+		exit(EXIT_FAILURE);
+	}
+
+	err = mcp251xfd_dev_coredump_read(&priv, &mem, file_path);
+	if (err)
+		err = mcp251xfd_regmap_read(&priv, &mem, file_path);
+	if (err) {
+		fprintf(stderr, "Unable to read file: '%s'\n", file_path);
+		exit(EXIT_FAILURE);
+	}
+
+	mcp251xfd_dump(&priv);
+
+	exit(EXIT_SUCCESS);
+}
diff --git a/canutils/mcp251xfd/mcp251xfd-regmap.c b/canutils/mcp251xfd/mcp251xfd-regmap.c
new file mode 100644
index 0000000000..61105f0811
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd-regmap.c
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Microchip MCP251xFD Family CAN controller debug tool
+//
+// Copyright (c) 2020 Pengutronix,
+//               Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+#include <linux/kernel.h>
+
+#include "mcp251xfd.h"
+#include "mcp251xfd-dump-userspace.h"
+
+static int
+do_mcp251xfd_regmap_read(struct mcp251xfd_priv *priv,
+			 struct mcp251xfd_mem *mem,
+			 const char *file_path)
+{
+	FILE *reg_file;
+	uint16_t reg;
+	uint32_t val;
+
+	reg_file = fopen(file_path, "r");
+	if (!reg_file)
+		return -errno;
+
+	while (fscanf(reg_file, "%hx: %x\n", &reg, &val) == 2) {
+		if (reg >= ARRAY_SIZE(mem->buf))
+			return -EINVAL;
+
+		*(uint32_t *)(mem->buf + reg) = val;
+	}
+
+	fclose(reg_file);
+
+	return 0;
+}
+
+int mcp251xfd_regmap_read(struct mcp251xfd_priv *priv,
+			  struct mcp251xfd_mem *mem,
+			  const char *file_path)
+{
+	char *tmp;
+	int err;
+
+	err = do_mcp251xfd_regmap_read(priv, mem, file_path);
+	if (!err)
+		return 0;
+
+	/* maybe it's something like "spi0.0" */
+	tmp = strchr(file_path, '/');
+	if (tmp)
+		return -ENOENT;
+
+	/* first try literally */
+	err = asprintf(&tmp, "/sys/kernel/debug/regmap/%s/registers", file_path);
+	if (err == -1)
+		return -errno;
+
+	err = do_mcp251xfd_regmap_read(priv, mem, tmp);
+	free (tmp);
+	if (!err)
+		return 0;
+
+	/* then add "-crc" */
+	err = asprintf(&tmp, "/sys/kernel/debug/regmap/%s-crc/registers", file_path);
+	if (err == -1)
+		return -errno;
+
+	err = do_mcp251xfd_regmap_read(priv, mem, tmp);
+	free (tmp);
+
+	return err;
+}
diff --git a/canutils/mcp251xfd/mcp251xfd.h b/canutils/mcp251xfd/mcp251xfd.h
new file mode 100644
index 0000000000..42b9621f95
--- /dev/null
+++ b/canutils/mcp251xfd/mcp251xfd.h
@@ -0,0 +1,389 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp251xfd - Microchip MCP251xFD Family CAN controller driver
+ *
+ * Copyright (c) 2019, 2020 Pengutronix,
+ *               Marc Kleine-Budde <kernel@pengutronix.de>
+ * Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef _MCP251XFD_H
+#define _MCP251XFD_H
+
+/* MPC251x registers */
+
+/* CAN FD Controller Module SFR */
+#define MCP251XFD_REG_CON 0x00
+#define MCP251XFD_REG_CON_TXBWS_MASK GENMASK(31, 28)
+#define MCP251XFD_REG_CON_ABAT BIT(27)
+#define MCP251XFD_REG_CON_REQOP_MASK GENMASK(26, 24)
+#define MCP251XFD_REG_CON_MODE_MIXED 0
+#define MCP251XFD_REG_CON_MODE_SLEEP 1
+#define MCP251XFD_REG_CON_MODE_INT_LOOPBACK 2
+#define MCP251XFD_REG_CON_MODE_LISTENONLY 3
+#define MCP251XFD_REG_CON_MODE_CONFIG 4
+#define MCP251XFD_REG_CON_MODE_EXT_LOOPBACK 5
+#define MCP251XFD_REG_CON_MODE_CAN2_0 6
+#define MCP251XFD_REG_CON_MODE_RESTRICTED 7
+#define MCP251XFD_REG_CON_OPMOD_MASK GENMASK(23, 21)
+#define MCP251XFD_REG_CON_TXQEN BIT(20)
+#define MCP251XFD_REG_CON_STEF BIT(19)
+#define MCP251XFD_REG_CON_SERR2LOM BIT(18)
+#define MCP251XFD_REG_CON_ESIGM BIT(17)
+#define MCP251XFD_REG_CON_RTXAT BIT(16)
+#define MCP251XFD_REG_CON_BRSDIS BIT(12)
+#define MCP251XFD_REG_CON_BUSY BIT(11)
+#define MCP251XFD_REG_CON_WFT_MASK GENMASK(10, 9)
+#define MCP251XFD_REG_CON_WFT_T00FILTER 0x0
+#define MCP251XFD_REG_CON_WFT_T01FILTER 0x1
+#define MCP251XFD_REG_CON_WFT_T10FILTER 0x2
+#define MCP251XFD_REG_CON_WFT_T11FILTER 0x3
+#define MCP251XFD_REG_CON_WAKFIL BIT(8)
+#define MCP251XFD_REG_CON_PXEDIS BIT(6)
+#define MCP251XFD_REG_CON_ISOCRCEN BIT(5)
+#define MCP251XFD_REG_CON_DNCNT_MASK GENMASK(4, 0)
+
+#define MCP251XFD_REG_NBTCFG 0x04
+#define MCP251XFD_REG_NBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP251XFD_REG_NBTCFG_TSEG1_MASK GENMASK(23, 16)
+#define MCP251XFD_REG_NBTCFG_TSEG2_MASK GENMASK(14, 8)
+#define MCP251XFD_REG_NBTCFG_SJW_MASK GENMASK(6, 0)
+
+#define MCP251XFD_REG_DBTCFG 0x08
+#define MCP251XFD_REG_DBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP251XFD_REG_DBTCFG_TSEG1_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_DBTCFG_TSEG2_MASK GENMASK(11, 8)
+#define MCP251XFD_REG_DBTCFG_SJW_MASK GENMASK(3, 0)
+
+#define MCP251XFD_REG_TDC 0x0c
+#define MCP251XFD_REG_TDC_EDGFLTEN BIT(25)
+#define MCP251XFD_REG_TDC_SID11EN BIT(24)
+#define MCP251XFD_REG_TDC_TDCMOD_MASK GENMASK(17, 16)
+#define MCP251XFD_REG_TDC_TDCMOD_AUTO 2
+#define MCP251XFD_REG_TDC_TDCMOD_MANUAL 1
+#define MCP251XFD_REG_TDC_TDCMOD_DISABLED 0
+#define MCP251XFD_REG_TDC_TDCO_MASK GENMASK(14, 8)
+#define MCP251XFD_REG_TDC_TDCV_MASK GENMASK(5, 0)
+
+#define MCP251XFD_REG_TBC 0x10
+
+#define MCP251XFD_REG_TSCON 0x14
+#define MCP251XFD_REG_TSCON_TSRES BIT(18)
+#define MCP251XFD_REG_TSCON_TSEOF BIT(17)
+#define MCP251XFD_REG_TSCON_TBCEN BIT(16)
+#define MCP251XFD_REG_TSCON_TBCPRE_MASK GENMASK(9, 0)
+
+#define MCP251XFD_REG_VEC 0x18
+#define MCP251XFD_REG_VEC_RXCODE_MASK GENMASK(30, 24)
+#define MCP251XFD_REG_VEC_TXCODE_MASK GENMASK(22, 16)
+#define MCP251XFD_REG_VEC_FILHIT_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_VEC_ICODE_MASK GENMASK(6, 0)
+
+#define MCP251XFD_REG_INT 0x1c
+#define MCP251XFD_REG_INT_IF_MASK GENMASK(15, 0)
+#define MCP251XFD_REG_INT_IE_MASK GENMASK(31, 16)
+#define MCP251XFD_REG_INT_IVMIE BIT(31)
+#define MCP251XFD_REG_INT_WAKIE BIT(30)
+#define MCP251XFD_REG_INT_CERRIE BIT(29)
+#define MCP251XFD_REG_INT_SERRIE BIT(28)
+#define MCP251XFD_REG_INT_RXOVIE BIT(27)
+#define MCP251XFD_REG_INT_TXATIE BIT(26)
+#define MCP251XFD_REG_INT_SPICRCIE BIT(25)
+#define MCP251XFD_REG_INT_ECCIE BIT(24)
+#define MCP251XFD_REG_INT_TEFIE BIT(20)
+#define MCP251XFD_REG_INT_MODIE BIT(19)
+#define MCP251XFD_REG_INT_TBCIE BIT(18)
+#define MCP251XFD_REG_INT_RXIE BIT(17)
+#define MCP251XFD_REG_INT_TXIE BIT(16)
+#define MCP251XFD_REG_INT_IVMIF BIT(15)
+#define MCP251XFD_REG_INT_WAKIF BIT(14)
+#define MCP251XFD_REG_INT_CERRIF BIT(13)
+#define MCP251XFD_REG_INT_SERRIF BIT(12)
+#define MCP251XFD_REG_INT_RXOVIF BIT(11)
+#define MCP251XFD_REG_INT_TXATIF BIT(10)
+#define MCP251XFD_REG_INT_SPICRCIF BIT(9)
+#define MCP251XFD_REG_INT_ECCIF BIT(8)
+#define MCP251XFD_REG_INT_TEFIF BIT(4)
+#define MCP251XFD_REG_INT_MODIF BIT(3)
+#define MCP251XFD_REG_INT_TBCIF BIT(2)
+#define MCP251XFD_REG_INT_RXIF BIT(1)
+#define MCP251XFD_REG_INT_TXIF BIT(0)
+/* These IRQ flags must be cleared by SW in the CAN_INT register */
+#define MCP251XFD_REG_INT_IF_CLEARABLE_MASK \
+	(MCP251XFD_REG_INT_IVMIF | MCP251XFD_REG_INT_WAKIF | \
+	 MCP251XFD_REG_INT_CERRIF |  MCP251XFD_REG_INT_SERRIF | \
+	 MCP251XFD_REG_INT_MODIF)
+
+#define MCP251XFD_REG_RXIF 0x20
+#define MCP251XFD_REG_TXIF 0x24
+#define MCP251XFD_REG_RXOVIF 0x28
+#define MCP251XFD_REG_TXATIF 0x2c
+#define MCP251XFD_REG_TXREQ 0x30
+
+#define MCP251XFD_REG_TREC 0x34
+#define MCP251XFD_REG_TREC_TXBO BIT(21)
+#define MCP251XFD_REG_TREC_TXBP BIT(20)
+#define MCP251XFD_REG_TREC_RXBP BIT(19)
+#define MCP251XFD_REG_TREC_TXWARN BIT(18)
+#define MCP251XFD_REG_TREC_RXWARN BIT(17)
+#define MCP251XFD_REG_TREC_EWARN BIT(16)
+#define MCP251XFD_REG_TREC_TEC_MASK GENMASK(15, 8)
+#define MCP251XFD_REG_TREC_REC_MASK GENMASK(7, 0)
+
+#define MCP251XFD_REG_BDIAG0 0x38
+#define MCP251XFD_REG_BDIAG0_DTERRCNT_MASK GENMASK(31, 24)
+#define MCP251XFD_REG_BDIAG0_DRERRCNT_MASK GENMASK(23, 16)
+#define MCP251XFD_REG_BDIAG0_NTERRCNT_MASK GENMASK(15, 8)
+#define MCP251XFD_REG_BDIAG0_NRERRCNT_MASK GENMASK(7, 0)
+
+#define MCP251XFD_REG_BDIAG1 0x3c
+#define MCP251XFD_REG_BDIAG1_DLCMM BIT(31)
+#define MCP251XFD_REG_BDIAG1_ESI BIT(30)
+#define MCP251XFD_REG_BDIAG1_DCRCERR BIT(29)
+#define MCP251XFD_REG_BDIAG1_DSTUFERR BIT(28)
+#define MCP251XFD_REG_BDIAG1_DFORMERR BIT(27)
+#define MCP251XFD_REG_BDIAG1_DBIT1ERR BIT(25)
+#define MCP251XFD_REG_BDIAG1_DBIT0ERR BIT(24)
+#define MCP251XFD_REG_BDIAG1_TXBOERR BIT(23)
+#define MCP251XFD_REG_BDIAG1_NCRCERR BIT(21)
+#define MCP251XFD_REG_BDIAG1_NSTUFERR BIT(20)
+#define MCP251XFD_REG_BDIAG1_NFORMERR BIT(19)
+#define MCP251XFD_REG_BDIAG1_NACKERR BIT(18)
+#define MCP251XFD_REG_BDIAG1_NBIT1ERR BIT(17)
+#define MCP251XFD_REG_BDIAG1_NBIT0ERR BIT(16)
+#define MCP251XFD_REG_BDIAG1_BERR_MASK \
+	(MCP251XFD_REG_BDIAG1_DLCMM | MCP251XFD_REG_BDIAG1_ESI | \
+	 MCP251XFD_REG_BDIAG1_DCRCERR | MCP251XFD_REG_BDIAG1_DSTUFERR | \
+	 MCP251XFD_REG_BDIAG1_DFORMERR | MCP251XFD_REG_BDIAG1_DBIT1ERR | \
+	 MCP251XFD_REG_BDIAG1_DBIT0ERR | MCP251XFD_REG_BDIAG1_TXBOERR | \
+	 MCP251XFD_REG_BDIAG1_NCRCERR | MCP251XFD_REG_BDIAG1_NSTUFERR | \
+	 MCP251XFD_REG_BDIAG1_NFORMERR | MCP251XFD_REG_BDIAG1_NACKERR | \
+	 MCP251XFD_REG_BDIAG1_NBIT1ERR | MCP251XFD_REG_BDIAG1_NBIT0ERR)
+#define MCP251XFD_REG_BDIAG1_EFMSGCNT_MASK GENMASK(15, 0)
+
+#define MCP251XFD_REG_TEFCON 0x40
+#define MCP251XFD_REG_TEFCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_TEFCON_FRESET BIT(10)
+#define MCP251XFD_REG_TEFCON_UINC BIT(8)
+#define MCP251XFD_REG_TEFCON_TEFTSEN BIT(5)
+#define MCP251XFD_REG_TEFCON_TEFOVIE BIT(3)
+#define MCP251XFD_REG_TEFCON_TEFFIE BIT(2)
+#define MCP251XFD_REG_TEFCON_TEFHIE BIT(1)
+#define MCP251XFD_REG_TEFCON_TEFNEIE BIT(0)
+
+#define MCP251XFD_REG_TEFSTA 0x44
+#define MCP251XFD_REG_TEFSTA_TEFOVIF BIT(3)
+#define MCP251XFD_REG_TEFSTA_TEFFIF BIT(2)
+#define MCP251XFD_REG_TEFSTA_TEFHIF BIT(1)
+#define MCP251XFD_REG_TEFSTA_TEFNEIF BIT(0)
+
+#define MCP251XFD_REG_TEFUA 0x48
+
+#define MCP251XFD_REG_TXQCON 0x50
+#define MCP251XFD_REG_TXQCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP251XFD_REG_TXQCON_PLSIZE_8 0
+#define MCP251XFD_REG_TXQCON_PLSIZE_12 1
+#define MCP251XFD_REG_TXQCON_PLSIZE_16 2
+#define MCP251XFD_REG_TXQCON_PLSIZE_20 3
+#define MCP251XFD_REG_TXQCON_PLSIZE_24 4
+#define MCP251XFD_REG_TXQCON_PLSIZE_32 5
+#define MCP251XFD_REG_TXQCON_PLSIZE_48 6
+#define MCP251XFD_REG_TXQCON_PLSIZE_64 7
+#define MCP251XFD_REG_TXQCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_TXQCON_TXAT_UNLIMITED 3
+#define MCP251XFD_REG_TXQCON_TXAT_THREE_SHOT 1
+#define MCP251XFD_REG_TXQCON_TXAT_ONE_SHOT 0
+#define MCP251XFD_REG_TXQCON_TXAT_MASK GENMASK(22, 21)
+#define MCP251XFD_REG_TXQCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_TXQCON_FRESET BIT(10)
+#define MCP251XFD_REG_TXQCON_TXREQ BIT(9)
+#define MCP251XFD_REG_TXQCON_UINC BIT(8)
+#define MCP251XFD_REG_TXQCON_TXEN BIT(7)
+#define MCP251XFD_REG_TXQCON_TXATIE BIT(4)
+#define MCP251XFD_REG_TXQCON_TXQEIE BIT(2)
+#define MCP251XFD_REG_TXQCON_TXQNIE BIT(0)
+
+#define MCP251XFD_REG_TXQSTA 0x54
+#define MCP251XFD_REG_TXQSTA_TXQCI_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_TXQSTA_TXABT BIT(7)
+#define MCP251XFD_REG_TXQSTA_TXLARB BIT(6)
+#define MCP251XFD_REG_TXQSTA_TXERR BIT(5)
+#define MCP251XFD_REG_TXQSTA_TXATIF BIT(4)
+#define MCP251XFD_REG_TXQSTA_TXQEIF BIT(2)
+#define MCP251XFD_REG_TXQSTA_TXQNIF BIT(0)
+
+#define MCP251XFD_REG_TXQUA 0x58
+
+#define MCP251XFD_REG_FIFOCON(x) (0x50 + 0xc * (x))
+#define MCP251XFD_REG_FIFOCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP251XFD_REG_FIFOCON_PLSIZE_8 0
+#define MCP251XFD_REG_FIFOCON_PLSIZE_12 1
+#define MCP251XFD_REG_FIFOCON_PLSIZE_16 2
+#define MCP251XFD_REG_FIFOCON_PLSIZE_20 3
+#define MCP251XFD_REG_FIFOCON_PLSIZE_24 4
+#define MCP251XFD_REG_FIFOCON_PLSIZE_32 5
+#define MCP251XFD_REG_FIFOCON_PLSIZE_48 6
+#define MCP251XFD_REG_FIFOCON_PLSIZE_64 7
+#define MCP251XFD_REG_FIFOCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_FIFOCON_TXAT_MASK GENMASK(22, 21)
+#define MCP251XFD_REG_FIFOCON_TXAT_ONE_SHOT 0
+#define MCP251XFD_REG_FIFOCON_TXAT_THREE_SHOT 1
+#define MCP251XFD_REG_FIFOCON_TXAT_UNLIMITED 3
+#define MCP251XFD_REG_FIFOCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_FIFOCON_FRESET BIT(10)
+#define MCP251XFD_REG_FIFOCON_TXREQ BIT(9)
+#define MCP251XFD_REG_FIFOCON_UINC BIT(8)
+#define MCP251XFD_REG_FIFOCON_TXEN BIT(7)
+#define MCP251XFD_REG_FIFOCON_RTREN BIT(6)
+#define MCP251XFD_REG_FIFOCON_RXTSEN BIT(5)
+#define MCP251XFD_REG_FIFOCON_TXATIE BIT(4)
+#define MCP251XFD_REG_FIFOCON_RXOVIE BIT(3)
+#define MCP251XFD_REG_FIFOCON_TFERFFIE BIT(2)
+#define MCP251XFD_REG_FIFOCON_TFHRFHIE BIT(1)
+#define MCP251XFD_REG_FIFOCON_TFNRFNIE BIT(0)
+
+#define MCP251XFD_REG_FIFOSTA(x) (0x54 + 0xc * (x))
+#define MCP251XFD_REG_FIFOSTA_FIFOCI_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_FIFOSTA_TXABT BIT(7)
+#define MCP251XFD_REG_FIFOSTA_TXLARB BIT(6)
+#define MCP251XFD_REG_FIFOSTA_TXERR BIT(5)
+#define MCP251XFD_REG_FIFOSTA_TXATIF BIT(4)
+#define MCP251XFD_REG_FIFOSTA_RXOVIF BIT(3)
+#define MCP251XFD_REG_FIFOSTA_TFERFFIF BIT(2)
+#define MCP251XFD_REG_FIFOSTA_TFHRFHIF BIT(1)
+#define MCP251XFD_REG_FIFOSTA_TFNRFNIF BIT(0)
+
+#define MCP251XFD_REG_FIFOUA(x) (0x58 + 0xc * (x))
+
+#define MCP251XFD_REG_FLTCON(x) (0x1d0 + 0x4 * (x))
+#define MCP251XFD_REG_FLTCON_FLTEN3 BIT(31)
+#define MCP251XFD_REG_FLTCON_F3BP_MASK GENMASK(28, 24)
+#define MCP251XFD_REG_FLTCON_FLTEN2 BIT(23)
+#define MCP251XFD_REG_FLTCON_F2BP_MASK GENMASK(20, 16)
+#define MCP251XFD_REG_FLTCON_FLTEN1 BIT(15)
+#define MCP251XFD_REG_FLTCON_F1BP_MASK GENMASK(12, 8)
+#define MCP251XFD_REG_FLTCON_FLTEN0 BIT(7)
+#define MCP251XFD_REG_FLTCON_F0BP_MASK GENMASK(4, 0)
+#define MCP251XFD_REG_FLTCON_FLTEN(x) (BIT(7) << 8 * ((x) & 0x3))
+#define MCP251XFD_REG_FLTCON_FLT_MASK(x) (GENMASK(7, 0) << (8 * ((x) & 0x3)))
+#define MCP251XFD_REG_FLTCON_FBP(x, fifo) ((fifo) << 8 * ((x) & 0x3))
+
+#define MCP251XFD_REG_FLTOBJ(x) (0x1f0 + 0x8 * (x))
+#define MCP251XFD_REG_FLTOBJ_EXIDE BIT(30)
+#define MCP251XFD_REG_FLTOBJ_SID11 BIT(29)
+#define MCP251XFD_REG_FLTOBJ_EID_MASK GENMASK(28, 11)
+#define MCP251XFD_REG_FLTOBJ_SID_MASK GENMASK(10, 0)
+
+#define MCP251XFD_REG_FLTMASK(x) (0x1f4 + 0x8 * (x))
+#define MCP251XFD_REG_MASK_MIDE BIT(30)
+#define MCP251XFD_REG_MASK_MSID11 BIT(29)
+#define MCP251XFD_REG_MASK_MEID_MASK GENMASK(28, 11)
+#define MCP251XFD_REG_MASK_MSID_MASK GENMASK(10, 0)
+
+/* RAM */
+#define MCP251XFD_RAM_START 0x400
+#define MCP251XFD_RAM_SIZE SZ_2K
+
+/* Message Object */
+#define MCP251XFD_OBJ_ID_SID11 BIT(29)
+#define MCP251XFD_OBJ_ID_EID_MASK GENMASK(28, 11)
+#define MCP251XFD_OBJ_ID_SID_MASK GENMASK(10, 0)
+#define MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK GENMASK(31, 9)
+#define MCP251XFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK GENMASK(15, 9)
+#define MCP251XFD_OBJ_FLAGS_SEQ_MASK MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK
+#define MCP251XFD_OBJ_FLAGS_ESI BIT(8)
+#define MCP251XFD_OBJ_FLAGS_FDF BIT(7)
+#define MCP251XFD_OBJ_FLAGS_BRS BIT(6)
+#define MCP251XFD_OBJ_FLAGS_RTR BIT(5)
+#define MCP251XFD_OBJ_FLAGS_IDE BIT(4)
+#define MCP251XFD_OBJ_FLAGS_DLC GENMASK(3, 0)
+
+#define MCP251XFD_REG_FRAME_EFF_SID_MASK GENMASK(28, 18)
+#define MCP251XFD_REG_FRAME_EFF_EID_MASK GENMASK(17, 0)
+
+/* MCP2517/18FD SFR */
+#define MCP251XFD_REG_OSC 0xe00
+#define MCP251XFD_REG_OSC_SCLKRDY BIT(12)
+#define MCP251XFD_REG_OSC_OSCRDY BIT(10)
+#define MCP251XFD_REG_OSC_PLLRDY BIT(8)
+#define MCP251XFD_REG_OSC_CLKODIV_10 3
+#define MCP251XFD_REG_OSC_CLKODIV_4 2
+#define MCP251XFD_REG_OSC_CLKODIV_2 1
+#define MCP251XFD_REG_OSC_CLKODIV_1 0
+#define MCP251XFD_REG_OSC_CLKODIV_MASK GENMASK(6, 5)
+#define MCP251XFD_REG_OSC_SCLKDIV BIT(4)
+#define MCP251XFD_REG_OSC_LPMEN BIT(3)	/* MCP2518FD only */
+#define MCP251XFD_REG_OSC_OSCDIS BIT(2)
+#define MCP251XFD_REG_OSC_PLLEN BIT(0)
+
+#define MCP251XFD_REG_IOCON 0xe04
+#define MCP251XFD_REG_IOCON_INTOD BIT(30)
+#define MCP251XFD_REG_IOCON_SOF BIT(29)
+#define MCP251XFD_REG_IOCON_TXCANOD BIT(28)
+#define MCP251XFD_REG_IOCON_PM1 BIT(25)
+#define MCP251XFD_REG_IOCON_PM0 BIT(24)
+#define MCP251XFD_REG_IOCON_GPIO1 BIT(17)
+#define MCP251XFD_REG_IOCON_GPIO0 BIT(16)
+#define MCP251XFD_REG_IOCON_LAT1 BIT(9)
+#define MCP251XFD_REG_IOCON_LAT0 BIT(8)
+#define MCP251XFD_REG_IOCON_XSTBYEN BIT(6)
+#define MCP251XFD_REG_IOCON_TRIS1 BIT(1)
+#define MCP251XFD_REG_IOCON_TRIS0 BIT(0)
+
+#define MCP251XFD_REG_CRC 0xe08
+#define MCP251XFD_REG_CRC_FERRIE BIT(25)
+#define MCP251XFD_REG_CRC_CRCERRIE BIT(24)
+#define MCP251XFD_REG_CRC_FERRIF BIT(17)
+#define MCP251XFD_REG_CRC_CRCERRIF BIT(16)
+#define MCP251XFD_REG_CRC_IF_MASK GENMASK(17, 16)
+#define MCP251XFD_REG_CRC_MASK GENMASK(15, 0)
+
+#define MCP251XFD_REG_ECCCON 0xe0c
+#define MCP251XFD_REG_ECCCON_PARITY_MASK GENMASK(14, 8)
+#define MCP251XFD_REG_ECCCON_DEDIE BIT(2)
+#define MCP251XFD_REG_ECCCON_SECIE BIT(1)
+#define MCP251XFD_REG_ECCCON_ECCEN BIT(0)
+
+#define MCP251XFD_REG_ECCSTAT 0xe10
+#define MCP251XFD_REG_ECCSTAT_ERRADDR_MASK GENMASK(27, 16)
+#define MCP251XFD_REG_ECCSTAT_IF_MASK GENMASK(2, 1)
+#define MCP251XFD_REG_ECCSTAT_DEDIF BIT(2)
+#define MCP251XFD_REG_ECCSTAT_SECIF BIT(1)
+
+#define MCP251XFD_REG_DEVID 0xe14	/* MCP2518FD only */
+#define MCP251XFD_REG_DEVID_ID_MASK GENMASK(7, 4)
+#define MCP251XFD_REG_DEVID_REV_MASK GENMASK(3, 0)
+
+struct mcp251xfd_hw_tef_obj {
+	u32 id;
+	u32 flags;
+	u32 ts;
+};
+
+struct mcp251xfd_hw_tx_obj_can {
+	u32 id;
+	u32 flags;
+	u8 data[sizeof_field(struct can_frame, data)];
+};
+
+struct mcp251xfd_hw_tx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u8 data[sizeof_field(struct canfd_frame, data)];
+};
+
+struct mcp251xfd_hw_rx_obj_can {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[sizeof_field(struct can_frame, data)];
+};
+
+struct mcp251xfd_hw_rx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[sizeof_field(struct canfd_frame, data)];
+};
+
+#endif
diff --git a/canutils/page.theme b/canutils/page.theme
new file mode 100644
index 0000000000..e850a9befc
--- /dev/null
+++ b/canutils/page.theme
@@ -0,0 +1,21 @@
+<!DOCTYPE html>
+<html>
+<head>
+	<title>page: <?theme title?></title>
+	<link rel="stylesheet" type="text/css" href="style.css">
+	<style>
+
+div#toc li {
+	list-style	: none;
+}
+	</style>
+</head>
+<body>
+<div id='toc'>
+<?theme toc?>
+</div>
+<?theme body?>
+</div>
+</body>
+</html>
+
diff --git a/canutils/slcan_attach.c b/canutils/slcan_attach.c
new file mode 100644
index 0000000000..df0dc98ee1
--- /dev/null
+++ b/canutils/slcan_attach.c
@@ -0,0 +1,272 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * slcan_attach.c - userspace tool for serial line CAN interface driver SLCAN
+ *
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <fcntl.h>
+#include <getopt.h>
+#include <linux/sockios.h>
+#include <linux/tty.h>
+#include <net/if.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <termios.h>
+#include <unistd.h>
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - userspace tool for serial line CAN interface driver SLCAN.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options] tty\n\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -o          (send open command 'O\\r')\n");
+	fprintf(stderr, "         -l          (send listen only command 'L\\r', overrides -o)\n");
+	fprintf(stderr, "         -c          (send close command 'C\\r')\n");
+	fprintf(stderr, "         -f          (read status flags with 'F\\r' to reset error states)\n");
+	fprintf(stderr, "         -s <speed>  (set CAN speed 0..8)\n");
+	fprintf(stderr, "         -b <btr>    (set bit time register value)\n");
+	fprintf(stderr, "         -d          (only detach line discipline)\n");
+	fprintf(stderr, "         -w          (attach - wait for keypress - detach)\n");
+	fprintf(stderr, "         -n <name>   (assign created netdevice name)\n");
+	fprintf(stderr, "\n"
+			"    <speed>          Bitrate\n"
+			"          0            10 Kbit/s\n"
+			"          1            20 Kbit/s\n"
+			"          2            50 Kbit/s\n"
+			"          3           100 Kbit/s\n"
+			"          4           125 Kbit/s\n"
+			"          5           250 Kbit/s\n"
+			"          6           500 Kbit/s\n"
+			"          7           800 Kbit/s\n"
+			"          8          1000 Kbit/s\n"
+			"\n");
+	fprintf(stderr, "\nExamples:\n");
+	fprintf(stderr, "slcan_attach -w -o -f -s6 -c /dev/ttyS1\n\n");
+	fprintf(stderr, "slcan_attach /dev/ttyS1\n\n");
+	fprintf(stderr, "slcan_attach -d /dev/ttyS1\n\n");
+	fprintf(stderr, "slcan_attach -w -n can15 /dev/ttyS1\n\n");
+	exit(1);
+}
+
+int main(int argc, char **argv)
+{
+	int fd;
+	int ldisc = N_SLCAN;
+	int detach = 0;
+	int waitkey = 0;
+	int send_open = 0;
+	int send_listen = 0;
+	int send_close = 0;
+	int send_read_status_flags = 0;
+	char *speed = NULL;
+	char *btr = NULL;
+	char buf[20];
+	static struct ifreq ifr;
+	char *tty;
+	char *name = NULL;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "ldwocfs:b:n:?")) != -1) {
+		switch (opt) {
+		case 'd':
+			detach = 1;
+			break;
+
+		case 'w':
+			waitkey = 1;
+			break;
+
+		case 'o':
+			send_open = 1;
+			break;
+
+		case 'l':
+			send_listen = 1;
+			break;
+
+		case 'c':
+			send_close = 1;
+			break;
+
+		case 'f':
+			send_read_status_flags = 1;
+			break;
+
+		case 's':
+			speed = optarg;
+			if (strlen(speed) > 1)
+				print_usage(argv[0]);
+			break;
+
+		case 'b':
+			btr = optarg;
+			if (strlen(btr) > 6)
+				print_usage(argv[0]);
+			break;
+
+		case 'n':
+			name = optarg;
+			if (strlen(name) > sizeof(ifr.ifr_newname) - 1)
+				print_usage(argv[0]);
+			break;
+
+		case '?':
+		default:
+			print_usage(argv[0]);
+			break;
+		}
+	}
+
+	if (argc - optind != 1)
+		print_usage(argv[0]);
+
+	tty = argv[optind];
+
+	if ((fd = open (tty, O_WRONLY | O_NOCTTY)) < 0) {
+		perror(tty);
+		exit(1);
+	}
+
+	if (waitkey || !detach) {
+
+		if (speed) {
+			sprintf(buf, "C\rS%s\r", speed);
+			if (write(fd, buf, strlen(buf)) <= 0) {
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		if (btr) {
+			sprintf(buf, "C\rs%s\r", btr);
+			if (write(fd, buf, strlen(buf)) <= 0) {
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		if (send_read_status_flags) {
+			sprintf(buf, "F\r");
+			if (write(fd, buf, strlen(buf)) <= 0) {
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		if (send_listen) {
+			sprintf(buf, "L\r");
+			if (write(fd, buf, strlen(buf)) <= 0) {
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		} else if (send_open) {
+			sprintf(buf, "O\r");
+			if (write(fd, buf, strlen(buf)) <= 0) {
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		}
+
+		/* set slcan line discipline on given tty */
+		if (ioctl (fd, TIOCSETD, &ldisc) < 0) {
+			perror("ioctl TIOCSETD");
+			exit(1);
+		}
+
+		/* retrieve the name of the created CAN netdevice */
+		if (ioctl (fd, SIOCGIFNAME, ifr.ifr_name) < 0) {
+			perror("ioctl SIOCGIFNAME");
+			exit(1);
+		}
+
+		printf("attached tty %s to netdevice %s\n", tty, ifr.ifr_name);
+
+		/* try to rename the created device if requested */
+		if (name) {
+			int s = socket(PF_INET, SOCK_DGRAM, 0);
+
+			printf("rename netdevice %s to %s ... ", buf, name);
+
+			if (s < 0)
+				perror("socket for interface rename");
+			else {
+				/* current slcan%d name is still in ifr.ifr_name */
+				memset (ifr.ifr_newname, 0, sizeof(ifr.ifr_newname));
+				strncpy (ifr.ifr_newname, name, sizeof(ifr.ifr_newname) - 1);
+
+				if (ioctl(s, SIOCSIFNAME, &ifr) < 0)
+					printf("failed!\n");
+				else
+					printf("ok.\n");
+
+				close(s);
+			}
+		}
+	}
+
+	if (waitkey) {
+		printf("Press any key to detach %s ...\n", tty);
+		getchar();
+	}
+
+	if (waitkey || detach) {
+		ldisc = N_TTY;
+		if (ioctl (fd, TIOCSETD, &ldisc) < 0) {
+			perror("ioctl");
+			exit(1);
+		}
+
+		if (send_close) {
+			sprintf(buf, "C\r");
+			if (write(fd, buf, strlen(buf)) <= 0) {
+				perror("write");
+				exit(EXIT_FAILURE);
+			}
+		}
+	}
+
+	close(fd);
+
+	return 0;
+}
diff --git a/canutils/slcand.c b/canutils/slcand.c
new file mode 100644
index 0000000000..4a15697b04
--- /dev/null
+++ b/canutils/slcand.c
@@ -0,0 +1,452 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * slcand.c - userspace daemon for serial line CAN interface driver SLCAN
+ *
+ * Copyright (c) 2009 Robert Haddon <robert.haddon@verari.com>
+ * Copyright (c) 2009 Verari Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/serial.h>
+#include <linux/sockios.h>
+#include <linux/tty.h>
+#include <net/if.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <syslog.h>
+#include <termios.h>
+#include <unistd.h>
+
+/* Change this to whatever your daemon is called */
+#define DAEMON_NAME "slcand"
+
+/* Change this to the user under which to run */
+#define RUN_AS_USER "root"
+
+/* The length of ttypath buffer */
+#define TTYPATH_LENGTH	256
+
+/* UART flow control types */
+#define FLOW_NONE 0
+#define FLOW_HW 1
+#define FLOW_SW 2
+
+static void fake_syslog(int priority, const char *format, ...)
+{
+	va_list ap;
+
+	printf("[%d] ", priority);
+	va_start(ap, format);
+	vprintf(format, ap);
+	va_end(ap);
+	printf("\n");
+}
+
+typedef void (*syslog_t)(int priority, const char *format, ...);
+static syslog_t syslogger = syslog;
+
+void print_usage(char *prg)
+{
+	fprintf(stderr, "%s - userspace daemon for serial line CAN interface driver SLCAN.\n", prg);
+	fprintf(stderr, "\nUsage: %s [options] <tty> [canif-name]\n\n", prg);
+	fprintf(stderr, "Options:\n");
+	fprintf(stderr, "         -o          (send open command 'O\\r')\n");
+	fprintf(stderr, "         -c          (send close command 'C\\r')\n");
+	fprintf(stderr, "         -f          (read status flags with 'F\\r' to reset error states)\n");
+	fprintf(stderr, "         -l          (send listen only command 'L\\r', overrides -o)\n");
+	fprintf(stderr, "         -s <speed>  (set CAN speed 0..8)\n");
+	fprintf(stderr, "         -S <speed>  (set UART speed in baud)\n");
+	fprintf(stderr, "         -t <type>   (set UART flow control type 'hw' or 'sw')\n");
+	fprintf(stderr, "         -b <btr>    (set bit time register value)\n");
+	fprintf(stderr, "         -F          (stay in foreground; no daemonize)\n");
+	fprintf(stderr, "         -h          (show this help page)\n");
+	fprintf(stderr, "\nExamples:\n");
+	fprintf(stderr, "slcand -o -c -f -s6 ttyUSB0\n\n");
+	fprintf(stderr, "slcand -o -c -f -s6 ttyUSB0 can0\n\n");
+	fprintf(stderr, "slcand -o -c -f -s6 /dev/ttyUSB0\n\n");
+	exit(EXIT_FAILURE);
+}
+
+static int slcand_running;
+static int exit_code;
+static char ttypath[TTYPATH_LENGTH];
+
+static void child_handler(int signum)
+{
+	switch (signum) {
+
+	case SIGUSR1:
+		/* exit parent */
+		exit(EXIT_SUCCESS);
+		break;
+	case SIGALRM:
+	case SIGCHLD:
+		syslogger(LOG_NOTICE, "received signal %i on %s", signum, ttypath);
+		exit_code = EXIT_FAILURE;
+		slcand_running = 0;
+		break;
+	case SIGINT:
+	case SIGTERM:
+		syslogger(LOG_NOTICE, "received signal %i on %s", signum, ttypath);
+		exit_code = EXIT_SUCCESS;
+		slcand_running = 0;
+		break;
+	}
+}
+
+static int look_up_uart_speed(long int s)
+{
+	switch (s) {
+
+	case 9600:
+		return B9600;
+	case 19200:
+		return B19200;
+	case 38400:
+		return B38400;
+	case 57600:
+		return B57600;
+	case 115200:
+		return B115200;
+	case 230400:
+		return B230400;
+	case 460800:
+		return B460800;
+	case 500000:
+		return B500000;
+	case 576000:
+		return B576000;
+	case 921600:
+		return B921600;
+	case 1000000:
+		return B1000000;
+	case 1152000:
+		return B1152000;
+	case 1500000:
+		return B1500000;
+	case 2000000:
+		return B2000000;
+#ifdef B2500000
+	case 2500000:
+		return B2500000;
+#endif
+#ifdef B3000000
+	case 3000000:
+		return B3000000;
+#endif
+#ifdef B3500000
+	case 3500000:
+		return B3500000;
+#endif
+#ifdef B3710000
+	case 3710000
+		return B3710000;
+#endif
+#ifdef B4000000
+	case 4000000:
+		return B4000000;
+#endif
+	default:
+		return -1;
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	char *tty = NULL;
+	char const *devprefix = "/dev/";
+	char *name = NULL;
+	char buf[20];
+	static struct ifreq ifr;
+	struct termios tios;
+	speed_t old_ispeed;
+	speed_t old_ospeed;
+
+	int opt;
+	int send_open = 0;
+	int send_close = 0;
+	int send_listen = 0;
+	int send_read_status_flags = 0;
+	char *speed = NULL;
+	char *uart_speed_str = NULL;
+	long int uart_speed = 0;
+	int flow_type = FLOW_NONE;
+	char *btr = NULL;
+	int run_as_daemon = 1;
+	char *pch;
+	int ldisc = N_SLCAN;
+	int fd;
+
+	ttypath[0] = '\0';
+
+	while ((opt = getopt(argc, argv, "ocfls:S:t:b:?hF")) != -1) {
+		switch (opt) {
+		case 'o':
+			send_open = 1;
+			break;
+		case 'c':
+			send_close = 1;
+			break;
+		case 'f':
+			send_read_status_flags = 1;
+			break;
+		case 'l':
+			send_listen = 1;
+			break;
+		case 's':
+			speed = optarg;
+			if (strlen(speed) > 1)
+				print_usage(argv[0]);
+			break;
+		case 'S':
+			uart_speed_str = optarg;
+			errno = 0;
+			uart_speed = strtol(uart_speed_str, NULL, 10);
+			if (errno)
+				print_usage(argv[0]);
+			if (look_up_uart_speed(uart_speed) == -1) {
+				fprintf(stderr, "Unsupported UART speed (%lu)\n", uart_speed);
+				exit(EXIT_FAILURE);
+			}
+			break;
+		case 't':
+			if (!strcmp(optarg, "hw")) {
+				flow_type = FLOW_HW;
+			} else if (!strcmp(optarg, "sw")) {
+				flow_type = FLOW_SW;
+			} else {
+				fprintf(stderr, "Unsupported flow type (%s)\n", optarg);
+				exit(EXIT_FAILURE);
+			}
+			break;
+		case 'b':
+			btr = optarg;
+			if (strlen(btr) > 6)
+				print_usage(argv[0]);
+			break;
+		case 'F':
+			run_as_daemon = 0;
+			break;
+		case 'h':
+		case '?':
+		default:
+			print_usage(argv[0]);
+			break;
+		}
+	}
+
+	if (!run_as_daemon)
+		syslogger = fake_syslog;
+
+	/* Initialize the logging interface */
+	openlog(DAEMON_NAME, LOG_PID, LOG_LOCAL5);
+
+	/* Parse serial device name and optional can interface name */
+	tty = argv[optind];
+	if (NULL == tty)
+		print_usage(argv[0]);
+
+	name = argv[optind + 1];
+	if (name && (strlen(name) > sizeof(ifr.ifr_newname) - 1))
+		print_usage(argv[0]);
+
+	/* Prepare the tty device name string */
+	pch = strstr(tty, devprefix);
+	if (pch != tty)
+		snprintf(ttypath, TTYPATH_LENGTH, "%s%s", devprefix, tty);
+	else
+		snprintf(ttypath, TTYPATH_LENGTH, "%s", tty);
+
+	syslogger(LOG_INFO, "starting on TTY device %s", ttypath);
+
+	fd = open(ttypath, O_RDWR | O_NONBLOCK | O_NOCTTY);
+	if (fd < 0) {
+		syslogger(LOG_NOTICE, "failed to open TTY device %s\n", ttypath);
+		perror(ttypath);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Configure baud rate */
+	memset(&tios, 0, sizeof(tios));
+	if (tcgetattr(fd, &tios) < 0) {
+		syslogger(LOG_NOTICE, "failed to get attributes for TTY device %s: %s\n", ttypath, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	// Because of a recent change in linux - https://patchwork.kernel.org/patch/9589541/
+	// we need to set low latency flag to get proper receive latency
+	struct serial_struct snew;
+	ioctl (fd, TIOCGSERIAL, &snew);
+	snew.flags |= ASYNC_LOW_LATENCY;
+	ioctl (fd, TIOCSSERIAL, &snew);
+
+	/* Get old values for later restore */
+	old_ispeed = cfgetispeed(&tios);
+	old_ospeed = cfgetospeed(&tios);
+
+	/* Reset UART settings */
+	cfmakeraw(&tios);
+	tios.c_iflag &= ~IXOFF;
+	tios.c_cflag &= ~CRTSCTS;
+
+	/* Baud Rate */
+	cfsetispeed(&tios, look_up_uart_speed(uart_speed));
+	cfsetospeed(&tios, look_up_uart_speed(uart_speed));
+
+	/* Flow control */
+	if (flow_type == FLOW_HW)
+		tios.c_cflag |= CRTSCTS;
+	else if (flow_type == FLOW_SW)
+		tios.c_iflag |= (IXON | IXOFF);
+
+	/* apply changes */
+	if (tcsetattr(fd, TCSADRAIN, &tios) < 0)
+		syslogger(LOG_NOTICE, "Cannot set attributes for device \"%s\": %s!\n", ttypath, strerror(errno));
+
+	if (speed) {
+		sprintf(buf, "C\rS%s\r", speed);
+		if (write(fd, buf, strlen(buf)) <= 0) {
+			perror("write");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (btr) {
+		sprintf(buf, "C\rs%s\r", btr);
+		if (write(fd, buf, strlen(buf)) <= 0) {
+			perror("write");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (send_read_status_flags) {
+		sprintf(buf, "F\r");
+		if (write(fd, buf, strlen(buf)) <= 0) {
+			perror("write");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (send_listen) {
+		sprintf(buf, "L\r");
+		if (write(fd, buf, strlen(buf)) <= 0) {
+			perror("write");
+			exit(EXIT_FAILURE);
+		}
+	} else if (send_open) {
+		sprintf(buf, "O\r");
+		if (write(fd, buf, strlen(buf)) <= 0) {
+			perror("write");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* set slcan like discipline on given tty */
+	if (ioctl(fd, TIOCSETD, &ldisc) < 0) {
+		perror("ioctl TIOCSETD");
+		exit(EXIT_FAILURE);
+	}
+	
+	/* retrieve the name of the created CAN netdevice */
+	if (ioctl(fd, SIOCGIFNAME, ifr.ifr_name) < 0) {
+		perror("ioctl SIOCGIFNAME");
+		exit(EXIT_FAILURE);
+	}
+
+	syslogger(LOG_NOTICE, "attached TTY %s to netdevice %s\n", ttypath, ifr.ifr_name);
+	
+	/* try to rename the created netdevice */
+	if (name) {
+		int s = socket(PF_INET, SOCK_DGRAM, 0);
+
+		if (s < 0)
+			perror("socket for interface rename");
+		else {
+			/* current slcan%d name is still in ifr.ifr_name */
+			memset (ifr.ifr_newname, 0, sizeof(ifr.ifr_newname));
+			strncpy (ifr.ifr_newname, name, sizeof(ifr.ifr_newname) - 1);
+
+			if (ioctl(s, SIOCSIFNAME, &ifr) < 0) {
+				syslogger(LOG_NOTICE, "netdevice %s rename to %s failed\n", buf, name);
+				perror("ioctl SIOCSIFNAME rename");
+				exit(EXIT_FAILURE);
+			} else
+				syslogger(LOG_NOTICE, "netdevice %s renamed to %s\n", buf, name);
+
+			close(s);
+		}	
+	}
+
+	/* Daemonize */
+	if (run_as_daemon) {
+		if (daemon(0, 0)) {
+			syslogger(LOG_ERR, "failed to daemonize");
+			exit(EXIT_FAILURE);
+		}
+	}
+	else {
+		/* Trap signals that we expect to receive */
+		signal(SIGINT, child_handler);
+		signal(SIGTERM, child_handler);
+	}
+
+	slcand_running = 1;
+
+	/* The Big Loop */
+	while (slcand_running)
+		sleep(1); /* wait 1 second */
+
+	/* Reset line discipline */
+	syslogger(LOG_INFO, "stopping on TTY device %s", ttypath);
+	ldisc = N_TTY;
+	if (ioctl(fd, TIOCSETD, &ldisc) < 0) {
+		perror("ioctl TIOCSETD");
+		exit(EXIT_FAILURE);
+	}
+
+	if (send_close) {
+		sprintf(buf, "C\r");
+		if (write(fd, buf, strlen(buf)) <= 0) {
+			perror("write");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	/* Reset old rates */
+	cfsetispeed(&tios, old_ispeed);
+	cfsetospeed(&tios, old_ospeed);
+
+	/* apply changes */
+	if (tcsetattr(fd, TCSADRAIN, &tios) < 0)
+		syslogger(LOG_NOTICE, "Cannot set attributes for device \"%s\": %s!\n", ttypath, strerror(errno));
+
+	/* Finish up */
+	syslogger(LOG_NOTICE, "terminated on %s", ttypath);
+	closelog();
+	return exit_code;
+}
diff --git a/canutils/slcanpty.c b/canutils/slcanpty.c
new file mode 100644
index 0000000000..e6f1efe119
--- /dev/null
+++ b/canutils/slcanpty.c
@@ -0,0 +1,558 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * slcanpty: adapter for applications using the slcan ASCII protocol
+ *
+ * slcanpty.c - creates a pty for applications using the slcan ASCII protocol
+ * and converts the ASCII data to a CAN network interface (and vice versa)
+ *
+ * Copyright (c)2009 Oliver Hartkopp
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#include <fcntl.h>
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <linux/can.h>
+#include <linux/can/raw.h>
+#include <linux/sockios.h>
+
+/* maximum rx buffer len: extended CAN frame with timestamp */
+#define SLC_MTU (sizeof("T1111222281122334455667788EA5F\r")+1)
+#define DEVICE_NAME_PTMX "/dev/ptmx"
+
+#define DEBUG
+
+static int asc2nibble(char c)
+{
+
+	if ((c >= '0') && (c <= '9'))
+		return c - '0';
+
+	if ((c >= 'A') && (c <= 'F'))
+		return c - 'A' + 10;
+
+	if ((c >= 'a') && (c <= 'f'))
+		return c - 'a' + 10;
+
+	return 16; /* error */
+}
+
+/* read data from pty, send CAN frames to CAN socket and answer commands */
+int pty2can(int pty, int socket, struct can_filter *fi,
+	    int *is_open, int *tstamp)
+{
+	int nbytes;
+	char cmd;
+	static char buf[200];
+	char replybuf[10]; /* for answers to received commands */
+	int ptr;
+	struct can_frame frame;
+	int tmp, i;
+	static int rxoffset = 0; /* points to the end of an received incomplete SLCAN message */
+
+	nbytes = read(pty, &buf[rxoffset], sizeof(buf)-rxoffset-1);
+	if (nbytes <= 0) {
+		/* nbytes == 0 : no error but pty descriptor has been closed */
+		if (nbytes < 0)
+			perror("read pty");
+
+		return 1;
+	}
+
+	/* reset incomplete message offset */
+	nbytes += rxoffset;
+	rxoffset = 0;
+
+rx_restart:
+	/* remove trailing '\r' characters to be robust against some apps */
+	while (buf[0] == '\r' && nbytes > 0) {
+		for (tmp = 0; tmp < nbytes; tmp++)
+			buf[tmp] = buf[tmp+1];
+		nbytes--;
+	}
+
+	if (!nbytes)
+		return 0;
+
+	/* check if we can detect a complete SLCAN message including '\r' */
+	for (tmp = 0; tmp < nbytes; tmp++) {
+		if (buf[tmp] == '\r')
+			break;
+	}
+
+	/* no '\r' found in the message buffer? */
+	if (tmp == nbytes) {
+		/* save incomplete message */
+		rxoffset = nbytes;
+
+		/* leave here and read from pty again */
+		return 0;
+	}
+
+	cmd = buf[0];
+	buf[nbytes] = 0;
+
+#ifdef DEBUG
+	for (tmp = 0; tmp < nbytes; tmp++)
+		if (buf[tmp] == '\r')
+			putchar('@');
+		else
+			putchar(buf[tmp]);
+	printf("\n");
+#endif
+
+	/* check for filter configuration commands */
+	if (cmd == 'm' || cmd == 'M') {
+		buf[9] = 0; /* terminate filter string */
+		ptr = 9;
+#if 0
+		/* the filter is no SocketCAN filter :-( */
+
+		/* TODO: behave like a SJA1000 controller specific filter */
+
+		if (cmd == 'm') {
+			fi->can_id = strtoul(buf+1,NULL,16);
+			fi->can_id &= CAN_EFF_MASK;
+		} else {
+			fi->can_mask = strtoul(buf+1,NULL,16);
+			fi->can_mask &= CAN_EFF_MASK;
+		}
+
+		if (*is_open)
+			setsockopt(socket, SOL_CAN_RAW,
+				   CAN_RAW_FILTER, fi,
+				   sizeof(struct can_filter));
+#endif
+		goto rx_out_ack;
+	}
+
+
+	/* check for timestamp on/off command */
+	if (cmd == 'Z') {
+		*tstamp = buf[1] & 0x01;
+		ptr = 2;
+		goto rx_out_ack;
+	}
+
+	/* check for 'O'pen command */
+	if (cmd == 'O') {
+		setsockopt(socket, SOL_CAN_RAW,
+			   CAN_RAW_FILTER, fi,
+			   sizeof(struct can_filter));
+		ptr = 1;
+		*is_open = 1;
+		goto rx_out_ack;
+	}
+
+	/* check for 'C'lose command */
+	if (cmd == 'C') {
+		setsockopt(socket, SOL_CAN_RAW, CAN_RAW_FILTER,
+			   NULL, 0);
+		ptr = 1;
+		*is_open = 0;
+		goto rx_out_ack;
+	}
+
+	/* check for 'V'ersion command */
+	if (cmd == 'V') {
+		sprintf(replybuf, "V1013\r");
+		tmp = strlen(replybuf);
+		ptr = 1;
+		goto rx_out;
+	}
+	/* check for 'v'ersion command */
+	if (cmd == 'v') {
+		sprintf(replybuf, "v1014\r");
+		tmp = strlen(replybuf);
+		ptr = 1;
+		goto rx_out;
+	}
+
+	/* check for serial 'N'umber command */
+	if (cmd == 'N') {
+		sprintf(replybuf, "N4242\r");
+		tmp = strlen(replybuf);
+		ptr = 1;
+		goto rx_out;
+	}
+
+	/* check for read status 'F'lags */
+	if (cmd == 'F') {
+		sprintf(replybuf, "F00\r");
+		tmp = strlen(replybuf);
+		ptr = 1;
+		goto rx_out;
+	}
+
+	/* correctly answer unsupported commands */
+	if (cmd == 'U') {
+		ptr = 2;
+		goto rx_out_ack;
+	}
+	if (cmd == 'S') {
+		ptr = 2;
+		goto rx_out_ack;
+	}
+	if (cmd == 's') {
+		ptr = 5;
+		goto rx_out_ack;
+	}
+	if (cmd == 'P' || cmd == 'A') {
+		ptr = 1;
+		goto rx_out_nack;
+	}
+	if (cmd == 'X') {
+		ptr = 2;
+		if (buf[1] & 0x01)
+			goto rx_out_ack;
+		else
+			goto rx_out_nack;
+	}
+
+	/* catch unknown commands */
+	if ((cmd != 't') && (cmd != 'T') &&
+	    (cmd != 'r') && (cmd != 'R')) {
+		ptr = nbytes-1;
+		goto rx_out_nack;
+	}
+
+	if (cmd & 0x20) /* tiny chars 'r' 't' => SFF */
+		ptr = 4; /* dlc position tiiid */
+	else
+		ptr = 9; /* dlc position Tiiiiiiiid */
+
+	memset(&frame.data, 0, 8); /* clear data[] */
+
+	if ((cmd | 0x20) == 'r' && buf[ptr] != '0') {
+
+		/* 
+		 * RTR frame without dlc information!
+		 * This is against the SLCAN spec but sent
+		 * by a commercial CAN tool ... so we are
+		 * robust against this protocol violation.
+		 */
+
+		frame.can_dlc = buf[ptr]; /* save following byte */
+
+		buf[ptr] = 0; /* terminate can_id string */
+
+		frame.can_id = strtoul(buf+1, NULL, 16);
+		frame.can_id |= CAN_RTR_FLAG;
+
+		if (!(cmd & 0x20)) /* NO tiny chars => EFF */
+			frame.can_id |= CAN_EFF_FLAG;
+
+		buf[ptr]  = frame.can_dlc; /* restore following byte */
+		frame.can_dlc = 0;
+		ptr--; /* we have no dlc component in the violation case */
+
+	} else {
+
+		if (!(buf[ptr] >= '0' && buf[ptr] < '9'))
+			goto rx_out_nack;
+
+		frame.can_dlc = buf[ptr] - '0'; /* get dlc from ASCII val */
+
+		buf[ptr] = 0; /* terminate can_id string */
+
+		frame.can_id = strtoul(buf+1, NULL, 16);
+
+		if (!(cmd & 0x20)) /* NO tiny chars => EFF */
+			frame.can_id |= CAN_EFF_FLAG;
+
+		if ((cmd | 0x20) == 'r') /* RTR frame */
+			frame.can_id |= CAN_RTR_FLAG;
+
+		for (i = 0, ptr++; i < frame.can_dlc; i++) {
+
+			tmp = asc2nibble(buf[ptr++]);
+			if (tmp > 0x0F)
+				goto rx_out_nack;
+			frame.data[i] = (tmp << 4);
+			tmp = asc2nibble(buf[ptr++]);
+			if (tmp > 0x0F)
+				goto rx_out_nack;
+			frame.data[i] |= tmp;
+		}
+		/* point to last real data */
+		if (frame.can_dlc)
+			ptr--;
+	}
+
+	tmp = write(socket, &frame, sizeof(frame));
+	if (tmp != sizeof(frame)) {
+		perror("write socket");
+		return 1;
+	}
+
+rx_out_ack:
+	replybuf[0] = '\r';
+	tmp = 1;
+	goto rx_out;
+rx_out_nack:
+	replybuf[0] = '\a';
+	tmp = 1;
+rx_out:
+	tmp = write(pty, replybuf, tmp);
+	if (tmp < 0) {
+		perror("write pty replybuf");
+		return 1;
+	}
+
+	/* check if there is another command in this buffer */
+	if (nbytes > ptr+1) {
+		for (tmp = 0, ptr++; ptr+tmp < nbytes; tmp++)
+			buf[tmp] = buf[ptr+tmp];
+		nbytes = tmp;
+		goto rx_restart;
+	}
+
+	return 0;
+}
+
+/* read CAN frames from CAN interface and write it to the pty */
+int can2pty(int pty, int socket, int *tstamp)
+{
+	int nbytes;
+	char cmd;
+	char buf[SLC_MTU];
+	int ptr;
+	struct can_frame frame;
+	int i;
+
+	nbytes = read(socket, &frame, sizeof(frame));
+	if (nbytes != sizeof(frame)) {
+		perror("read socket");
+		return 1;
+	}
+
+	/* convert to slcan ASCII frame */
+	if (frame.can_id & CAN_RTR_FLAG)
+		cmd = 'R'; /* becomes 'r' in SFF format */
+	else
+		cmd = 'T'; /* becomes 't' in SFF format */
+
+	if (frame.can_id & CAN_EFF_FLAG)
+		sprintf(buf, "%c%08X%d", cmd,
+			frame.can_id & CAN_EFF_MASK,
+			frame.can_dlc);
+	else
+		sprintf(buf, "%c%03X%d", cmd | 0x20,
+			frame.can_id & CAN_SFF_MASK,
+			frame.can_dlc);
+
+	ptr = strlen(buf);
+
+	for (i = 0; i < frame.can_dlc; i++)
+		sprintf(&buf[ptr + 2*i], "%02X",
+			frame.data[i]);
+
+	if (*tstamp) {
+		struct timeval tv;
+
+		if (ioctl(socket, SIOCGSTAMP, &tv) < 0)
+			perror("SIOCGSTAMP");
+
+		sprintf(&buf[ptr + 2*frame.can_dlc], "%04lX",
+			(tv.tv_sec%60)*1000 + tv.tv_usec/1000);
+	}
+
+	strcat(buf, "\r"); /* add terminating character */
+	nbytes = write(pty, buf, strlen(buf));
+	if (nbytes < 0) {
+		perror("write pty");
+		return 1;
+	}
+	fflush(NULL);
+
+	return 0;
+}
+
+int check_select_stdin(void)
+{
+	fd_set rdfs;
+	struct timeval timeout;
+	int ret;
+
+	FD_ZERO(&rdfs);
+	FD_SET(0, &rdfs);
+	timeout.tv_sec = 0;
+	timeout.tv_usec = 0;
+
+	ret = select(1, &rdfs, NULL, NULL, &timeout);
+
+	if (ret < 0)
+		return 0; /* not selectable */
+
+	if (ret > 0 && getchar() == EOF)
+		return 0; /* EOF, eg. /dev/null */
+
+	return 1;
+}
+
+int main(int argc, char **argv)
+{
+	fd_set rdfs;
+	int p; /* pty master file */ 
+	int s; /* can raw socket */ 
+	struct sockaddr_can addr;
+	struct termios topts;
+	int select_stdin = 0;
+	int running = 1;
+	int tstamp = 0;
+	int is_open = 0;
+	struct can_filter fi;
+
+	/* check command line options */
+	if (argc != 3) {
+		fprintf(stderr, "%s: adapter for applications using"
+			" the slcan ASCII protocol.\n", basename(argv[0]));
+		fprintf(stderr, "\n%s creates a pty for applications using"
+			" the slcan ASCII protocol and\n", basename(argv[0]));
+		fprintf(stderr, "converts the ASCII data to a CAN network"
+			" interface (and vice versa)\n\n");
+		fprintf(stderr, "Usage: %s <pty> <can interface>\n", basename(argv[0]));
+		fprintf(stderr, "\nExamples:\n");
+		fprintf(stderr, "%s /dev/ptyc0 can0  - creates /dev/ttyc0 for the slcan application\n\n",
+			basename(argv[0]));
+		fprintf(stderr, "e.g. for pseudo-terminal '%s %s can0' creates"
+			" /dev/pts/N\n", basename(argv[0]), DEVICE_NAME_PTMX);
+		fprintf(stderr, "\n");
+		return 1;
+	}
+
+	select_stdin = check_select_stdin();
+
+	/* open pty */
+	p = open(argv[1], O_RDWR);
+	if (p < 0) {
+		perror("open pty");
+		return 1;
+	}
+
+	if (tcgetattr(p, &topts)) {
+		perror("tcgetattr");
+		return 1;
+	}
+
+	/* disable local echo which would cause double frames */
+	topts.c_lflag &= ~(ICANON | ECHO | ECHOE | ECHOK |
+			   ECHONL | ECHOPRT | ECHOKE);
+	topts.c_iflag &= ~(ICRNL);
+	topts.c_iflag |= INLCR;
+	tcsetattr(p, TCSANOW, &topts);
+
+	/* Support for the Unix 98 pseudo-terminal interface /dev/ptmx /dev/pts/N */
+	if  (strcmp(argv[1], DEVICE_NAME_PTMX) == 0) {
+
+		char *name_pts = NULL;	/* slave pseudo-terminal device name */
+
+		if (grantpt(p) < 0) {
+			perror("grantpt");
+			return 1;
+		}
+
+		if (unlockpt(p) < 0) {
+			perror("unlockpt");
+			return 1;
+		}
+
+		name_pts = ptsname(p);
+		if (name_pts == NULL) {
+			perror("ptsname");
+			return 1;
+		}
+		printf("open: %s: slave pseudo-terminal is %s\n", argv[1], name_pts);
+	}
+
+	/* open socket */
+	s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
+	if (s < 0) {
+		perror("socket");
+		return 1;
+	}
+
+	addr.can_family = AF_CAN;
+	addr.can_ifindex = if_nametoindex(argv[2]);
+	if (!addr.can_ifindex) {
+		perror("if_nametoindex");
+		return 1;
+	}
+
+	/* disable reception of CAN frames until we are opened by 'O' */
+	setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
+
+	if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		perror("bind");
+		return 1;
+	}
+
+	/* open filter by default */
+	fi.can_id   = 0;
+	fi.can_mask = 0;
+
+	while (running) {
+
+		FD_ZERO(&rdfs);
+
+		if (select_stdin)
+			FD_SET(0, &rdfs);
+
+		FD_SET(p, &rdfs);
+		FD_SET(s, &rdfs);
+
+		if (select(s+1, &rdfs, NULL, NULL, NULL) < 0) {
+			perror("select");
+			return 1;
+		}
+
+		if (FD_ISSET(0, &rdfs)) {
+			running = 0;
+			continue;
+		}
+
+		if (FD_ISSET(p, &rdfs))
+			if (pty2can(p, s, &fi, &is_open, &tstamp)) {
+			running = 0;
+			continue;
+		}
+
+		if (FD_ISSET(s, &rdfs))
+			if (can2pty(p, s, &tstamp)) {
+			running = 0;
+			continue;
+		}
+	}
+
+	close(p);
+	close(s);
+
+	return 0;
+}
diff --git a/canutils/style.css b/canutils/style.css
new file mode 100644
index 0000000000..6be67d23c5
--- /dev/null
+++ b/canutils/style.css
@@ -0,0 +1,68 @@
+* {
+    font-family: Helvetica Neue, Helvetica, Arial, sans-serif;
+}
+body {
+    max-width: 60em;
+    margin: 0 auto;
+    color: #111;
+}
+
+pre, code {
+    font-family: Monaco, Courier New, monospace;
+    font-size: 11px;
+}
+
+h1 {
+    color: rgb(43,105,145);
+    font-weight: bold;
+    font-size: 40px;
+    letter-spacing: -1px;
+    margin-bottom: -5px;
+    margin: 0;
+}
+h1 code {
+    font-size: 32px;
+}
+
+h2 {
+    color: rgb(43,105,145);
+    font-weight: bold;
+    margin-bottom: -5px;
+}
+h2 code {
+    font-size: 22px;
+}
+
+h3 {
+    margin-bottom: -5px;
+}
+h3 code {
+    font-size: 16px;
+}
+
+a {
+    color: blue;
+    text-decoration: none;
+}
+a:visited {
+    color: navy;
+}
+a:hover {
+    text-decoration: underline;
+}
+
+pre {
+    border-width: 1px;
+    border-color: #777;
+    border-style: solid;
+    padding: 0.5em;
+    background-color: #ccc;
+    overflow: auto;
+    color: #000;
+    font-weight: bold;
+}
+
+p, li {
+    font-size: 13px;
+    line-height: 18px;
+}
diff --git a/canutils/terminal.h b/canutils/terminal.h
new file mode 100644
index 0000000000..198b48ec0d
--- /dev/null
+++ b/canutils/terminal.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Send feedback to <linux-can@vger.kernel.org>
+ *
+ */
+
+#ifndef TERMINAL_H
+#define TERMINAL_H
+
+/* reset to default */
+
+#define ATTRESET "\33[0m"
+
+/* attributes */
+
+#define ATTBOLD      "\33[1m"
+#define ATTUNDERLINE "\33[4m"
+#define ATTBLINK     "\33[5m"
+#define ATTINVERSE   "\33[7m"
+#define ATTINVISIBLE "\33[8m"
+
+/* foreground colors */
+
+#define FGBLACK   "\33[30m"
+#define FGRED     "\33[31m"
+#define FGGREEN   "\33[32m"
+#define FGYELLOW  "\33[33m"
+#define FGBLUE    "\33[34m"
+#define FGMAGENTA "\33[35m"
+#define FGCYAN    "\33[36m"
+#define FGWHITE   "\33[37m"
+
+/* background colors */
+
+#define BGBLACK   "\33[40m"
+#define BGRED     "\33[41m"
+#define BGGREEN   "\33[42m"
+#define BGYELLOW  "\33[43m"
+#define BGBLUE    "\33[44m"
+#define BGMAGENTA "\33[45m"
+#define BGCYAN    "\33[46m"
+#define BGWHITE   "\33[47m"
+
+/* cursor */
+
+#define CSR_HOME  "\33[H"
+#define CSR_UP    "\33[A"
+#define CSR_DOWN  "\33[B"
+#define CSR_RIGHT "\33[C"
+#define CSR_LEFT  "\33[D"
+
+#define CSR_HIDE  "\33[?25l"
+#define CSR_SHOW  "\33[?25h"
+
+/* clear screen */
+
+#define CLR_SCREEN  "\33[2J"
+
+#endif /* TERMINAL_H */
diff --git a/canutils/testj1939.c b/canutils/testj1939.c
new file mode 100644
index 0000000000..a59be4ac01
--- /dev/null
+++ b/canutils/testj1939.c
@@ -0,0 +1,316 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2013 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <errno.h>
+#include <inttypes.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include <err.h>
+#include <getopt.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#include "libj1939.h"
+
+static const char help_msg[] =
+	"testj1939: demonstrate j1939 use\n"
+	"Usage: testj1939 [OPTIONS] FROM TO\n"
+	" FROM / TO	- or [IFACE][:[SA][,[PGN][,NAME]]]\n"
+	"Options:\n"
+	" -v		Print relevant API calls\n"
+	" -s[=LEN]	Initial send of LEN bytes dummy data\n"
+	" -r		Receive (and print) data\n"
+	" -e		Echo incoming packets back\n"
+	"		This actually receives packets\n"
+	" -c		Issue connect()\n"
+	" -p=PRIO	Set priority to PRIO\n"
+	" -P		Promiscuous mode. Allow to receive all packets\n"
+	" -b		Do normal bind with SA+1 and rebind with actual SA\n"
+	" -B		Allow to send and receive broadcast packets.\n"
+	" -o		Omit bind\n"
+	" -n		Emit 64bit NAMEs in output\n"
+	" -w[TIME]	Return after TIME (default 1) seconds\n"
+	"\n"
+	"Examples:\n"
+	"testj1939 can1 20\n"
+	"\n"
+	;
+
+static const char optstring[] = "?vbBPos::rep:cnw::";
+
+static void onsigalrm(int sig)
+{
+	err(0, "exit as requested");
+	exit(0);
+}
+
+static void schedule_oneshot_itimer(double delay)
+{
+	struct itimerval it = { 0 };
+
+	it.it_value.tv_sec = delay;
+	it.it_value.tv_usec = (long)(delay * 1e6) % 1000000;
+	if (setitimer(ITIMER_REAL, &it, NULL) < 0)
+		err(1, "schedule itimer %.3lfs", delay);
+}
+
+/* main */
+int main(int argc, char *argv[])
+{
+	int ret, sock, opt;
+	unsigned int j;
+	int verbose = 0;
+	socklen_t peernamelen;
+	struct sockaddr_can sockname = {
+		.can_family = AF_CAN,
+		.can_addr.j1939 = {
+			.addr = J1939_NO_ADDR,
+			.name = J1939_NO_NAME,
+			.pgn = J1939_NO_PGN,
+		},
+	}, peername = {
+		.can_family = AF_CAN,
+		.can_addr.j1939 = {
+			.addr = J1939_NO_ADDR,
+			.name = J1939_NO_NAME,
+			.pgn = J1939_NO_PGN,
+		},
+	};
+	uint8_t dat[128];
+	int valid_peername = 0;
+	unsigned int todo_send = 0;
+	int todo_recv = 0, todo_echo = 0, todo_prio = -1;
+	int todo_connect = 0, todo_names = 0, todo_wait = 0, todo_rebind = 0;
+	int todo_broadcast = 0, todo_promisc = 0;
+	int no_bind = 0;
+
+	/* argument parsing */
+	while ((opt = getopt(argc, argv, optstring)) != -1)
+		switch (opt) {
+		case 'v':
+			verbose = 1;
+			break;
+		case 's':
+			todo_send = strtoul(optarg ?: "8", NULL, 0);
+			if (todo_send > sizeof(dat))
+				err(1, "Unsupported size. max: %zu",
+				    sizeof(dat));
+			break;
+		case 'r':
+			todo_recv = 1;
+			break;
+		case 'e':
+			todo_echo = 1;
+			break;
+		case 'p':
+			todo_prio = strtoul(optarg, NULL, 0);
+			break;
+		case 'P':
+			todo_promisc = 1;
+			break;
+		case 'c':
+			todo_connect = 1;
+			break;
+		case 'n':
+			todo_names = 1;
+			break;
+		case 'b':
+			todo_rebind = 1;
+			break;
+		case 'B':
+			todo_broadcast = 1;
+			break;
+		case 'o':
+			no_bind = 1;
+			break;
+		case 'w':
+			schedule_oneshot_itimer(strtod(optarg ?: "1", NULL));
+			signal(SIGALRM, onsigalrm);
+			todo_wait = 1;
+			break;
+		default:
+			fputs(help_msg, stderr);
+			exit(1);
+			break;
+		}
+
+	if (argv[optind]) {
+		if (strcmp("-", argv[optind]) != 0)
+			libj1939_parse_canaddr(argv[optind], &sockname);
+		++optind;
+	}
+
+	if (todo_rebind)
+		sockname.can_addr.j1939.addr++;
+
+	if (argv[optind]) {
+		if (strcmp("-", argv[optind]) != 0) {
+			libj1939_parse_canaddr(argv[optind], &peername);
+			valid_peername = 1;
+		}
+		++optind;
+	}
+
+	/* open socket */
+	if (verbose)
+		fprintf(stderr, "- socket(PF_CAN, SOCK_DGRAM, CAN_J1939);\n");
+	sock = ret = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+	if (ret < 0)
+		err(1, "socket(j1939)");
+
+	if (todo_promisc) {
+		if (verbose)
+			fprintf(stderr, "- setsockopt(, SOL_SOCKET, SO_J1939_PROMISC, %d, %zd);\n",
+				todo_promisc, sizeof(todo_promisc));
+		ret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_PROMISC,
+				 &todo_promisc, sizeof(todo_promisc));
+		if (ret < 0)
+			err(1, "setsockopt: filed to set promiscuous mode");
+	}
+
+	if (todo_broadcast) {
+		if (verbose)
+			fprintf(stderr, "- setsockopt(, SOL_SOCKET, SO_BROADCAST, %d, %zd);\n",
+				todo_broadcast, sizeof(todo_broadcast));
+		ret = setsockopt(sock, SOL_SOCKET, SO_BROADCAST,
+				 &todo_broadcast, sizeof(todo_broadcast));
+		if (ret < 0)
+			err(1, "setsockopt: filed to set broadcast");
+	}
+
+	if (todo_prio >= 0) {
+		if (verbose)
+			fprintf(stderr, "- setsockopt(, SOL_CAN_J1939, SO_J1939_SEND_PRIO, &%i);\n", todo_prio);
+		ret = setsockopt(sock, SOL_CAN_J1939, SO_J1939_SEND_PRIO,
+				&todo_prio, sizeof(todo_prio));
+		if (ret < 0)
+			err(1, "set priority %i", todo_prio);
+	}
+
+	if (!no_bind) {
+
+		if (verbose)
+			fprintf(stderr, "- bind(, %s, %zi);\n", libj1939_addr2str(&sockname), sizeof(sockname));
+		ret = bind(sock, (void *)&sockname, sizeof(sockname));
+		if (ret < 0)
+			err(1, "bind()");
+
+		if (todo_rebind) {
+			/* rebind with actual SA */
+			sockname.can_addr.j1939.addr--;
+
+			if (verbose)
+				fprintf(stderr, "- bind(, %s, %zi);\n", libj1939_addr2str(&sockname), sizeof(sockname));
+			ret = bind(sock, (void *)&sockname, sizeof(sockname));
+			if (ret < 0)
+				err(1, "re-bind()");
+		}
+	}
+
+	if (todo_connect) {
+		if (!valid_peername)
+			err(1, "no peername supplied");
+		if (verbose)
+			fprintf(stderr, "- connect(, %s, %zi);\n", libj1939_addr2str(&peername), sizeof(peername));
+		ret = connect(sock, (void *)&peername, sizeof(peername));
+		if (ret < 0)
+			err(1, "connect()");
+	}
+
+	if (todo_send) {
+		/* initialize test vector */
+		for (j = 0; j < sizeof(dat); ++j)
+			dat[j] = ((2*j) << 4) + ((2*j+1) & 0xf);
+
+		/* send data */
+		/*
+		 * when using connect, do not provide additional
+		 * destination information and use send()
+		 */
+		if (valid_peername && !todo_connect) {
+			if (verbose)
+				fprintf(stderr, "- sendto(, <dat>, %i, 0, %s, %zi);\n", todo_send, libj1939_addr2str(&peername), sizeof(peername));
+			ret = sendto(sock, dat, todo_send, 0,
+					(void *)&peername, sizeof(peername));
+		} else {
+			/*
+			 * we may do sendto(sock, dat, todo_send, 0, NULL, 0)
+			 * as well, but using send() demonstrates the API better
+			 */
+			if (verbose)
+				fprintf(stderr, "- send(, <dat>, %i, 0);\n", todo_send);
+			ret = send(sock, dat, todo_send, 0);
+		}
+
+		if (ret < 0)
+			err(1, "sendto");
+	}
+
+	/* main loop */
+	if ((todo_echo || todo_recv) && verbose)
+		fprintf(stderr, "- while (1)\n");
+	while (todo_echo || todo_recv) {
+		/*
+		 * re-use peername for storing the sender's peername of
+		 * received packets
+		 */
+		if (verbose)
+			fprintf(stderr, "- recvfrom(, <dat>, %zi, 0, &<peername>, %zi);\n", sizeof(peername), sizeof(peername));
+		peernamelen = sizeof(peername);
+		ret = recvfrom(sock, dat, sizeof(dat), 0,
+				(void *)&peername, &peernamelen);
+		if (ret < 0) {
+			if (EINTR == errno) {
+				if (verbose)
+					fprintf(stderr, "-\t<interrupted>\n");
+				continue;
+			}
+			err(1, "recvfrom()");
+		}
+
+		if (todo_echo) {
+			if (verbose)
+				fprintf(stderr, "- sendto(, <dat>, %i, 0, %s, %i);\n", ret, libj1939_addr2str(&peername), peernamelen);
+			ret = sendto(sock, dat, ret, 0,
+					(void *)&peername, peernamelen);
+			if (ret < 0)
+				err(1, "sendto");
+		}
+		if (todo_recv) {
+			int i;
+
+			if (todo_names && peername.can_addr.j1939.name)
+				printf("%016llx ", peername.can_addr.j1939.name);
+			printf("%02x %05x:", peername.can_addr.j1939.addr,
+					peername.can_addr.j1939.pgn);
+			for (i = 0, j = 0; i < ret; ++i, j++) {
+				if (j == 8) {
+					printf("\n%05x    ", i);
+					j = 0;
+				}
+				printf(" %02x", dat[i]);
+			}
+			printf("\n");
+		}
+	}
+	if (todo_wait)
+		for (;;)
+			sleep(1);
+	return 0;
+}
+
diff --git a/spidevtest/Android.bp b/spidevtest/Android.bp
new file mode 100644
index 0000000000..9f3f1fcfc0
--- /dev/null
+++ b/spidevtest/Android.bp
@@ -0,0 +1,57 @@
+// Copyright (C) 2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_applicable_licenses: ["external_spidevtest_license"],
+}
+
+// Added automatically by a large-scale-change that took the approach of
+// 'apply every license found to every target'. While this makes sure we respect
+// every license restriction, it may not be entirely correct.
+//
+// e.g. GPL in an MIT project might only apply to the contrib/ directory.
+//
+// Please consider splitting the single license below into multiple licenses,
+// taking care not to lose any license_kind information, and overriding the
+// default license using the 'licenses: [...]' property on targets as needed.
+//
+// For unused files, consider creating a 'fileGroup' with "//visibility:private"
+// to attach the license to, and including a comment whether the files may be
+// used in the current project.
+// See: http://go/android-license-faq
+license {
+    name: "external_spidevtest_license",
+    visibility: [":__subpackages__"],
+    license_kinds: [
+        "SPDX-license-identifier-BSD",
+        "SPDX-license-identifier-MIT",
+        "SPDX-license-identifier-NCSA",
+        "legacy_notice",
+        "legacy_unencumbered",
+    ],
+    license_text: [
+        "LICENSE",
+    ],
+}
+
+
+cc_binary {
+    name: "spidevtest",
+    srcs: [
+        "src/*.c",
+    ],
+    cflags: [
+        "-Wno-unused-parameter",
+    ],
+}
diff --git a/spidevtest/LICENSE b/spidevtest/LICENSE
new file mode 100644
index 0000000000..3ae3bbf3f0
--- /dev/null
+++ b/spidevtest/LICENSE
@@ -0,0 +1,244 @@
+"iperf, Copyright (c) 2014-2020, The Regents of the University of California,
+through Lawrence Berkeley National Laboratory (subject to receipt of any 
+required approvals from the U.S. Dept. of Energy).  All rights reserved."
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+(1) Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+
+(2) Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation and/
+or other materials provided with the distribution.
+
+(3) Neither the name of the University of California, Lawrence Berkeley
+National Laboratory, U.S. Dept. of Energy nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+You are under no obligation whatsoever to provide any bug fixes, patches, or
+upgrades to the features, functionality or performance of the source code
+("Enhancements") to anyone; however, if you choose to make your Enhancements
+available either publicly, or directly to Lawrence Berkeley National
+Laboratory, without imposing a separate written license agreement for such
+Enhancements, then you hereby grant the following license: a  non-exclusive,
+royalty-free perpetual license to install, use, modify, prepare derivative
+works, incorporate into other computer software, distribute, and sublicense
+such enhancements or derivative works thereof, in binary and source code form.
+
+=====
+
+This software contains source code (src/cjson.{c,h}) that is:
+
+  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+
+=====
+
+This software contains source code (src/net.{c,h}) that is:
+
+  This software was developed as part of a project at MIT.
+
+  Copyright (c) 2005-2007 Russ Cox,
+		     Massachusetts Institute of Technology
+
+  Permission is hereby granted, free of charge, to any person obtaining
+  a copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, sublicense, and/or sell copies of the Software, and to
+  permit persons to whom the Software is furnished to do so, subject to
+  the following conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  ===
+
+  Contains parts of an earlier library that has:
+
+  /*
+   * The authors of this software are Rob Pike, Sape Mullender, and Russ Cox
+   *              Copyright (c) 2003 by Lucent Technologies.
+   * Permission to use, copy, modify, and distribute this software for any
+   * purpose without fee is hereby granted, provided that this entire notice
+   * is included in all copies of any software which is or includes a copy
+   * or modification of this software and in all copies of the supporting
+   * documentation for such software.
+   * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+   * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT TECHNOLOGIES MAKE ANY
+   * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
+   * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+  */
+
+=====
+
+This software contains source code (src/net.c) that is:
+
+/*
+ * Copyright (c) 2001 Eric Jackson <ericj@monkey.org>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+=====
+
+This software contains source code (src/queue.h) that is:
+
+  /*
+   * Copyright (c) 1991, 1993
+   *      The Regents of the University of California.  All rights reserved.
+   *
+   * Redistribution and use in source and binary forms, with or without
+   * modification, are permitted provided that the following conditions
+   * are met:
+   * 1. Redistributions of source code must retain the above copyright
+   *    notice, this list of conditions and the following disclaimer.
+   * 2. Redistributions in binary form must reproduce the above copyright
+   *    notice, this list of conditions and the following disclaimer in the
+   *    documentation and/or other materials provided with the distribution.
+   * 3. Neither the name of the University nor the names of its contributors
+   *    may be used to endorse or promote products derived from this software
+   *    without specific prior written permission.
+   *
+   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   * SUCH DAMAGE.
+   *
+   *      @(#)queue.h     8.5 (Berkeley) 8/20/94
+   */
+
+=====
+
+This software contains source code (src/units.{c.h}) that is:
+
+  /*---------------------------------------------------------------
+   * Copyright (c) 1999,2000,2001,2002,2003
+   * The Board of Trustees of the University of Illinois
+   * All Rights Reserved.
+   *---------------------------------------------------------------
+   * Permission is hereby granted, free of charge, to any person
+   * obtaining a copy of this software (Iperf) and associated
+   * documentation files (the "Software"), to deal in the Software
+   * without restriction, including without limitation the
+   * rights to use, copy, modify, merge, publish, distribute,
+   * sublicense, and/or sell copies of the Software, and to permit
+   * persons to whom the Software is furnished to do
+   * so, subject to the following conditions:
+   *
+   *
+   * Redistributions of source code must retain the above
+   * copyright notice, this list of conditions and
+   * the following disclaimers.
+   *
+   *
+   * Redistributions in binary form must reproduce the above
+   * copyright notice, this list of conditions and the following
+   * disclaimers in the documentation and/or other materials
+   * provided with the distribution.
+   *
+   *
+   * Neither the names of the University of Illinois, NCSA,
+   * nor the names of its contributors may be used to endorse
+   * or promote products derived from this Software without
+   * specific prior written permission.
+   *
+   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+   * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   * NONINFRINGEMENT. IN NO EVENT SHALL THE CONTIBUTORS OR COPYRIGHT
+   * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+   * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+   * ________________________________________________________________
+   * National Laboratory for Applied Network Research
+   * National Center for Supercomputing Applications
+   * University of Illinois at Urbana-Champaign
+   * http://www.ncsa.uiuc.edu
+   * ________________________________________________________________
+   *
+   * stdio.c
+   * by Mark Gates <mgates@nlanr.net>
+   * and Ajay Tirumalla <tirumala@ncsa.uiuc.edu>
+   * -------------------------------------------------------------------
+   * input and output numbers, converting with kilo, mega, giga
+   * ------------------------------------------------------------------- */
+
+=====
+
+This software contains source code (src/portable_endian.h) that is:
+
+// "License": Public Domain
+// I, Mathias Panzenb√∂ck, place this file hereby into the public domain. Use it at your own risk for whatever you like.
+
+=====
+
+
+
diff --git a/spidevtest/spdev_refer b/spidevtest/spdev_refer
new file mode 100644
index 0000000000..217ea4f001
--- /dev/null
+++ b/spidevtest/spdev_refer
@@ -0,0 +1,19 @@
+LOCAL_PATH := $(call my-dir)
+
+PRIVATE_LOCAL_CFLAGS := -O2 -g -W -Wall		\
+			-Wno-error=unused-parameter
+
+#
+# spidev_test
+#
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := spidev_test.c
+LOCAL_MODULE := spidev_test
+LOCAL_MODULE_TAGS := optional
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include/
+LOCAL_CFLAGS := $(PRIVATE_LOCAL_CFLAGS)
+LOCAL_VENDOR_MODULE := true
+
+include $(BUILD_EXECUTABLE)
diff --git a/spidevtest/src/spidev_test.c b/spidevtest/src/spidev_test.c
new file mode 100644
index 0000000000..079c436767
--- /dev/null
+++ b/spidevtest/src/spidev_test.c
@@ -0,0 +1,498 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * SPI testing utility (using spidev driver)
+ *
+ * Copyright (c) 2007  MontaVista Software, Inc.
+ * Copyright (c) 2007  Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * Cross-compile with cross-gcc -I/path/to/cross-kernel/include
+ */
+
+#include <stdint.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <getopt.h>
+#include <fcntl.h>
+#include <time.h>
+#include <sys/ioctl.h>
+#include <linux/ioctl.h>
+#include <sys/stat.h>
+#include <linux/types.h>
+#include <linux/spi/spidev.h>
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+#define	SPI_TX_OCTAL	0x2000			/* transmit with 8 wires */
+#define	SPI_RX_OCTAL	0x4000			/* receive with 8 wires */
+
+static void pabort(const char *s)
+{
+	if (errno != 0)
+		perror(s);
+	else
+		printf("%s\n", s);
+
+	abort();
+}
+
+static const char *device = "/dev/spidev1.1";
+static uint32_t mode;
+static uint8_t bits = 8;
+static char *input_file;
+static char *output_file;
+static uint32_t speed = 500000;
+static uint16_t delay;
+static int verbose;
+static int transfer_size;
+static int iterations;
+static int interval = 5; /* interval in seconds for showing transfer rate */
+
+static uint8_t default_tx[] = {
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0x40, 0x00, 0x00, 0x00, 0x00, 0x95,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xF0, 0x0D,
+};
+
+static uint8_t default_rx[ARRAY_SIZE(default_tx)] = {0, };
+static char *input_tx;
+
+static void hex_dump(const void *src, size_t length, size_t line_size,
+		     char *prefix)
+{
+	int i = 0;
+	const unsigned char *address = src;
+	const unsigned char *line = address;
+	unsigned char c;
+
+	printf("%s | ", prefix);
+	while (length-- > 0) {
+		printf("%02X ", *address++);
+		if (!(++i % line_size) || (length == 0 && i % line_size)) {
+			if (length == 0) {
+				while (i++ % line_size)
+					printf("__ ");
+			}
+			printf(" |");
+			while (line < address) {
+				c = *line++;
+				printf("%c", (c < 32 || c > 126) ? '.' : c);
+			}
+			printf("|\n");
+			if (length > 0)
+				printf("%s | ", prefix);
+		}
+	}
+}
+
+/*
+ *  Unescape - process hexadecimal escape character
+ *      converts shell input "\x23" -> 0x23
+ */
+static int unescape(char *_dst, char *_src, size_t len)
+{
+	int ret = 0;
+	int match;
+	char *src = _src;
+	char *dst = _dst;
+	unsigned int ch;
+
+	while (*src) {
+		if (*src == '\\' && *(src+1) == 'x') {
+			match = sscanf(src + 2, "%2x", &ch);
+			if (!match)
+				pabort("malformed input string");
+
+			src += 4;
+			*dst++ = (unsigned char)ch;
+		} else {
+			*dst++ = *src++;
+		}
+		ret++;
+	}
+	return ret;
+}
+
+static void transfer(int fd, uint8_t const *tx, uint8_t const *rx, size_t len)
+{
+	int ret;
+	int out_fd;
+	struct spi_ioc_transfer tr = {
+		.tx_buf = (unsigned long)tx,
+		.rx_buf = (unsigned long)rx,
+		.len = len,
+		.delay_usecs = delay,
+		.speed_hz = speed,
+		.bits_per_word = bits,
+	};
+
+	if (mode & SPI_TX_OCTAL)
+		tr.tx_nbits = 8;
+	else if (mode & SPI_TX_QUAD)
+		tr.tx_nbits = 4;
+	else if (mode & SPI_TX_DUAL)
+		tr.tx_nbits = 2;
+	if (mode & SPI_RX_OCTAL)
+		tr.rx_nbits = 8;
+	else if (mode & SPI_RX_QUAD)
+		tr.rx_nbits = 4;
+	else if (mode & SPI_RX_DUAL)
+		tr.rx_nbits = 2;
+	if (!(mode & SPI_LOOP)) {
+		if (mode & (SPI_TX_OCTAL | SPI_TX_QUAD | SPI_TX_DUAL))
+			tr.rx_buf = 0;
+		else if (mode & (SPI_RX_OCTAL | SPI_RX_QUAD | SPI_RX_DUAL))
+			tr.tx_buf = 0;
+	}
+
+	ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
+	if (ret < 1)
+		pabort("can't send spi message");
+
+	if (verbose)
+		hex_dump(tx, len, 32, "TX");
+
+	if (output_file) {
+		out_fd = open(output_file, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+		if (out_fd < 0)
+			pabort("could not open output file");
+
+		ret = write(out_fd, rx, len);
+		if (ret != (int)len)
+			pabort("not all bytes written to output file");
+
+		close(out_fd);
+	}
+
+	if (verbose)
+		hex_dump(rx, len, 32, "RX");
+}
+
+static void print_usage(const char *prog)
+{
+	printf("Usage: %s [-DsbdlHOLC3vpNR24SI]\n", prog);
+	puts("  -D --device   device to use (default /dev/spidev1.1)\n"
+	     "  -s --speed    max speed (Hz)\n"
+	     "  -d --delay    delay (usec)\n"
+	     "  -b --bpw      bits per word\n"
+	     "  -i --input    input data from a file (e.g. \"test.bin\")\n"
+	     "  -o --output   output data to a file (e.g. \"results.bin\")\n"
+	     "  -l --loop     loopback\n"
+	     "  -H --cpha     clock phase\n"
+	     "  -O --cpol     clock polarity\n"
+	     "  -L --lsb      least significant bit first\n"
+	     "  -C --cs-high  chip select active high\n"
+	     "  -3 --3wire    SI/SO signals shared\n"
+	     "  -v --verbose  Verbose (show tx buffer)\n"
+	     "  -p            Send data (e.g. \"1234\\xde\\xad\")\n"
+	     "  -N --no-cs    no chip select\n"
+	     "  -R --ready    slave pulls low to pause\n"
+	     "  -2 --dual     dual transfer\n"
+	     "  -4 --quad     quad transfer\n"
+	     "  -8 --octal    octal transfer\n"
+	     "  -S --size     transfer size\n"
+	     "  -I --iter     iterations\n");
+	exit(1);
+}
+
+static void parse_opts(int argc, char *argv[])
+{
+	while (1) {
+		static const struct option lopts[] = {
+			{ "device",  1, 0, 'D' },
+			{ "speed",   1, 0, 's' },
+			{ "delay",   1, 0, 'd' },
+			{ "bpw",     1, 0, 'b' },
+			{ "input",   1, 0, 'i' },
+			{ "output",  1, 0, 'o' },
+			{ "loop",    0, 0, 'l' },
+			{ "cpha",    0, 0, 'H' },
+			{ "cpol",    0, 0, 'O' },
+			{ "lsb",     0, 0, 'L' },
+			{ "cs-high", 0, 0, 'C' },
+			{ "3wire",   0, 0, '3' },
+			{ "no-cs",   0, 0, 'N' },
+			{ "ready",   0, 0, 'R' },
+			{ "dual",    0, 0, '2' },
+			{ "verbose", 0, 0, 'v' },
+			{ "quad",    0, 0, '4' },
+			{ "octal",   0, 0, '8' },
+			{ "size",    1, 0, 'S' },
+			{ "iter",    1, 0, 'I' },
+			{ NULL, 0, 0, 0 },
+		};
+		int c;
+
+		c = getopt_long(argc, argv, "D:s:d:b:i:o:lHOLC3NR248p:vS:I:",
+				lopts, NULL);
+
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'D':
+			device = optarg;
+			break;
+		case 's':
+			speed = atoi(optarg);
+			break;
+		case 'd':
+			delay = atoi(optarg);
+			break;
+		case 'b':
+			bits = atoi(optarg);
+			break;
+		case 'i':
+			input_file = optarg;
+			break;
+		case 'o':
+			output_file = optarg;
+			break;
+		case 'l':
+			mode |= SPI_LOOP;
+			break;
+		case 'H':
+			mode |= SPI_CPHA;
+			break;
+		case 'O':
+			mode |= SPI_CPOL;
+			break;
+		case 'L':
+			mode |= SPI_LSB_FIRST;
+			break;
+		case 'C':
+			mode |= SPI_CS_HIGH;
+			break;
+		case '3':
+			mode |= SPI_3WIRE;
+			break;
+		case 'N':
+			mode |= SPI_NO_CS;
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		case 'R':
+			mode |= SPI_READY;
+			break;
+		case 'p':
+			input_tx = optarg;
+			break;
+		case '2':
+			mode |= SPI_TX_DUAL;
+			break;
+		case '4':
+			mode |= SPI_TX_QUAD;
+			break;
+		case '8':
+			mode |= SPI_TX_OCTAL;
+			break;
+		case 'S':
+			transfer_size = atoi(optarg);
+			break;
+		case 'I':
+			iterations = atoi(optarg);
+			break;
+		default:
+			print_usage(argv[0]);
+		}
+	}
+	if (mode & SPI_LOOP) {
+		if (mode & SPI_TX_DUAL)
+			mode |= SPI_RX_DUAL;
+		if (mode & SPI_TX_QUAD)
+			mode |= SPI_RX_QUAD;
+		if (mode & SPI_TX_OCTAL)
+			mode |= SPI_RX_OCTAL;
+	}
+}
+
+static void transfer_escaped_string(int fd, char *str)
+{
+	size_t size = strlen(str);
+	uint8_t *tx;
+	uint8_t *rx;
+
+	tx = malloc(size);
+	if (!tx)
+		pabort("can't allocate tx buffer");
+
+	rx = malloc(size);
+	if (!rx)
+		pabort("can't allocate rx buffer");
+
+	size = unescape((char *)tx, str, size);
+	transfer(fd, tx, rx, size);
+	free(rx);
+	free(tx);
+}
+
+static void transfer_file(int fd, char *filename)
+{
+	ssize_t bytes;
+	struct stat sb;
+	int tx_fd;
+	uint8_t *tx;
+	uint8_t *rx;
+
+	if (stat(filename, &sb) == -1)
+		pabort("can't stat input file");
+
+	tx_fd = open(filename, O_RDONLY);
+	if (tx_fd < 0)
+		pabort("can't open input file");
+
+	tx = malloc(sb.st_size);
+	if (!tx)
+		pabort("can't allocate tx buffer");
+
+	rx = malloc(sb.st_size);
+	if (!rx)
+		pabort("can't allocate rx buffer");
+
+	bytes = read(tx_fd, tx, sb.st_size);
+	if (bytes != sb.st_size)
+		pabort("failed to read input file");
+
+	transfer(fd, tx, rx, sb.st_size);
+	free(rx);
+	free(tx);
+	close(tx_fd);
+}
+
+static uint64_t _read_count;
+static uint64_t _write_count;
+
+static void show_transfer_rate(void)
+{
+	static uint64_t prev_read_count, prev_write_count;
+	double rx_rate, tx_rate;
+
+	rx_rate = ((_read_count - prev_read_count) * 8) / (interval*1000.0);
+	tx_rate = ((_write_count - prev_write_count) * 8) / (interval*1000.0);
+
+	printf("rate: tx %.1fkbps, rx %.1fkbps\n", rx_rate, tx_rate);
+
+	prev_read_count = _read_count;
+	prev_write_count = _write_count;
+}
+
+static void transfer_buf(int fd, int len)
+{
+	uint8_t *tx;
+	uint8_t *rx;
+	int i;
+
+	tx = malloc(len);
+	if (!tx)
+		pabort("can't allocate tx buffer");
+	for (i = 0; i < len; i++)
+		tx[i] = random();
+
+	rx = malloc(len);
+	if (!rx)
+		pabort("can't allocate rx buffer");
+
+	transfer(fd, tx, rx, len);
+
+	_write_count += len;
+	_read_count += len;
+
+	if (mode & SPI_LOOP) {
+		if (memcmp(tx, rx, len)) {
+			fprintf(stderr, "transfer error !\n");
+			hex_dump(tx, len, 32, "TX");
+			hex_dump(rx, len, 32, "RX");
+			exit(1);
+		}
+	}
+
+	free(rx);
+	free(tx);
+}
+
+int main(int argc, char *argv[])
+{
+	int ret = 0;
+	int fd;
+
+	parse_opts(argc, argv);
+
+	if (input_tx && input_file)
+		pabort("only one of -p and --input may be selected");
+
+	fd = open(device, O_RDWR);
+	if (fd < 0)
+		pabort("can't open device");
+
+	/*
+	 * spi mode
+	 */
+	ret = ioctl(fd, SPI_IOC_WR_MODE32, &mode);
+	if (ret == -1)
+		pabort("can't set spi mode");
+
+	ret = ioctl(fd, SPI_IOC_RD_MODE32, &mode);
+	if (ret == -1)
+		pabort("can't get spi mode");
+
+	/*
+	 * bits per word
+	 */
+	ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);
+	if (ret == -1)
+		pabort("can't set bits per word");
+
+	ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);
+	if (ret == -1)
+		pabort("can't get bits per word");
+
+	/*
+	 * max speed hz
+	 */
+	ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);
+	if (ret == -1)
+		pabort("can't set max speed hz");
+
+	ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);
+	if (ret == -1)
+		pabort("can't get max speed hz");
+
+	printf("spi mode: 0x%x\n", mode);
+	printf("bits per word: %u\n", bits);
+	printf("max speed: %u Hz (%u kHz)\n", speed, speed/1000);
+
+	if (input_tx)
+		transfer_escaped_string(fd, input_tx);
+	else if (input_file)
+		transfer_file(fd, input_file);
+	else if (transfer_size) {
+		struct timespec last_stat;
+
+		clock_gettime(CLOCK_MONOTONIC, &last_stat);
+
+		while (iterations-- > 0) {
+			struct timespec current;
+
+			transfer_buf(fd, transfer_size);
+
+			clock_gettime(CLOCK_MONOTONIC, &current);
+			if (current.tv_sec - last_stat.tv_sec > interval) {
+				show_transfer_rate();
+				last_stat = current;
+			}
+		}
+		printf("total: tx %.1fKB, rx %.1fKB\n",
+		       _write_count/1024.0, _read_count/1024.0);
+	} else
+		transfer(fd, default_tx, default_rx, sizeof(default_tx));
+
+	close(fd);
+
+	return ret;
+}
